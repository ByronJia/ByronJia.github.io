<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 27 Dec 2020 12:26:02 +0800</pubDate>
    <lastBuildDate>Sun, 27 Dec 2020 12:26:02 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Linux文件权限详解</title>
        <description>&lt;h3 id=&quot;查看文件权限&quot;&gt;查看文件权限：&lt;/h3&gt;
&lt;p&gt;ls -l  在目录下列出文件列表和权限信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--   1 byron  staff    89  8 11 10:47 OWNERS
-rwxr-xr-x   1 byron  staff  4034  8 11 10:47 ensure_gn_version.py
drwxr-xr-x   3 byron  staff    96  8 11 10:47 linux64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;权限信息通用格式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rwxr-xr-x　number　user　group　filesize　updatetime　filename
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通用格式分为7个部分，分别是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;文件属性，共10个字符,第1个表示类型，&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;表示文件， &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;表示文件夹。后9个字符分3组，分别表示对于当前用户，当前用户所在组，其他用户的 读/写/执行权限。 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;可读， &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;可写， &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;可执行 ，&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;无权限&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;表示文件的数量&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;表示当前用户名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;group&lt;/code&gt;表示当前用户所在组的名字&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filesize&lt;/code&gt;表示该文件大小，单位byte&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updatetime&lt;/code&gt;表示文件最后修改时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filename&lt;/code&gt; 文件名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面例子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;-rw-r--r--&lt;/code&gt; 表示OWNERS是一个文件，对当前用户有读写权限，没有执行权限， 当前用户所在组其他用户只有读权限，没有写和执行权限。
&lt;code class=&quot;highlighter-rouge&quot;&gt;drwxr-xr-x&lt;/code&gt;表示linux64是一个文件夹，对当前用户有读写执行权限，用户组和其他用户有读和执行权限，没有写权限，且文件夹中有3个文件。&lt;/p&gt;

&lt;h3 id=&quot;修改文件权限&quot;&gt;修改文件权限&lt;/h3&gt;
&lt;p&gt;修改权限的命令格式：
&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod &amp;lt;权限范围&amp;gt;&amp;lt;权限操作&amp;gt;&amp;lt;具体权限&amp;gt; &amp;lt;文件或目录&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;权限范围&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;u ： user,当前用户&lt;/li&gt;
  &lt;li&gt;g ：Group,当前用户所在组&lt;/li&gt;
  &lt;li&gt;o ：Other,其他用户&lt;/li&gt;
  &lt;li&gt;a ：All,全部用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;权限操作&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; ：增加权限,
&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; ：取消权限,
&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; ：设置拥有权限,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;具体权限&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;r ：可读&lt;/li&gt;
  &lt;li&gt;w ：可写&lt;/li&gt;
  &lt;li&gt;x ：可执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--  1 byron  staff  0 12 27 12:04 text.txt  // 文件原始权限
chmod u+x text.txt      // 执行修改权限
-rwxr--r--  1 byron  staff  0 12 27 12:04 text.txt  // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--  1 byron  staff  0 12 27 12:04 text.txt // 文件原始权限
chmod a=rwx text.txt    // 执行修改权限
-rwxrwxrwx  1 byron  staff  0 12 27 12:04 text.txt // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-rw-rw-  1 byron  staff  0 12 27 12:04 text.txt // 文件原始权限
chmod u+x-w text.txt    // 执行修改权限
-r-xrw-rw-  1 byron  staff  0 12 27 12:04 text.txt // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一种修改权限的命令格式：
&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod &amp;lt;数字&amp;gt; &amp;lt;文件名&amp;gt;&lt;/code&gt;
3位数字分别表示user, group,other的权限&lt;/p&gt;

&lt;p&gt;r = 4, w = 2, x = 1&lt;/p&gt;

&lt;p&gt;则 rwx为 4+2+1=7, rw-为 4+2=6, r-x为4+1=5,-wx为2+1=3等等&lt;/p&gt;

&lt;p&gt;所以我们常见的755代表&lt;code class=&quot;highlighter-rouge&quot;&gt;rwxr-xr-x&lt;/code&gt;,777代表&lt;code class=&quot;highlighter-rouge&quot;&gt;rwxrwxrwx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod a=rwx filename&lt;/code&gt; 可以简化为&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod 777 filename&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--  1 byron  staff  0 12 27 12:04 text.txt // 文件原始权限
chmod 777 text.txt    // 执行修改权限
-rwxrwxrwx  1 byron  staff  0 12 27 12:04 text.txt // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 24 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS App签名原理</title>
        <description>&lt;p&gt;iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。&lt;/p&gt;

&lt;h3 id=&quot;app签名10&quot;&gt;App签名1.0&lt;/h3&gt;
&lt;p&gt;要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079168080845.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。
但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;开发 App 时可以直接把开发中的应用安装进手机进行调试。&lt;/li&gt;
  &lt;li&gt;In-House 企业内部分发，可以直接安装企业证书签名后的 APP。&lt;/li&gt;
  &lt;li&gt;AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。
苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app签名20&quot;&gt;App签名2.0&lt;/h3&gt;
&lt;p&gt;我们先来看第一个，开发时安装APP，它有两个个需求：
安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。
苹果必须对这里的安装有控制权，包括
a. 经过苹果允许才可以这样安装。
b. 不能被滥用导致非开发app也能被安装。
为了实现这些需求，iOS 签名的复杂度也就开始增加了。
苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079168652311.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在你的 Mac 开发机器生成一对公私钥，这里称为&lt;code class=&quot;highlighter-rouge&quot;&gt;公钥L&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;私钥L&lt;/code&gt;。L:Local&lt;/li&gt;
  &lt;li&gt;苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为&lt;code class=&quot;highlighter-rouge&quot;&gt;公钥A&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;私钥A&lt;/code&gt;。A:Apple&lt;/li&gt;
  &lt;li&gt;把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。&lt;/li&gt;
  &lt;li&gt;在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。&lt;/li&gt;
  &lt;li&gt;在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。&lt;/li&gt;
  &lt;li&gt;验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app签名30&quot;&gt;App签名3.0&lt;/h3&gt;
&lt;p&gt;上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。
怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079169420158.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。&lt;/p&gt;

&lt;h3 id=&quot;app签名终版&quot;&gt;App签名终版&lt;/h3&gt;
&lt;p&gt;这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。
实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。
所以整个流程稍微变一下，就变成这样了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079170366343.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local&lt;/li&gt;
  &lt;li&gt;苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple&lt;/li&gt;
  &lt;li&gt;把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。&lt;/li&gt;
  &lt;li&gt;在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。&lt;/li&gt;
  &lt;li&gt;在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。&lt;/li&gt;
  &lt;li&gt;在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。&lt;/li&gt;
  &lt;li&gt;确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。&lt;/li&gt;
  &lt;li&gt;开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实际操作&quot;&gt;实际操作&lt;/h3&gt;
&lt;p&gt;上面的步骤对应到我们平常具体的操作和概念是这样的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。&lt;/li&gt;
  &lt;li&gt;第 2 步苹果处理，不用管。&lt;/li&gt;
  &lt;li&gt;第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。&lt;/li&gt;
  &lt;li&gt;第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。&lt;/li&gt;
  &lt;li&gt;第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。&lt;/li&gt;
  &lt;li&gt;第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里再总结一下这些概念：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;证书&lt;/code&gt;：内容是公钥或私钥，由其他机构对其签名组成的数据包。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Entitlements&lt;/code&gt;：包含了 App 权限开关列表。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CertificateSigningRequest&lt;/code&gt;：本地公钥。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p12&lt;/code&gt;：本地私钥，可以导入到其他电脑。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Provisioning Profile&lt;/code&gt;：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS-App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS-App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>音视频基础知识</title>
        <description>&lt;h3 id=&quot;码率&quot;&gt;码率：&lt;/h3&gt;
&lt;p&gt;也叫比特率， Bits per second 每秒传输的数据量。 可以理解成吞吐量或带宽。 目的是用最低的比特率达到最少的失真&lt;/p&gt;

&lt;p&gt;###帧率：
Frames per second 每秒显示帧数。&lt;/p&gt;

&lt;h3 id=&quot;常见编码标准&quot;&gt;常见编码标准:&lt;/h3&gt;
&lt;p&gt;MPEG-4， 其中第10部分提出新的视频编码方案，即与另一个组织共同开发的H.264。第三部分提出AAC音频编码方案，旨在替代MP3。  第14部分提出MP4封装格式包括音频编码方案和视频编码方案。&lt;/p&gt;

&lt;h3 id=&quot;h264&quot;&gt;H.264:&lt;/h3&gt;
&lt;p&gt;定义了三种帧，I帧 P帧 B帧
1）I 帧：I帧即帧内编码帧、关键帧，可以理解为一帧画面的完整保留，解码时只需要本帧数据就可以完成，不需要参考其他画面，数据量比较大；
2）P 帧：P帧即前向预测编码帧，记录当前帧跟上一关键帧（或P帧）的差别，解码时依赖之前缓存的画面，叠加上本帧定义的差别，才能生成最终画面，数据量较 I 帧小很多；
3）B 帧：B帧即双向预测编码帧，记录当前帧跟前后帧的差别，解码时依赖前面的I帧（或P帧）和后面的P帧，数据量比I帧和P帧小很多。
直播场景中一般不适用B帧，因为受到一个B帧后还要等待之后的P帧才能解码，会有滞后性。&lt;/p&gt;

&lt;p&gt;编码计算复杂度是H.263的3倍， 解码复杂度是H.263的2倍。但是相同视频 质量，可以比H.263节省50%码率&lt;/p&gt;

&lt;h3 id=&quot;h265&quot;&gt;H.265:&lt;/h3&gt;
&lt;p&gt;High Efficiency Video Coding 简称HEVC。  与H.264类似，包含帧内预测，帧间预测，转化，量化，滤波，熵编码等。
在H.264基础上使用先进技术用以改善码流，编码质量，延时和算法复杂度之间的关系。
在码率减少51-74%情况下，265的视频质量与264近似甚至更好。
iOS11开始原生支持HEVC   H.265&lt;/p&gt;

&lt;h3 id=&quot;gop&quot;&gt;GOP:&lt;/h3&gt;
&lt;p&gt;Group of Pictures 一组连续的画面，由一张I帧和多张B/P帧组成，是视频编解码存取的基本单位。GOP组的长度格式也决定了码流的大小,形容一个I帧到下一个I帧之间间隔多少帧，增大GOP能有效减少编码后视频体积，但也会降低视频质量。&lt;/p&gt;

&lt;h3 id=&quot;idr帧&quot;&gt;IDR帧：&lt;/h3&gt;
&lt;p&gt;一个序列的首个I帧叫做IDR帧，IDR帧都是I帧.
引入目的是为了解码的重同步,如果前序列出现重大错误，这里可以获得重新同步机会。
当解码到IDR帧时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始新序列。&lt;/p&gt;

&lt;h3 id=&quot;nal&quot;&gt;NAL:&lt;/h3&gt;
&lt;p&gt;Network abstract layer 网络抽象层&lt;/p&gt;

&lt;h3 id=&quot;sps&quot;&gt;SPS:&lt;/h3&gt;
&lt;p&gt;Sequence Parameter Set ，序列参数集，保存了一组编码视频序列的全局参数，一般SPS 和PPS在整个码流的起始位置，特殊情况下也可能在中间出现，例如中间需要重新解码，或者参数信息发生编发例如屏幕宽高比变化。&lt;/p&gt;

&lt;h3 id=&quot;pps&quot;&gt;PPS:&lt;/h3&gt;
&lt;p&gt;Picture Parameter Set  图形参数集，类似于SPS， 在马六周年单独保存在一个NAL Unit中，保存在视频文件的文件头中。&lt;/p&gt;

&lt;h3 id=&quot;dts&quot;&gt;DTS&lt;/h3&gt;
&lt;p&gt;Decoding Time Stamp 解码时间戳，表示送入解码器的顺序&lt;/p&gt;

&lt;h3 id=&quot;pts&quot;&gt;PTS&lt;/h3&gt;
&lt;p&gt;Presentation Time Stamp 显示时间戳，表示解码后的帧显示时间
在没有B帧情况下，DTS和PTS输出顺序一致。 因为B帧需要依赖后续的帧，所以B帧解码要在后续P帧之后，但是显示又在后续P帧之前&lt;/p&gt;

&lt;h3 id=&quot;音视频同步&quot;&gt;音视频同步：&lt;/h3&gt;
&lt;p&gt;音频没有类似视频中的B帧，所以音频帧的DTS 和PTS顺序是一致的。
通常需要选择一个参考时钟，参考时间的时间是线性递增的，编码音视频流时一句参考时钟上的时间给每个数据打上时间戳，播放时读取数据帧上的时间戳，同时参考PTS安排播放。&lt;/p&gt;

&lt;h3 id=&quot;视频传输协议优化&quot;&gt;视频传输协议优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;服务端节点之间尽量使用RTMP，降低整体传输延迟&lt;/li&gt;
  &lt;li&gt;如果终端使用RTMP播放，应该在尽量靠近收流节点进行转码，这样传输的视频流从一开始就是最优大小&lt;/li&gt;
  &lt;li&gt;如有必要，使用定制的UDP协议替换TCP协议，省去弱网环境下的丢包重传。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;视频传输网络优化&quot;&gt;视频传输网络优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在服务端节点中缓存GOP，配合播放器端的首开优化&lt;/li&gt;
  &lt;li&gt;服务端实时记录每个视频流在每个环节的帧率和码率，检测波动&lt;/li&gt;
  &lt;li&gt;客户端通过查询服务端准实时获取当前最优节点(5秒一次)， 准实时下线当前故障节点和线路&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;推流播放优化&quot;&gt;推流、播放优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;考察发送端系统的网络buffer大小&lt;/li&gt;
  &lt;li&gt;播放端的缓存对首开延迟也有较大影响，甚至可以在0缓存的情况下，将第一帧数据直接解码显示。但是如果弱网状态下，需要考虑网络波动造成的卡顿，还是需要增加一定的缓存。&lt;/li&gt;
  &lt;li&gt;可以使用动态缓存策略，参考第一帧的下载耗时决定后续播放过程中的缓存大小。&lt;/li&gt;
  &lt;li&gt;动态码率，在增加缓存依然无法满足当前码率的情况下，采用动态码率，减少延迟，当网络有所改善后，再动态增加码率。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS Crash 分析</title>
        <description>&lt;h3 id=&quot;关于crash&quot;&gt;关于Crash&lt;/h3&gt;
&lt;p&gt;当app发生crash时，系统会生成crash report 存储在设备上，其中会描述app在何种情况下被系统终止，一般会包括完整的线程调用堆栈。包括以下2种report:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Crash report:包含堆栈信息，被符号化之前是运行内容中的实际函数地址，需要将report与 .dSYM或 .app共同分析出内存中的实际地址映射的函数方法，从而便于定位问题。&lt;/li&gt;
  &lt;li&gt;Low Memory report:没有堆栈信息，由于低内存引发crash，下面会详细介绍&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;符号化&quot;&gt;符号化&lt;/h3&gt;
&lt;p&gt;crash符号化常用的3个文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;symbolicatecrash：是系统提供的符号化执行程序，依赖于.dSYM、.crash 和.app  3个文件&lt;/li&gt;
  &lt;li&gt;.dSYM : 编译器在把你的源代码转换成机器码的同时，也会生成一份对应的Debug符号表,保存十六进制函数地址映射信息，通过他能得知log中的堆栈地址与具体方法的地址的映射关系&lt;/li&gt;
  &lt;li&gt;.crash : 是系统保存的崩溃日志文件，包括所有线程状态，和方法调用堆栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也可使用atos命令符号化， 只需要.crash和 .dSYM和app其中一个即可。
以下是符号化之前和符号化之后的堆栈信息，第3行符号化之后即可看到自己实现的函数名
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201211/16076544840576.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201211/16076544907887.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么系统函数的堆栈能打印出来？
因为系统函数的符号表在xcode中已经内置，且不同系统版本不一样，所以每次我们在升级xcode后，就会包含xcode支持的最新iOS系统的符号表。&lt;/p&gt;

&lt;h3 id=&quot;异常信息&quot;&gt;异常信息&lt;/h3&gt;
&lt;p&gt;carsh report 中的字段能提供异常信息，便于从宏观角度分析crash的原因。&lt;/p&gt;

&lt;p&gt;下面是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;uncaught Objective-C exception&lt;/code&gt;而导致的进程被停止的crash report的摘录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception Type: EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note: EXC_CORPSE_NOTIFY
Triggered by Thread: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是由于反向引用了一个NULL指针而造成进程被终止的crash report的摘录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000
Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [0]
Triggered by Thread: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中
&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Type&lt;/code&gt;: 异常类型，下面会详细定义不同类型的含义。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Codes&lt;/code&gt; ：和异常是有关的处理器指定信息，这些信息会被编码成一个或者多个64位二进制数字。一般来说，这个字段不应该存在，因为crash report生成时会把exception code转化成可读的信息并在其它字段进行体现。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Subtype&lt;/code&gt;：可读的exception code的名称。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Message&lt;/code&gt;：从exception code中解析出来的附加的可读信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Note&lt;/code&gt;：不特指某一种异常的额外信息。如果这个字段包含”SIMULATED”(不是Crash)，则进程并没有发生crash，而是在系统层面被kill掉了，比如看门狗机制。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Termination Reason&lt;/code&gt;：当进程被终止时的原因及信息。关键的信息模块，不论是进程内还是进程外，当遇到一个致命错误（fatal error，例如bad code signature，缺失依赖库，不恰当的访问私有敏感信息等）。MacOS Sierra,iOS 10, watch OS3和tvOS 10 已经采用新的架构去记录这些错误信息，所以这些系统之下的crash report会在Termination Reason这个字段里描述error message信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Triggered by Thread&lt;/code&gt;：指出异常是在哪个线程发生的&lt;/p&gt;

&lt;h3 id=&quot;看门狗&quot;&gt;看门狗&lt;/h3&gt;
&lt;p&gt;为了防止应用占用过多系统资源，看门狗机制能检测应用性能，若超出阈值，看门狗会强制终结这个应用的进程。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;触发时机&lt;/th&gt;
      &lt;th&gt;看门狗出动的时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;启动&lt;/td&gt;
      &lt;td&gt;20秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;恢复运行&lt;/td&gt;
      &lt;td&gt;10秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;挂起进程&lt;/td&gt;
      &lt;td&gt;10秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;退出应用&lt;/td&gt;
      &lt;td&gt;6秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;后台运行&lt;/td&gt;
      &lt;td&gt;10分钟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;常见异常类型&quot;&gt;常见异常类型&lt;/h3&gt;
&lt;h4 id=&quot;bad-memory-access-exc_bad_access--sigsegv--sigbus&quot;&gt;Bad Memory Access [EXC_BAD_ACCESS // SIGSEGV // SIGBUS]&lt;/h4&gt;
&lt;p&gt;进程试图访问无效的内存空间，或尝试访问的方法不允许(例如去写只读的内存空间)&lt;/p&gt;

&lt;h4 id=&quot;abnormal-exit-exc_crash--sigabrt&quot;&gt;Abnormal Exit [EXC_CRASH // SIGABRT]&lt;/h4&gt;
&lt;p&gt;进程异常退出，常见原因是&lt;code class=&quot;highlighter-rouge&quot;&gt;uncaught Objective-C/C++ exception&lt;/code&gt; 并且调用了abort()。&lt;/p&gt;

&lt;h4 id=&quot;trace-trap-exc_breakpoint--sigtrap&quot;&gt;Trace Trap [EXC_BREAKPOINT // SIGTRAP]&lt;/h4&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Abnormal Exit&lt;/code&gt;类似，这种异常是由于在特殊的节点加入debugger调试节点的原因。&lt;/p&gt;

&lt;h4 id=&quot;illegal-instruction-exc_bad_instruction--sigill&quot;&gt;Illegal Instruction [EXC_BAD_INSTRUCTION // SIGILL]&lt;/h4&gt;
&lt;p&gt;尝试执行一个非法或者未定义的指令时会触发该异常。&lt;/p&gt;

&lt;h4 id=&quot;quit-sigquit&quot;&gt;Quit [SIGQUIT]&lt;/h4&gt;
&lt;p&gt;这个异常是由于其他进程拥有高优先级且可以管理本进程所导致（被高优先级进程kill掉）。&lt;/p&gt;

&lt;h4 id=&quot;killedsigkill&quot;&gt;Killed[SIGKILL]&lt;/h4&gt;
&lt;p&gt;进程收到系统指令被干掉，可以自行查看Termination Reason来定位线程被干掉的原因。&lt;/p&gt;

&lt;h4 id=&quot;guarded-resource-violation-exc_guard&quot;&gt;Guarded Resource Violation [EXC_GUARD]&lt;/h4&gt;
&lt;p&gt;进程访问了一个被保护的资源。&lt;/p&gt;

&lt;h4 id=&quot;resource-limit-exc_resource&quot;&gt;Resource Limit [EXC_RESOURCE]&lt;/h4&gt;
&lt;p&gt;进程的资源超过限定阈值，表示进程占用太多资源，&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Subtype&lt;/code&gt;会提示原因，例如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEMORY&lt;/code&gt;:暗示了进程占用已经超过系统限制。如果之后出现由于系统占用过多进程被Kill，可能和这有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WAKEUP&lt;/code&gt;:暗示线程每秒被进程唤醒太多次了，进而导致CPU被频繁唤醒并且造成电量损耗。
通常，这种事发生在线程间通信（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;peformSelector:onThread:&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;），而且会远比预想的发生的更频繁。因为发生这种异常的通信被触发的如此频繁，所以很多后台线程会出现彼此高度雷同的堆栈信息——恰恰暗示了它们是从哪儿来的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;other-exception-types&quot;&gt;Other Exception Types&lt;/h4&gt;
&lt;p&gt;有些report可能出现无名的&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Type&lt;/code&gt;，取而代之出现的是16进制的地址(0x12387617823)，下面列举一些&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xbaaaaaad&lt;/code&gt;: 则说明此条logs是系统堆栈快照，并非crash report。可以通过同时按（手机）侧边按钮和音量键来记录堆栈快照。通常情况下，这些logs是用户无意中生成的，并非表示错误。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xbad22222&lt;/code&gt;: 表示一个VoIP应用因为频繁暂停被iOS系统终止掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x8badf00d&lt;/code&gt;:（读起来像badfood）则说明一个应用因为触发了看门狗机制被iOS系统终止掉，有可能是应用花了太长时间启动，终止，或者是响应系统事件。一种常见原因是在主线程上做网络同步逻辑。不论Thread0上（也就是主线程）想做什么（重要的事），都应该转移到后台线程，或者换一种方式触发，这样它才不会阻塞主线程。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xc00010ff&lt;/code&gt;: 则说明app因为环境过热（的事件）被iOS系统干掉了。这个也许是和发生crash的特定设备有关，或者是和它所在的环境有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xdead10cc&lt;/code&gt;: (读起来像deadlock)则说明一个应用被系统终止掉，原因是在应用挂起时拿到了文件锁或者sqlite数据库所长期不释放直到被冻结。如果你的app在挂起时拿到了文件锁或者sqlite数据库锁，它必须请求额外的后台执行时间(request additional background execution time )并在被挂起前完成解锁操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2bad45ec&lt;/code&gt;: 则说明app因为违规操作（安全违规）被iOS系统终止。终止描述会写：“进程被查到在安全模式进行非安全操作”，暗示app尝试在禁止屏幕绘制的时候绘制屏幕，例如当屏幕锁定时。用户可能会忽略这种异常，尤其当屏幕是关闭的或者当这种终止发生时正好锁屏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;低内存low-memory-reports&quot;&gt;低内存Low Memory Reports&lt;/h3&gt;
&lt;p&gt;当系统检测到内存不足时，虚拟内存系统会协同各应用来做内存释放，各个应用都会接受到内存警告，要求释放内存空间。如果内存依然不够，则你的应用会被终止，并生成report 存储在设备中，没有堆栈信息，可能的原因有一下几个：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[per-process-limit]&lt;/code&gt;:进程占用超过了它的最大内存值。每一个进程在常驻内存上的限制是早已经由系统为每个应用分配好了的。超过这个限制会导致进程被系统干掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[vm-pageshortage]/[vm-thrashing]/[vm]&lt;/code&gt;:由于系统内存压力被干掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[vnode-limit]&lt;/code&gt;: 打开太多文件了。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[highwater]&lt;/code&gt;:一个系统守护进程超过过了它的内存占用高水位（就是已经很危险了）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[jettisoned]&lt;/code&gt;:进程因为其它不可描述的原因被杀掉。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS-Crash-%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS-Crash-%E5%88%86%E6%9E%90/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>视频秒开优化方案</title>
        <description>&lt;h3 id=&quot;前置metadata&quot;&gt;前置metadata：&lt;/h3&gt;
&lt;p&gt;需要获取文件的metadata，解析出文件的编码，帧率等信息后才能开始边下边播，所以尽量让metadata或 MOOV box在靠近文件头部的位置，保证播放器尽快播放&lt;/p&gt;

&lt;h3 id=&quot;选择合适的缓冲策略&quot;&gt;选择合适的缓冲策略：&lt;/h3&gt;
&lt;p&gt;AVPlayer的 automaticallyWaitsToMinimizeStalling属性就是尽量多缓存一段时间，保证播放过程中减少卡顿&lt;/p&gt;

&lt;h3 id=&quot;使用httpdns加快建连&quot;&gt;使用HTTPDNS加快建连：&lt;/h3&gt;
&lt;p&gt;获取最优的CDN节点地址，并每隔一段时间获取一次最佳CDN节点，准实时的保证使用最佳节点。&lt;/p&gt;

&lt;h3 id=&quot;提升cdn命中率&quot;&gt;提升CDN命中率：&lt;/h3&gt;
&lt;p&gt;减少CDN的资源部命中，减少回源，比如URL中减少随机性的值，增加匹配命中概率。&lt;/p&gt;

&lt;h3 id=&quot;域名解析&quot;&gt;域名解析：&lt;/h3&gt;
&lt;p&gt;使用HTTPDNS快速获取最佳CDN节点信息。&lt;/p&gt;

&lt;h3 id=&quot;socket-cache&quot;&gt;Socket cache:&lt;/h3&gt;
&lt;p&gt;TCP的数据收发都是在缓冲区中完成拼装，通过调整缓冲区的大小。设置太小，影响效率，设置太大， 会短时间吃掉带宽(根据带宽探测原理可知),通过ffmpeg提供的api可修改。&lt;/p&gt;

&lt;h3 id=&quot;探测buffer&quot;&gt;探测buffer:&lt;/h3&gt;
&lt;p&gt;一开始需要先读一段数据，再对数据进行探测，得到封装格式、分辨率等信息。这个buffer可以设置。&lt;/p&gt;

&lt;h3 id=&quot;格式探测&quot;&gt;格式探测：&lt;/h3&gt;
&lt;p&gt;播放端开始时会探测数据格式，根据自己支持的格式探测出一个分数，得到相应的格式，如果短视频格式确定，就可以减少不必要的探测类型。&lt;/p&gt;

&lt;h3 id=&quot;播放-buffer&quot;&gt;播放 buffer:&lt;/h3&gt;
&lt;p&gt;减少播放的缓冲，一般缓冲buffer会按照帧数设置，但是短视频可以减小这个数字，达到尽快解码播放。&lt;/p&gt;

&lt;h3 id=&quot;分辨率视频格式&quot;&gt;分辨率、视频格式：&lt;/h3&gt;
&lt;p&gt;一定程度降低分辨率，减小文件大小。使用HEVC格式。&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E8%A7%86%E9%A2%91%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E8%A7%86%E9%A2%91%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>网络优化策略</title>
        <description>&lt;h3 id=&quot;网络优化策略&quot;&gt;网络优化策略&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;NSCache缓存，Last-Modified, ETag&lt;/li&gt;
  &lt;li&gt;DNS解析&lt;/li&gt;
  &lt;li&gt;数据压缩，protobuf, WebP&lt;/li&gt;
  &lt;li&gt;失败重发，缓存请求有网发送&lt;/li&gt;
  &lt;li&gt;弱网下设置不同超时时间&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nscache缓存&quot;&gt;NSCache缓存&lt;/h4&gt;
&lt;p&gt;Get类似SQL查找，所以默认会缓存，Post是提交数据，类似UPDATE，所以不会缓存。
Last-Modified：资源最后修改时间，来判断是否过期
请求response中会包含该字段和时间，下次请求时加上if-Modified-since : xxxx， 如果资源无变化返回304 Not Changed。&lt;/p&gt;

&lt;p&gt;ETag:资源文件的hash值，与当前资源文件比对是否一致，不一致则返回新值，一致则不返回。&lt;/p&gt;

&lt;h4 id=&quot;dns解析&quot;&gt;DNS解析&lt;/h4&gt;
&lt;p&gt;使用HTTPDNS 解析域名，代替从localDNS获取IP。 当HTTPDNS解析失败时再走localDNS.
或者本地维护IP list，与HTTPDNS的结果做更新&lt;/p&gt;

&lt;h4 id=&quot;数据压缩&quot;&gt;数据压缩&lt;/h4&gt;
&lt;p&gt;webP图片格式比PNG和jpg 体积小，但是webP图片需要解析才能成为可用的jpg图片， app内解析肯定要花费一定的性能。
在wifi条件下，较大的图片直接使用png/jpg, 减少解析时间。  4G条件下，建议用webP,对流量比较友好&lt;/p&gt;

&lt;h4 id=&quot;失败重发&quot;&gt;失败重发&lt;/h4&gt;
&lt;p&gt;超时或失败的请求建立重发机制，待网络通畅后再次发送&lt;/p&gt;

&lt;h4 id=&quot;弱网下设置不同超时时间&quot;&gt;弱网下设置不同超时时间&lt;/h4&gt;
&lt;p&gt;不同网络状态下超时时间设置不同，例如4G只需要10秒，3G需要20秒，在超时后依然无法与服务端建立连接，可排查网络链路通畅性，例如使用HTTPDNS切换新的服务器站点，尝试连接。&lt;/p&gt;

&lt;h3 id=&quot;http2相比http1x的升级&quot;&gt;HTTP2相比HTTP1.x的升级：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP/2采用二进制格式传输数据 ，而不是1.x的文本格式。&lt;/li&gt;
  &lt;li&gt;对消息头进行压缩传输，节省消息头占用的流量。 1.x每次请求携带大量冗余头信息，浪费资源&lt;/li&gt;
  &lt;li&gt;多路复用，一个域名下的请求可以通过一个TCP连接并发完成，毕竟新开一个TCP连接都需要慢慢提升传输速度。 1.x虽然通过pipeline也能并发请求，但是多个请求之间响应会被阻塞。采用二进制分帧，数据流可以乱序发送，接收后可以重新组装。&lt;/li&gt;
  &lt;li&gt;server push， 服务端提前把资源推送给客户端&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>各iOS版本适配概要</title>
        <description>&lt;h3 id=&quot;ios9&quot;&gt;iOS9：&lt;/h3&gt;
&lt;p&gt;App Thinning: 包括slicing, bitcode都是在不同设备上打包不同的app版本，&lt;/p&gt;

&lt;h3 id=&quot;ios10&quot;&gt;iOS10:&lt;/h3&gt;
&lt;p&gt;UIRefreshControl: 原来只是TableViewController的属性，现在增加成 UIScrollView的属性。可以脱离controller使用
跳转到设置的方式：可以用 UIApplicationOpenSettingsURLString
UITableView和UICollectionView的 Pre-Feching 预加载和生命周期的优化，例如prepareForReuse方法比之前版本要提前，且是一个一个的加载，而不是之前的一行一行的加载，且会把滑出屏幕的cell保存一段时间，防止又滑回来导致重新走一遍cell的生命周期。
scroolview卡顿优化方式处理离屏渲染等方式，还可以使用pre fetch方式，子线程预加载数据来实现一定的性能提升&lt;/p&gt;

&lt;h3 id=&quot;ios11&quot;&gt;iOS11:&lt;/h3&gt;
&lt;p&gt;UIScrollView: 废弃了UIViewController的 automaticllyAdjustsScrollViewInsets属性，新增contentInsetAdjustmentBehavior,当超出安全区域时系统自动跳转safeAreaInsets。 进而影响adjustContentInset。&lt;/p&gt;

&lt;h3 id=&quot;ios12&quot;&gt;iOS12：&lt;/h3&gt;
&lt;p&gt;libc++替代 libstdc++&lt;/p&gt;

&lt;h3 id=&quot;ios13&quot;&gt;iOS13:&lt;/h3&gt;
&lt;p&gt;通过KVC调用一些私有API的导致crash, 例如testField的 _placeholderLabel,    UISearchbar的 _searchField，13新增searchTextField属性
DeviceToken格式变化了
必须支持 Sign with apple 
modalPresentationStyle 默认值13开始变为automatic, 之前都是fullscreen
DarkMode 
Xcode11新工程要支持Scene多屏， 低版本黑屏
UIWebView废弃
蓝牙权限需要申请&lt;/p&gt;

&lt;h3 id=&quot;ios14&quot;&gt;iOS14：&lt;/h3&gt;
&lt;p&gt;####隐私权限更新：
*1. 照片： 增加选择部分照片权限limited，建议使用PHPicker
*2. 通讯录: 不需要权限，可以给textfile设置contenttype，设为通讯录，这样键盘会自动提示，app无需处理
*3. 定位： 增加精确定位和模糊定位的开关
Mac 地址对随着连接不同wifi而变化，且24小时也会更新一次。之前mac地址不会变，目的是防止运营商对用户数据收集和追踪
IDFA 默认关闭用户追踪开关&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E5%90%84iOS%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D%E6%A6%82%E8%A6%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E5%90%84iOS%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D%E6%A6%82%E8%A6%81/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS 组件化方案选型</title>
        <description>&lt;h2 id=&quot;一组件化概念&quot;&gt;一、组件化概念&lt;/h2&gt;
&lt;h3 id=&quot;11项目状态&quot;&gt;1.1、项目状态&lt;/h3&gt;
&lt;p&gt;各模块直接调用，耦合严重。业务模块间划分不清晰，相互引用，模块之间耦合度很大，非常难维护。
所有模块代码都编写在一个项目中，测试某个模块或功能，需要编译运行整个项目，不能独立运行。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024733598436.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12解决方案&quot;&gt;1.2、解决方案&lt;/h3&gt;
&lt;p&gt;所有的模块间的调用都会经过中间层中转(参考Router)，但是发现增加这个中间层后，耦合还是存在的。
中间层对被调用模块存在耦合，其他模块也需要耦合中间层才能发起调用。这样还是存在之前的相互耦合的问题，虽然可解决了统一调用的问题，而且本质上比之前更麻烦了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734216154.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;13正确的组件化解耦&quot;&gt;1.3、正确的组件化解耦&lt;/h3&gt;
&lt;p&gt;正确的解耦应该是，只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合。
对于这个问题，可以采用组件化的架构，将每个模块作为一个组件。并且建立一个主项目，这个主项目负责集成所有组件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734534438.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二组件化主流方案&quot;&gt;二、组件化主流方案&lt;/h2&gt;
&lt;h3 id=&quot;21url-block-代表蘑菇街组件化方案mgjrouter&quot;&gt;2.1、url-block (代表：蘑菇街组件化方案MGJRouter)&lt;/h3&gt;
&lt;p&gt;蘑菇街通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MGJRouter&lt;/code&gt;实现中间层，通过MGJRouter进行组件间的消息转发，从名字上来说更像是路由器。实现方式大致是，在提供服务的组件中提前注册block，然后在调用方组件中通过URL调用block，下面是调用方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;架构设计
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734970626.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MGJRouter组件化架构
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024735173869.png&quot; style=&quot;zoom=20%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MGJRouter是一个单例对象，在其内部维护着一个“URL -&amp;gt; block”格式的注册表，通过这个注册表来保存服务方注册的block，以及使调用方可以通过URL映射出block，并通过MGJRouter对服务方发起调用。&lt;/li&gt;
  &lt;li&gt;在程序开始运行时，需要将所有服务方的接口类实例化，以完成这个注册工作，使MGJRouter中所有服务方的block可以正常提供服务。在这个服务注册完成后，就可以被调用方调起并提供服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 、MGJRouter调用，代码模拟对详情页的注册、调用，在调用过程中传递id参数。下面是注册的示例代码。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter registerURLPattern:@&quot;mgj://detail?id=id&quot; toHandler:^(NSDictionary *routerParameters) {
// 下面可以在拿到参数后，为其他组件提供对应的服务
NSString uid = routerParameters[@&quot;id&quot;];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.1.2、通过openURL:方法传入的URL参数，对详情页已经注册的block方法发起调用。调用方式类似于GET请求，URL地址后面拼接参数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter openURL:@&quot;mgj://detail?id=404&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.1.3、也可以通过字典方式传参，MGJRouter提供了带有字典参数的方法，这样就可以传递非字符串之外的其他类型参数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter openURL:@&quot;mgj://detail?&quot; withParam:@{@&quot;id&quot; : @&quot;404&quot;}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;短链管理这时候会发现一个问题，在蘑菇街组件化架构中，存在了很多硬编码的URL和参数。&lt;/li&gt;
  &lt;li&gt;在代码实现过程中URL编写出错会导致调用失败，而且参数是一个字典类型，调用方不知道服务方需要哪些参数，这些都是个问题。&lt;/li&gt;
  &lt;li&gt;对于这些数据的管理，蘑菇街开发了一个web页面，这个web页面统一来管理所有的URL和参数，Android和iOS都使用这一套URL，可以保持统一性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22protocol方案代表阿里的beehive&quot;&gt;2.2、Protocol方案(代表：阿里的BeeHive)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;面向接口调用，我们知道只要直接引用代码，就会有依赖，比如：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// A 模块
- (void)getSomeDataFromB {
B.getSomeData();
}
// B 模块
- (void)getSomeData {
return self.data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;那么我们可以实现一个 getSomeDataFromB 的接口，让 A 只依赖这个接口，而 B 来实现这个接口，这样就实现了 A 与 B 的解耦。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 接口
@protocol BService &amp;lt;NSObject&amp;gt;
- (void)getSomeData;
@end
// A 模块, 只依赖接口
- (void)getSomeDataFromB {
id b = findService(@protocol(BService));
b.getSomeData;
}
// B 模块，实现BService接口
@interface B : NSObject &amp;lt;BService&amp;gt;
- (void)getSomeData {
return self.data;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就可以实现了即满足了模块之间调用，也实现了解耦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口类似代码，可以非常灵活的定义函数和回调等。&lt;/li&gt;
  &lt;li&gt;解决了硬编码的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。&lt;/li&gt;
  &lt;li&gt;使用较为麻烦，每个调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;BeeHive框架&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Module负责管理模块的注册和释放&lt;/li&gt;
  &lt;li&gt;Protocol负责公开组件开放的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024736500731.jpg&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优势：扩展组件的生命周期，大厂开源 注意：BeeHive采用GPL开源协议，若有修改，不允许私有化，必须开源分享。&lt;/p&gt;

&lt;h3 id=&quot;23target-action方案casatwy组件化方案&quot;&gt;2.3、Target-Action方案(casatwy组件化方案)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.3.1、调用方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整体架构casatwy组件化方案分为两种调用方式，远程调用和本地调用，对于两个不同的调用方式分别对应两个接口。&lt;/li&gt;
  &lt;li&gt;远程调用通过AppDelegate代理方法传递到当前应用后，调用远程接口并在内部做一些处理，处理完成后会在远程接口内部调用本地接口，以实现本地调用为远程调用服务。&lt;/li&gt;
  &lt;li&gt;本地调用由performTarget:action:params:方法负责，但调用方一般不直接调用performTarget:方法。CTMediator会对外提供明确参数和方法名的方法，在方法内部调用performTarget:方法和参数的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.3.2、架构设计思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;casatwy是通过CTMediator类实现组件化的，在此类中对外提供明确参数类型的接口，接口内部通过performTarget方法调用服务方组件的Target、Action。&lt;/li&gt;
  &lt;li&gt;由于CTMediator类的调用是通过runtime主动发现服务的，所以服务方对此类是完全解耦的。&lt;/li&gt;
  &lt;li&gt;但如果CTMediator类对外提供的方法都放在此类中，将会对CTMediator造成极大的负担和代码量。&lt;/li&gt;
  &lt;li&gt;解决方法就是对每个服务方组件创建一个CTMediator的Category，并将对服务方的performTarget调用放在对应的Category中，这些Category都属于CTMediator中间件，从而实现了感官上的接口分离。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.3.3、casatwy组件化实现细节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于服务方的组件来说，每个组件都提供一个或多个Target类，在Target类中声明Action方法。&lt;/li&gt;
  &lt;li&gt;Target类是当前组件对外提供的一个“服务类”，Target将当前组件中所有的服务都定义在里面，CTMediator通过runtime主动发现服务。&lt;/li&gt;
  &lt;li&gt;在Target中的所有Action方法，都只有一个字典参数，所以可以传递的参数很灵活，这也是casatwy提出的去Model化的概念。&lt;/li&gt;
  &lt;li&gt;在Action的方法实现中，对传进来的字典参数进行解析，再调用组件内部的类和方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三组件化方案对比&quot;&gt;三、组件化方案对比&lt;/h2&gt;
&lt;h3 id=&quot;31url-block方式&quot;&gt;3.1、url-block方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;硬编码问题，每个组件参数调用都需要查找对应。蘑菇街为此开发了一个web页面，这个web页面统一来管理所有的URL和参数。&lt;/li&gt;
  &lt;li&gt;需要在内存中维护url-block的表，组件多了可能会有内存问题。&lt;/li&gt;
  &lt;li&gt;url的参数传递受到限制，只能传递常规的字符串参数，无法传递非常规参数，如UIImage、NSData等类型。&lt;/li&gt;
  &lt;li&gt;没有区分本地调用和远程调用的情况，尤其是远程调用，会因为url参数受限，导致一些功能受限。&lt;/li&gt;
  &lt;li&gt;组件本身依赖了中间件，且分散注册使的耦合较多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32protocol方案&quot;&gt;3.2、Protocol方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;0硬编码，代码可读性高;&lt;/li&gt;
  &lt;li&gt;Protocol方案需要在启动的时候向ProtocolManager注册，侵入较大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33target_action方案&quot;&gt;3.3、Target_Action方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;侵入最小，但硬编码较多。&lt;/li&gt;
  &lt;li&gt;runtime编译阶段不检查,运行时才检查对应类或者方法是否存在，对开发要求较高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四组件化实现原则&quot;&gt;四、组件化实现原则&lt;/h2&gt;
&lt;h3 id=&quot;41抽象化原则&quot;&gt;4.1、抽象化原则&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;越底层的模块，应该越稳定，越抽象，越具有高复用度。&lt;/li&gt;
  &lt;li&gt;稳定的最直观表现就是API很久都不用变化，所有的变化因子不要暴露出来，避免传递给依赖它的模块。&lt;/li&gt;
  &lt;li&gt;但是要做到设计一套API很久都不用改变，那么就需要设计的时候能越抽象, 即需要我们抽象总结的能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42稳定性原则&quot;&gt;4.2、稳定性原则&lt;/h3&gt;
&lt;p&gt;不要让稳定的模块依赖不稳定的模块， 减少依赖，稳定性 还有一个特点就是会传递，比如 B 模块依赖了 A 模块，如果 B 模块很稳定，但是 A 模块不稳定，那么B模块也会变的不稳定了。&lt;/p&gt;

&lt;h3 id=&quot;43自备性完整&quot;&gt;4.3、自备性完整&lt;/h3&gt;
&lt;p&gt;提升模块的复用度，自完备性有时候要优于代码复用；什么是自完备性，就是尽可能的依赖少的模块来达到代码可复用；我有个模块 Utils 里面放了大量的category工具方法等，在日常UI产品开发中，依赖这个Utils会很方便，但是我现在要写一个比较基础的模块，应该就要求复用度更高一些，这个时候需要用到Utils里面的几个方法，那这个时候还适合直接依赖Utils吗，当然不合适了，这与我们上面的设计原则相悖了啊，因此我们这时候为了这个模块的自完备性，就可以重新实现下这几个方法，而不是依赖Utils模块。&lt;/p&gt;

&lt;h3 id=&quot;44不要让common出现&quot;&gt;4.4、不要让Common出现&lt;/h3&gt;
&lt;p&gt;每个模块只做好一件事情，不要让Common出现，按照你架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合。&lt;/p&gt;

&lt;h3 id=&quot;45业务模块真正解耦&quot;&gt;4.5、业务模块真正解耦&lt;/h3&gt;
&lt;p&gt;为什么要解耦吧，模块化并不是说你把工程的代码拆分成 50 个 pod 或者framework就算完事了，要实现模块之间真正的解耦才算真正的模块化，否则如果模块之间还都是互相调用代码，循环依赖，那么和原本放文件夹里面没啥两样。那么什么是模块间的解耦呢？模块解耦的目标就是, 在基于模块设计原则上, 让模块之间没有循环依赖, 让业务模块之间解除依赖。&lt;/p&gt;

&lt;h3 id=&quot;46单向依赖&quot;&gt;4.6、单向依赖&lt;/h3&gt;
&lt;p&gt;基础模块下沉，这块其实还是讲的模块设计，一个工程的架构可能会分为很多层，然而在开发的过程中，很容易有人不注意让应该处于较底层的模块依赖了上层的模块，这种情况下应该对模块的设计进行改造实现单向依赖。&lt;/p&gt;

&lt;h2 id=&quot;五组件化具体实施步骤&quot;&gt;五、组件化具体实施步骤&lt;/h2&gt;
&lt;h3 id=&quot;51组件化第一步剥离产品公共库和基础库&quot;&gt;5.1、组件化第一步，剥离产品公共库和基础库&lt;/h3&gt;
&lt;p&gt;包括组件中间件，网络请求，第三方SDK管理封装，WebView(封装js，且以服务形式提供)，自定义键盘，UI基础组件，分类。然后在项目里用pod进行管理。其中，针对三方库，最好再封装一层，使我们的项目不直接依赖三方库，方便后续开发过程中的更换。&lt;/p&gt;

&lt;h3 id=&quot;52组件化第二步独立业务模块单独成库&quot;&gt;5.2、组件化第二步，独立业务模块单独成库&lt;/h3&gt;
&lt;p&gt;拆分粒度可以先粗后细，将相对独立的组件拆分出来。在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。&lt;/p&gt;

&lt;h3 id=&quot;53组件化第三步对外服务最小化&quot;&gt;5.3、组件化第三步，对外服务最小化&lt;/h3&gt;
&lt;p&gt;在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(8)- 性能优化</title>
        <description>&lt;h3 id=&quot;减少卡顿&quot;&gt;减少卡顿&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;尽量减少视图数量和层次&lt;/li&gt;
  &lt;li&gt;减少透明的视图&lt;/li&gt;
  &lt;li&gt;尽量避免出现离屏渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;离屏渲染&quot;&gt;离屏渲染&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。
如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;GPU离屏渲染：采用画家算法，把每一层依次输出到画布，如果父layer剪裁成圆角，容器子layer因为父容器有圆角，也要被剪裁，但这时还在渲染队列中，此时需要在新内存中，把容器以及子layer依次画好，剪裁完成，再放到&lt;code class=&quot;highlighter-rouge&quot;&gt;frame buffer&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&quot;消耗性能原因&quot;&gt;消耗性能原因&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要创建新的缓冲区&lt;/li&gt;
  &lt;li&gt;整个过程需要多次切换上下文环境，从&lt;code class=&quot;highlighter-rouge&quot;&gt;on-screen&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;off-screen&lt;/code&gt;，等渲染结束后，将离屏缓冲区结果显示到屏幕上，再讲上下文从&lt;code class=&quot;highlighter-rouge&quot;&gt;off-screen&lt;/code&gt;切换到&lt;code class=&quot;highlighter-rouge&quot;&gt;on-screen&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;哪些会触发离屏渲染&quot;&gt;哪些会触发离屏渲染&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;光栅化   &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shouldRasterize= YES&lt;/code&gt;。 隐式的创建一个位图，各种阴影遮罩效果保存在位图中缓存，如果对应的layer极其sublayers没有发生改变，在下一帧的时候可以直接复用，减少渲染频率。但是否有助于优化性能取决于缓存的位图是否被有效复用。&lt;/li&gt;
  &lt;li&gt;遮罩   &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.mask&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圆角   同时设置&lt;code class=&quot;highlighter-rouge&quot;&gt;layer.maskToBounds = YES&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.cornerRadius &amp;gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;阴影 &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shadowoffset...&lt;/code&gt;,    但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shadowPath&lt;/code&gt;不会产生离屏渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;卡顿检测&quot;&gt;卡顿检测&lt;/h3&gt;
&lt;p&gt;通过使用监听 runloop的状态切换的耗时达到监控卡顿的目的&lt;/p&gt;

&lt;h3 id=&quot;app启动优化&quot;&gt;APP启动优化&lt;/h3&gt;
&lt;p&gt;启动分为3大阶段&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyld(dynamic link editor)&lt;/code&gt; 动态链接，装在Mach-O文件
    &lt;ul&gt;
      &lt;li&gt;装在APP可执行文件，递归加载所有依赖的动态库&lt;/li&gt;
      &lt;li&gt;都完毕后，通知runtime进行下一步处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;map_images&lt;/code&gt; 进行执行文件内容的解析和处理&lt;/li&gt;
      &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;load_images&lt;/code&gt;中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;call_load_methods&lt;/code&gt;， 调用所有class和&lt;code class=&quot;highlighter-rouge&quot;&gt;category&lt;/code&gt;的 &lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;方法&lt;/li&gt;
      &lt;li&gt;进行objc结构初始化，注册类，初始化对象等&lt;/li&gt;
      &lt;li&gt;可执行文件和动态库中所有符号Class,Protocol, Selctor, IMP 都已经加载完成&lt;/li&gt;
      &lt;li&gt;调用Main函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationMain&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;didFinishLaunchingWithOptions&lt;/code&gt;方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化方案：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyld&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;减少动态库，合并动态库&lt;/li&gt;
      &lt;li&gt;减少Objc类，分类的数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;+initialize&lt;/code&gt;方法和dispath_once代替+load方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;按需加载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细优化方案见&lt;a href=&quot;https://byronjia.github.io/2020/09/iOS-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/&quot;&gt;iOS 应用启动耗时分析及优化&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(8)-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(8)-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(7)- 内存管理</title>
        <description>&lt;h2 id=&quot;浅拷贝和深拷贝&quot;&gt;浅拷贝和深拷贝&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;拷贝的最终目的是产生一个副本，修改副本不会对原对象产生影响。故到底是深拷贝还是浅拷贝要根据这个规则来判断。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;[任意对象 copy] 产生一个不可变对象，如果原对象是不可变对象，那么就是浅拷贝，因为不可变对象本身就不能修改，所以没必要创新分配内存。原对象是可变对象，就是深拷贝。&lt;/li&gt;
  &lt;li&gt;[任意对象 mutableCopy] 产生一个可变对象，不论原对象是否是可变对象，都是深拷贝，因为要产生修改不影响原对象的副本，必须重新分配内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208497217.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;定义属性时使用copy修饰词，目的是在赋值之后产生一个不可变对象，那么在修改外部变量的时候不影响内部，例如UI控件的text都是copy修饰，防止外部修改影响内部实现。&lt;/p&gt;

&lt;h2 id=&quot;cadisplaylink-和-nstimer使用问题&quot;&gt;CADisplayLink 和 NSTimer使用问题&lt;/h2&gt;
&lt;p&gt;会对target 强引用，如果target也强引用他们，就发生循环引用问题
解决方法是使用NSProxy，是和NSObject同一级别的基类，但是没有实现和声明多余的方法，只有alloc等。
作用是只要方法列表里找不到方法，跳过动态方法解析，直接做转发。且NXProxy中弱引用target即可。&lt;/p&gt;

&lt;h2 id=&quot;内存布局&quot;&gt;内存布局&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208614585.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tagged-pointer&quot;&gt;Tagged Pointer&lt;/h2&gt;
&lt;p&gt;从64位开始引入，目的是优化NSNumber, NSDate， NSString等小对象的存储，提高内存使用率&lt;br /&gt;
原来NSNumber占用一个对象的空间，指针还指向堆地址的值，最终可能只是为了存一个3。 就浪费很大空间&lt;/p&gt;

&lt;p&gt;在使用Tagged pointer技术后，NSNumber 3的地址0x327, Tag+Data 的形式存储，从地址就能读到真实值，不需要额外空间。当内存地址长度超过64位后，才使用动态分配内存的方式存储数据。&lt;/p&gt;

&lt;p&gt;如果地址最低有效位是1， 则是Tagged pointer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ： 字符串想要使用tagged pointer, 初始化要用&lt;code class=&quot;highlighter-rouge&quot;&gt;[NSString stringWithFormat:]&lt;/code&gt;，如果是@”xx”创建的是常规对象存在常量区。&lt;/p&gt;
&lt;h2 id=&quot;引用计数管理&quot;&gt;引用计数管理&lt;/h2&gt;
&lt;p&gt;新建OC对象引用计数默认是1，当调用alloc,new,copy,mutableCopy时对象引用计数会+1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引用计数存储&lt;/strong&gt;：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208775066.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在64位优化后的isa共用体结构中，引用计数=extra_rc + sidetable_rc.refcnts[self].count,不是每个对象都会使用sidetable_rc,要看isa的标志位has_sidetable_rc.  &lt;br /&gt;
如果isa不是共用体结构，引用计数=sidetable_rc.refcnts[self].count
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208883784.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;refcnts是一个散列表，使用对象的地址为key,value为引用计数。
获取引用计数、retain、release操作都是获取extra_rc的值+sidetable的值+1或-1. 如果是release则判断是否为0，为0就dealloc。&lt;/p&gt;

&lt;h2 id=&quot;weak-指针原理&quot;&gt;weak 指针原理&lt;/h2&gt;
&lt;p&gt;__weak: 弱引用对象，当对象销毁时指针置为空&lt;br /&gt;
__unsafe_unretain: 弱引用对象，当对象销毁时，指针不变，使用会发生坏内存访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;weak能在对象销毁置为空的原理：&lt;/strong&gt;
当自动调用dealloc方法时，判断是否有弱引用和&lt;code class=&quot;highlighter-rouge&quot;&gt;sidetable_rc&lt;/code&gt;,（弱引用和超过计数器时都使用到了sidetable），有弱引用就将sidetable中自己对应的value取出来，得到一个__weak对象的地址集合(不确定是不是数组，因为用到C++的遍历器)， 并遍历将其置为nil
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209058628.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h2&gt;
&lt;p&gt;主要通过AutoreleasePoolPage来管理，结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209189251.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在@autoreleasePool代码开始时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoreleasePoolPage&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;方法，将&lt;code class=&quot;highlighter-rouge&quot;&gt;BOUNDARY&lt;/code&gt; 添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，标记为开始，后续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;的对象也会添加到该&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，在括号结束时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;方法时传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;的内存地址，会从最后一个入栈的对象开始发送&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;消息，直到遇到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象释放时机&quot;&gt;对象释放时机&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MRC&lt;/strong&gt;: 对象创建时调用了autorelease方法   &lt;br /&gt;
系统在主线程的Runloop中注册了2个Observer,1个监听kCFRunLoopEntry时间，调用objc_autoreleasePoolPush()。另一个监听kCFRunLoopBeforeWaiting事件，调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()。
监听kCFRunLoopBeforeExit事件调用objc_autoreleasePoolPop() &lt;br /&gt;
例如：viewdidload和viewwillappear 在一个loop中，即一次执行所有的block和sources，直到执行完毕loop睡眠，在睡眠之前会释放对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARC&lt;/strong&gt;:
在括号结束时，LLVM编译器自动给对象release一次，而不是在runloop中执行。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
