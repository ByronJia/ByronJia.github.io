<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 10 Oct 2020 18:13:06 +0800</pubDate>
    <lastBuildDate>Sat, 10 Oct 2020 18:13:06 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>iOS底层(7)- 内存管理</title>
        <description>&lt;h2 id=&quot;浅拷贝和深拷贝&quot;&gt;浅拷贝和深拷贝&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;拷贝的最终目的是产生一个副本，修改副本不会对原对象产生影响。故到底是深拷贝还是浅拷贝要根据这个规则来判断。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;[任意对象 copy] 产生一个不可变对象，如果原对象是不可变对象，那么就是浅拷贝，因为不可变对象本身就不能修改，所以没必要创新分配内存。原对象是可变对象，就是深拷贝。&lt;/li&gt;
  &lt;li&gt;[任意对象 mutableCopy] 产生一个可变对象，不论原对象是否是可变对象，都是深拷贝，因为要产生修改不影响原对象的副本，必须重新分配内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208497217.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;定义属性时使用copy修饰词，目的是在赋值之后产生一个不可变对象，那么在修改外部变量的时候不影响内部，例如UI控件的text都是copy修饰，防止外部修改影响内部实现。&lt;/p&gt;

&lt;h2 id=&quot;cadisplaylink-和-nstimer使用问题&quot;&gt;CADisplayLink 和 NSTimer使用问题&lt;/h2&gt;
&lt;p&gt;会对target 强引用，如果target也强引用他们，就发生循环引用问题
解决方法是使用NSProxy，是和NSObject同一级别的基类，但是没有实现和声明多余的方法，只有alloc等。
作用是只要方法列表里找不到方法，跳过动态方法解析，直接做转发。且NXProxy中弱引用target即可。&lt;/p&gt;

&lt;h2 id=&quot;内存布局&quot;&gt;内存布局&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208614585.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tagged-pointer&quot;&gt;Tagged Pointer&lt;/h2&gt;
&lt;p&gt;从64位开始引入，目的是优化NSNumber, NSDate， NSString等小对象的存储，提高内存使用率&lt;br /&gt;
原来NSNumber占用一个对象的空间，指针还指向堆地址的值，最终可能只是为了存一个3。 就浪费很大空间&lt;/p&gt;

&lt;p&gt;在使用Tagged pointer技术后，NSNumber 3的地址0x327, Tag+Data 的形式存储，从地址就能读到真实值，不需要额外空间。当内存地址长度超过64位后，才使用动态分配内存的方式存储数据。&lt;/p&gt;

&lt;p&gt;如果地址最低有效位是1， 则是Tagged pointer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ： 字符串想要使用tagged pointer, 初始化要用&lt;code class=&quot;highlighter-rouge&quot;&gt;[NSString stringWithFormat:]&lt;/code&gt;，如果是@”xx”创建的是常规对象存在常量区。&lt;/p&gt;
&lt;h2 id=&quot;引用计数管理&quot;&gt;引用计数管理&lt;/h2&gt;
&lt;p&gt;新建OC对象引用计数默认是1，当调用alloc,new,copy,mutableCopy时对象引用计数会+1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引用计数存储&lt;/strong&gt;：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208775066.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在64位优化后的isa共用体结构中，引用计数=extra_rc + sidetable_rc.refcnts[self].count,不是每个对象都会使用sidetable_rc,要看isa的标志位has_sidetable_rc.  &lt;br /&gt;
如果isa不是共用体结构，引用计数=sidetable_rc.refcnts[self].count
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208883784.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;refcnts是一个散列表，使用对象的地址为key,value为引用计数。
获取引用计数、retain、release操作都是获取extra_rc的值+sidetable的值+1或-1. 如果是release则判断是否为0，为0就dealloc。&lt;/p&gt;

&lt;h2 id=&quot;weak-指针原理&quot;&gt;weak 指针原理&lt;/h2&gt;
&lt;p&gt;__weak: 弱引用对象，当对象销毁时指针置为空&lt;br /&gt;
__unsafe_unretain: 弱引用对象，当对象销毁时，指针不变，使用会发生坏内存访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;weak能在对象销毁置为空的原理：&lt;/strong&gt;
当自动调用dealloc方法时，判断是否有弱引用和&lt;code class=&quot;highlighter-rouge&quot;&gt;sidetable_rc&lt;/code&gt;,（弱引用和超过计数器时都使用到了sidetable），有弱引用就将sidetable中自己对应的value取出来，得到一个__weak对象的地址集合(不确定是不是数组，因为用到C++的遍历器)， 并遍历将其置为nil
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209058628.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h2&gt;
&lt;p&gt;主要通过AutoreleasePoolPage来管理，结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209189251.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在@autoreleasePool代码开始时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoreleasePoolPage&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;方法，将&lt;code class=&quot;highlighter-rouge&quot;&gt;BOUNDARY&lt;/code&gt; 添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，标记为开始，后续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;的对象也会添加到该&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，在括号结束时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;方法时传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;的内存地址，会从最后一个入栈的对象开始发送&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;消息，直到遇到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象释放时机&quot;&gt;对象释放时机&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MRC&lt;/strong&gt;: 对象创建时调用了autorelease方法   &lt;br /&gt;
系统在主线程的Runloop中注册了2个Observer,1个监听kCFRunLoopEntry时间，调用objc_autoreleasePoolPush()。另一个监听kCFRunLoopBeforeWaiting事件，调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()。
监听kCFRunLoopBeforeExit事件调用objc_autoreleasePoolPop() &lt;br /&gt;
例如：viewdidload和viewwillappear 在一个loop中，即一次执行所有的block和sources，直到执行完毕loop睡眠，在睡眠之前会释放对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARC&lt;/strong&gt;:
在括号结束时，LLVM编译器自动给对象release一次，而不是在runloop中执行。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(6)- runLoop &amp; 多线程</title>
        <description>&lt;h2 id=&quot;runloop&quot;&gt;runloop&lt;/h2&gt;
&lt;h3 id=&quot;常见类型&quot;&gt;常见类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;runloop&lt;/strong&gt; 和线程一一对应，子线程默认不开启runloop,当第一次获取runloop时就会创建runloop。存在全局map中，key是线程，value是runloop&lt;/p&gt;

&lt;p&gt;runloopModel结构体如下
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023184791593.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见2种Mode:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kCFRunLoopDefaultMode&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDefaultRunLoopMode&lt;/code&gt;）：App的默认Mode，通常主线程是在这个Mode下运行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UITrackingRunLoopMode&lt;/code&gt;：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目的是不同组的&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;能分隔开来，互不影响，处理不同的事件，只能同一时间运行一种模式&lt;/p&gt;

&lt;h3 id=&quot;线程保活&quot;&gt;线程保活&lt;/h3&gt;

&lt;p&gt;一般线程启动后，如果事情做完会直接销毁，因为启动runloop 如果Mode里没有任何&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;，RunLoop会立马退出。 唯一办法是在runloop中添加前面所说的几个事件。
做法：
在当前线程中调用以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init]   forMode:NSDefaultRunLoopMode];
while (1){
    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样添加一个port的 &lt;code class=&quot;highlighter-rouge&quot;&gt;source1&lt;/code&gt; 事件，并启动本次runMode, 一旦响应一次事件后本次会结束，所以需要while 运行runModel 。其实就是阻塞了当前runloop的一个事件，导致后续事件无法运行，以此保证runloop和线程的存活&lt;/p&gt;

&lt;h2 id=&quot;多线程&quot;&gt;多线程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185008204.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;线程死锁&quot;&gt;线程死锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁)&lt;/strong&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector:withObject:afterDelay: &lt;/code&gt;方法是用你NSTimer实现定时，且是加在当前线程runloop中，但是如果当前是&lt;code class=&quot;highlighter-rouge&quot;&gt;asyn&lt;/code&gt;产生的线程runloop没启动的话这种方法无效。需要手动启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;线程锁&quot;&gt;线程锁&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt; 自旋锁，一直处于忙等状态&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;os_unfair_lock&lt;/code&gt; 互斥锁，等待锁的线程处于休眠状态，节省资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185133777.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt; 互斥锁，等待锁的线程处于休眠状态
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185345005.jpg&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;的条件锁
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185451423.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;  对于pthread_mutex的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSRecursiveLock&lt;/code&gt;  对于pthread_mutex的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;  对于pthread_mutex 和 condition的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue(DISPATCH_QUEUE_SERIAL)&lt;/code&gt; 把不同线程的任务放在同步队列中执行，能达到锁的效果&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt; 信号量， 初始化赋一个最多同时执行线程数量，如果是1就实现了锁的效果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁都是由于不同线程的问题导致的，如果条件锁在一个线程有wait，没有其他线程signal,就会永远睡眠下去。wait后的代码不会执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队列和线程是2个概念，队列中的任务可以在不同的线程中去执行。例如用globalQueue来创建不同的线程任务，所以可以使用串行队列来实现线程锁的问题，只要保证任务都加入到队列中执行即可&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;atomic 用于保证setter、 getter的操作原子性，在方法内部加上线程同步锁&lt;/p&gt;

&lt;h3 id=&quot;读写安全方案-保证同一时间只有一个线程写可以多个线程读不能同时读写&quot;&gt;读写安全方案 ,保证同一时间只有一个线程写，可以多个线程读，不能同时读写&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_rwlock&lt;/code&gt; 读写锁&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt; 异步栅栏调用
  &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_asyn(que)&lt;/code&gt; 用于读操作
  &lt;code class=&quot;highlighter-rouge&quot;&gt;diapatch_barrier_async(que)&lt;/code&gt; 用于写操作，可以保证当前队列中只有栅栏中的任务在执行，其他全部暂停。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(6)runLoop-&-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(6)runLoop-&-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(5)-Block</title>
        <description>&lt;h2 id=&quot;block本质&quot;&gt;Block本质&lt;/h2&gt;
&lt;p&gt;本质是一个OC对象，编译之后是一个结构体包含isa指针，block中封装了调用的函数和调用环境。调用环境值&lt;code class=&quot;highlighter-rouge&quot;&gt;variables&lt;/code&gt;是block捕获的变量(如果block中访问了一些需要被捕获的变量，例如局部变量)
block的变量捕获机制：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;局部变量， &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;临时变量会捕获到block内部，且用的值传递。&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 会捕获，用的指针传递。&lt;/li&gt;
  &lt;li&gt;全局变量，不会捕获，block运行的时候会直接访问&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;auto临时变量代表 autorelease的在一个作用域内的临时变量&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098593774.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中FuncPtr指的block函数的指针。 
block分为3种类型，分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSGlobalBlock__&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSStackBlock__&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSMallocBlock__&lt;/code&gt;，分为位于以下内存区域，那么什么样的block会属于什么样的类型？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098896250.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098896265.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图表示不同的block因为操作的变量类型不一样，所以block类型也不一样。因为auto变量是临时变量会存在&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;中自动销毁，所以相应block就是&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;。没访问auto变量则存在常量区&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;为什么block用copy修饰&quot;&gt;为什么block用copy修饰？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;由于&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stackblock&lt;/code&gt;在栈中，且捕获的是在栈中的变量，如果变量销毁，有可能block访问的就的数据就是野指针，&lt;strong&gt;所以&lt;/strong&gt;需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;stackblock&lt;/code&gt;通过调用&lt;strong&gt;copy&lt;/strong&gt;方法转为&lt;code class=&quot;highlighter-rouge&quot;&gt;mallocblock&lt;/code&gt;即保存到堆中，保证由用户自己创建自己销毁，不会造成程序异常。所以block变量用&lt;strong&gt;copy&lt;/strong&gt;修饰或者直接调用&lt;strong&gt;copy&lt;/strong&gt;方法&lt;/p&gt;

&lt;h2 id=&quot;block如果捕获变量&quot;&gt;block如果捕获变量&lt;/h2&gt;
&lt;p&gt;当block内部访问了对象类型的auto变量时：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果block在栈上，则不会对auto变量强引用&lt;/li&gt;
  &lt;li&gt;如果block被拷贝到堆上：会调用block内部的copy函数（&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_object_assgin&lt;/code&gt;），会根据对象的修饰符__strong, __weak等作出强引用或弱引用&lt;/li&gt;
  &lt;li&gt;如果block从堆上移除：调用block内部dispose函数，对变量release&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;__block与__weak__strong&quot;&gt;__block与__weak、__strong&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt;修饰一个变量会把他包装成一个结构体对象，其中的一个属性就是这个变量。且这个结构体对象会把捕获的对象进行引用，根据对象前面是否使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;__strong&lt;/code&gt; 决定是弱引用还是强引用。
block中的&lt;code class=&quot;highlighter-rouge&quot;&gt;forwarding&lt;/code&gt;指针是指向自己位于堆中的地址，如果修饰的是对象，block中还会增加2个内存管理方法,&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dispose&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;__weak 和 __strong 目的是在变量被block捕获的时候以什么引用方式。&lt;/p&gt;

&lt;h2 id=&quot;循环引用问题&quot;&gt;循环引用问题：&lt;/h2&gt;
&lt;p&gt;对象 强引用 block; block  强引用  对象 导致无法释放， 解决办法是将其中一条链路变为弱引用，则能完成释放。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(5)-Block/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(5)-Block/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(4)-方法调用机制</title>
        <description>&lt;h2 id=&quot;消息发送objc_msgsend&quot;&gt;消息发送objc_msgSend()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;缓存中查找方法，找到了直接调用&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;class_rw_t&lt;/code&gt;方法列表中查找，找到了缓存到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，再调用&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;superClass&lt;/code&gt; 缓存中查找，找到了缓存到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，再调用&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;superClass class_rw_t&lt;/code&gt;方法列表中查找，找到了缓存到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，再调用&lt;/li&gt;
  &lt;li&gt;递归父类查找，直到父类为空，执行下一步动态方法解析&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态方法解析&quot;&gt;动态方法解析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;若未动态解析过，则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;resolveInstanceMethod:  &lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resolveClassMethod:&lt;/code&gt; 来完成方法添加&lt;/li&gt;
  &lt;li&gt;不管有没有实现，都会再次走上一步的方法查找
    &lt;ul&gt;
      &lt;li&gt;若找到则执行并结束&lt;/li&gt;
      &lt;li&gt;没找到则执行下一步消息转发&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;消息转发&quot;&gt;消息转发&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;forwardingTargetForSelector:&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;不为空则走&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt; 向转发的对象发送消息调用&lt;/li&gt;
      &lt;li&gt;返回值为nil,调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;methodSignatureForSelector&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;methodSignatureForSelector&lt;/code&gt; 返回为空 则crash&lt;/li&gt;
  &lt;li&gt;不为空则调用 ForwardInvocation方法，在里面可以手动invoca和获取修改invoca的所有属性，包括target，methodSignature，selector&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;super-关键字&quot;&gt;super 关键字&lt;/h2&gt;
&lt;p&gt;[self class] 与 [super class] 结果一样，因为super关键字底层实现是调用
&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSendSuper({self, class_getSuperClass('selfClass')}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sel_registerName('class'))&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSendSuper&lt;/code&gt;意义是从父类开始查找class方法，但是方法接收者还是self, 所以才能实现跳过自己，直接调用父类的方法。
class方法的实现是objc_getClass(self), 因为前面接收者是self,所以方法实现里的参数还是自己，那么打印出来就是一样的。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(4)-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(4)-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(3)-KVC &amp; KVO</title>
        <description>&lt;h2 id=&quot;kvo&quot;&gt;KVO&lt;/h2&gt;
&lt;p&gt;Person 类的对象p 注册监听。
原理：注册监听后，系统利用runtime动态生成一个新的子类&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_Person&lt;/code&gt;对象，且将&lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;isa = NSKVONotifying_Person&lt;/code&gt;. 新的类重写set方法和class方法。
在set方法中，先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;willChangeValueForKey&lt;/code&gt;, 然后赋值，最后&lt;code class=&quot;highlighter-rouge&quot;&gt;didChangeValueForKey&lt;/code&gt;出发监听的方法。
&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_Person -&amp;gt;superClass = Person&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_Person-&amp;gt;isa = meta-NSKVONotifying_Person&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想手动调用监听方法：可以先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;willChangeValueForKey&lt;/code&gt;, 再调用&lt;code class=&quot;highlighter-rouge&quot;&gt;didChangeValueForKey&lt;/code&gt;即可&lt;/p&gt;

&lt;h2 id=&quot;kvc&quot;&gt;KVC&lt;/h2&gt;
&lt;p&gt;下图是KVC获取属性和设置属性的调用原理图，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;[p setValue:21 forKey:@“age”]&lt;/code&gt;,找到set方法，因为声明了一个age属性，所以通过setAge方法找到，并赋值后触发监听。如果没有age属性，则不会触发监听。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023005369387.png&quot; alt=&quot;截屏2020-10-09 下午2.55.25&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023005401951.png&quot; alt=&quot;截屏2020-10-09 下午2.55.32&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(3)-KVC-&-KVO/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(3)-KVC-&-KVO/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(2)-Category类别 &amp; 关联对象</title>
        <description>&lt;h2 id=&quot;category&quot;&gt;Category&lt;/h2&gt;
&lt;p&gt;分类在编译的时候变成&lt;code class=&quot;highlighter-rouge&quot;&gt;category_t&lt;/code&gt; 结构体，其中包含所有方法，协议，属性等。
运行的时候把Category数组合并到Class的大数组中，后面参与编译的在数组的前面，也解释了为什么类别能够覆盖主类的方法，因为在方法查找时先找到类别的方法而已。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+laod()&lt;/code&gt;是在app启动时加载类、分类的时候调用。
调用原理与普通的category方法不同，是直接按照主类，类别的方法调用专门存取load方法的指针来调用load方法，即调用顺序一定是主类，分类1，分类2。。。而且如果父类还未load，先调用父类load。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+initialize()&lt;/code&gt;在类第一次接受消息时调用。且方法是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend()&lt;/code&gt;方法调用，则会从大数组中寻找方法，找到第一个肯定是类别的方法，则调用完毕结束。若父类还未初始化，则先调用父类initialize&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;关联对象&quot;&gt;关联对象&lt;/h2&gt;
&lt;p&gt;可以使用runtime的关联对象给categoty添加成员变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_setAssociatedObject&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_getAssociatedObject&lt;/code&gt;,其中key的参数很重要，必须是不变的一个地址，有多种实现方式，可以用静态变量例如@“key”, 因为存在常量区，所以地址不变。可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;static void * KEYNAEM = &amp;amp;KEYNAME&lt;/code&gt;， 取出定义的全局变量的指针用作key&lt;/p&gt;

&lt;p&gt;原理: 全局保存一个&lt;code class=&quot;highlighter-rouge&quot;&gt;AssociationsManager&lt;/code&gt;，和其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;,保存所有的对象和对象需要监听的属性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16022999875266.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(2)-Category%E7%B1%BB%E5%88%AB-&-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(2)-Category%E7%B1%BB%E5%88%AB-&-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(1)-Class &amp; isa</title>
        <description>&lt;h2 id=&quot;类初始化内存分配&quot;&gt;类初始化内存分配&lt;/h2&gt;
&lt;p&gt;NSObject占用内存大小为16个字节，但是NSObjct只有一个属性就是isa只占用8个字节，由于底层设计原因最少需要16个字节。&lt;br /&gt;
结构体内存对齐，(x+7)&amp;amp; ~x 是将x按照8字节对齐。不满8就补齐8字节
malloc 中的内存分配也会有内存对齐规则，mac中是16的倍数，如果传入只需要24字节，alloc后系统会分配32个字节空间即内存对齐。 &lt;br /&gt;
class_getInstanceSize 返回的是对象需要的内存， NSObjcet中的isa占用8， 加上继承来的每个属性的空间。
malloc_size 返回的是实际分配的空间大小&lt;/p&gt;

&lt;h2 id=&quot;oc中的对象类型&quot;&gt;OC中的对象类型&lt;/h2&gt;
&lt;p&gt;分为3种&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实例对象
    &lt;ul&gt;
      &lt;li&gt;isa&lt;/li&gt;
      &lt;li&gt;成员变量值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类对象
    &lt;ul&gt;
      &lt;li&gt;isa&lt;/li&gt;
      &lt;li&gt;superclass&lt;/li&gt;
      &lt;li&gt;属性、对象方法、协议、成员变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;元类对象
    &lt;ul&gt;
      &lt;li&gt;isa&lt;/li&gt;
      &lt;li&gt;superclass&lt;/li&gt;
      &lt;li&gt;类方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类对象是由元类对象描述的，即class-&amp;gt;isa = metaclass, 但是二者结构一致，只是存储的数据不同。    &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;object_getClass(id)&lt;/code&gt; 传入是对象，则返回类对象，传入是类对象，返回元类对象
&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_getClass(char * className)&lt;/code&gt; 只会返回类对象。&lt;/p&gt;

&lt;h2 id=&quot;对象之间的关系&quot;&gt;对象之间的关系&lt;/h2&gt;
&lt;p&gt;有3个类 NSObjcect -&amp;gt; Person -&amp;gt; Student，
&lt;code class=&quot;highlighter-rouge&quot;&gt;[stu studentInstanceMethod];&lt;/code&gt; stu-&amp;gt;isa = Student类寻找对象方法来执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;[stu personInstanceMethod]; &lt;/code&gt; stu-&amp;gt;isa = Student-&amp;gt;superClass = Person寻找对象方法
&lt;code class=&quot;highlighter-rouge&quot;&gt;[stu load]; &lt;/code&gt;stu-&amp;gt;isa = Student-&amp;gt;superClass = Person-&amp;gt;superClass = NSObject寻找对象方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Student studentClassMethod];&lt;/code&gt; Student-&amp;gt;isa = Meta_Student 寻找Student的类方法   &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[Student personClassMethod];&lt;/code&gt; Student-&amp;gt;isa = Meta_Student-&amp;gt;superclass = Meta_Person 寻找person的类方法&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[Student copy]; &lt;/code&gt;Student-&amp;gt;isa = Meta_Student-&amp;gt;superclass = Meta_Person-&amp;gt;superclass=Meta_NSObject 寻找NSObject的类方法   &lt;br /&gt;
一旦中途找到，则停止后续寻找，这就是为什么override会覆盖父类同名方法&lt;/p&gt;

&lt;p&gt;isa指针地址需要&amp;amp; isa_mask才能得到真实的class的地址
superClass地址 直接就是真实superclass地址
&lt;strong&gt;总结&lt;/strong&gt;
instance调用实例方法轨迹
isa找到class,方法不存在，就通过superclass找到父类(类对象)&lt;/p&gt;

&lt;p&gt;class调用类方法轨迹
isa找meta-class，方法不存在，就通过superclass找父类(元类对象)&lt;/p&gt;

&lt;h2 id=&quot;class的结构&quot;&gt;Class的结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022266359919.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;class_rw_t 中存放的是可读写的所有数据，class_ro_t保存的是只读的数据，主要是主类中生成的方法变量协议等property_list_t一维数组。class_rw_t中存放的是包含类别变量协议方法的一个大的二维数组property_array_t，存放主类和类别的小数组数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022266740521.jpg&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;方法缓存&quot;&gt;方法缓存&lt;/h2&gt;
&lt;p&gt;class中有个cache_t cache, 用来做方法的缓存，使用哈希表实现。第一次在rw_t中的methods中遍历查找方法实现，找到就放入cache中，节省查找时间。
插入和查询时分别用SEL按位与 mask,得到哈希表的index,解决哈希表冲突的方式是开放地址法，就是往前寻找一位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267154421.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在arm64之前，isa是一个普通指针，指向class和meta-class地址
arm64之后， ISA经过优化，使用union数据结构，使用位域来增加存储信息，增加内存利用率
下图中bits为真正存放数据的值，struct中只是申明bits中分别多少位是什么数据。在取值时将bits按位与得到指定位数的值是多少而不受其他位数据的影响。例如shiftcls是存放类地址的，使用了33位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267618486.jpg&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267618501.jpg&quot; alt=&quot;2&quot; /&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267618514.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(1)-Class&isa/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(1)-Class&isa/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>JSBridge实现原理</title>
        <description>&lt;h2 id=&quot;什么是jsbridge&quot;&gt;什么是JSBridge&lt;/h2&gt;
&lt;p&gt;由于Native和H5的各自特性，尤其的H5的易于部署的适用与双端的特点，使得为了满足业务的需要，公司实际项目的开发过程中往往会融合两者进行 Hybrid 开发。
JSBridge 是一种 JS 实现的 Bridge，连接着桥两端的 Native 和 H5。它在 APP 内方便地让 Native 调用 JS，JS 调用 Native ，是双向通信的通道。&lt;/p&gt;
&lt;h2 id=&quot;为什么要做jsbridge&quot;&gt;为什么要做JSBridge&lt;/h2&gt;
&lt;p&gt;我们知道OC调用JS的方法可以通过Webview的evaluateJavaScript:completionHandler: 方法实现，但是解决不了异步问题，当JS需要执行一些耗时操作，就无法立即给OC返回相应结果。
同样JS调用OC的方法没有现成的方法，且也无法解决上面的异步问题。
所以JSBridge的出现，目的是解决OC与JS相互异步调用，且当其中有多个异步回调，要能处理好各回调之间的关系，能够做到类似CS架构。
这样能处理原先很多无法实现的能力，例如获取定位，相机拍照，手机传感器等等需要异步的接口调用能力。&lt;/p&gt;

&lt;h2 id=&quot;怎么实现jsbridge&quot;&gt;怎么实现JSBridge&lt;/h2&gt;
&lt;h3 id=&quot;10版本&quot;&gt;1.0版本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JS调用Native，通过自定义跳转URL协议头(例如jsbridge://)，并携带相应参数，Native拦截URL并解析来实现。&lt;/li&gt;
  &lt;li&gt;OC调用Native，通过evaluateJavaScript:completionHandler: 且用runloop阻塞当前线程，直到返回结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2端各维护一套响应回调和方法回调的映射表，从而实现在通信过程中，即使异步依然可以从映射表中查出回调地址。
流程图如下：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200929/16013608341218.png&quot; style=&quot;zoom:70%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;20版本&quot;&gt;2.0版本&lt;/h3&gt;
&lt;p&gt;通过JavascriptCore实现,关于JSCore详见&lt;a href=&quot;https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html&quot;&gt;深入理解JSCore&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/JSBridge%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/JSBridge%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>LeetCode刷题笔记</title>
        <description>&lt;h2 id=&quot;链表和数组&quot;&gt;链表和数组&lt;/h2&gt;
&lt;p&gt;多见链表的全反转，K个一组反转链表
   head 等表示指定Node,不是index也不是指针
   head.next = node1 表示该Node的后继节点是node1
   node2 = node1.next, 表示将node1的后继节点node赋值给 node2&lt;/p&gt;

&lt;h2 id=&quot;0-交换链表节点&quot;&gt;0. 交换链表节点&lt;/h2&gt;
&lt;h3 id=&quot;剑指-offer-反转链表&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/&quot;&gt;剑指 Offer 反转链表&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  def reverseList(self, head: ListNode) -&amp;gt; ListNode:
        cur = head
        prev = None
        while cur:
            cur.next, prev, cur = prev, cur, cur.next
        return prev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;两两交换链表中的节点&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/swap-nodes-in-pairs/&quot;&gt;两两交换链表中的节点&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
给定 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, 你应该返回 2-&amp;gt;1-&amp;gt;4-&amp;gt;3.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200925/16010201705371.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; def swapPairs(self, head):
        a, a.next = self, head
        while a.next and a.next.next:
            b,c = a.next, a.next.next
            a.next, b.next, c.next = c, c.next, b
            a = b
        return self.next
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;1-判断链表是否有环&quot;&gt;1. 判断链表是否有环&lt;/h2&gt;
&lt;p&gt;判断是否有环可用快慢指针， 起点相同，快指针每次走2个步，满指针每次都1步，如果最终快慢指针相遇，则证明此链表中有环。
用set将路径上每个节点存起来，每走一步判断set中是否有当前节点，若有则证明有环&lt;/p&gt;

&lt;h3 id=&quot;环形链表&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot;&gt;环形链表&lt;/a&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;给定一个链表，判断链表中是否有环&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def hasCycle(self, head: ListNode) -&amp;gt; bool:
    # 快慢指针法
        fast = slow = head
        while fast and slow and fast.next:
            fast = fast.next.next
            slow = slow.next
            if (fast == slow):
                return True
        return False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;环形链表-ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot;&gt;环形链表 II&lt;/a&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def detectCycle(self, head: ListNode) -&amp;gt; ListNode:
    # 快慢指针不好使，快指针可能会跳过那个节点
    # 所以还是使用的缓存法，把走过的路缓存起来
        cur = head
        cache = set()
        while cur:
            if cur not in cache:
                cache.add(cur)
                cur = cur.next
            else:
                return cur
        return None
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;k-个一组翻转链表&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/&quot;&gt;K 个一组翻转链表&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
k 是一个正整数，它的值小于或等于链表的长度。
如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。&lt;/p&gt;

&lt;h2 id=&quot;2-判断括号字符串是否有效&quot;&gt;2. 判断括号字符串是否有效&lt;/h2&gt;
&lt;p&gt;用堆栈，如果符号是左边，入栈，如果符号是右边则与栈顶符号做匹配。最终堆栈为空则有效
将字符串中所有{} [] () 替换为空字符串，如果最后又剩余则表示字符串无效&lt;/p&gt;

&lt;h3 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-parentheses/&quot;&gt;有效的括号&lt;/a&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def isValid(self, s: str) -&amp;gt; bool:
         #堆栈的方式
        symbols = {'}':'{',']':'[',')':'('}
        stack = []
        for i in s:
            if i not in symbols:
                stack.append(i)
                # if stack为空意思是 如果栈还是空的就来一个右符号，则肯定是无效的
                # 或者是栈取出来的不一样
            elif not stack or symbols[i] != stack.pop():
                return False
        return not stack
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-用队列实现栈用栈实现队列&quot;&gt;3. 用队列实现栈&amp;amp;用栈实现队列&lt;/h2&gt;
&lt;p&gt;队列-&amp;gt; 栈: 每个元素入栈后，将前面n-1个元素pop然后压入栈，保证第n个元素总是位于第一位的。
栈-&amp;gt;队列： 用2个栈， A为输入栈，B为输出栈。 当pop时将A所有元素依次出栈并压入B栈，形成倒叙的A栈数据。后续若B栈为空，则继续讲A倒叙压入B栈中再执行pop&lt;/p&gt;

&lt;h3 id=&quot;用队列实现栈&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-stack-using-queues/&quot;&gt;用队列实现栈&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    def __init__(self):
        self.q = []

    def push(self, x: int) -&amp;gt; None:
        self.q.append(x)

    def pop(self) -&amp;gt; int:
        temp = self.q[-1]
        del self.q[-1]
        return temp

    def top(self) -&amp;gt; int:
        return self.q[-1]

    def empty(self) -&amp;gt; bool:
        return not len(self.q)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;用栈实现队列&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-queue-using-stacks/&quot;&gt;用栈实现队列&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    def __init__(self):
        self.s1 = []
        self.s2 = []

    def push(self, x: int) -&amp;gt; None:
        self.s1.append(x)

    def pop(self) -&amp;gt; int:
        if not len(self.s2):
            for _ in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2.pop()

    def peek(self) -&amp;gt; int:
        if not len(self.s2):
            for _ in range(len(self.s1)):
                self.s2.append(self.s1.pop())
        return self.s2[len(self.s2)-1]

    def empty(self) -&amp;gt; bool:
        return len(self.s1) == 0 and len(self.s2) == 0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4-返回数据流中的第k大元素&quot;&gt;4. 返回数据流中的第K大元素&lt;/h2&gt;
&lt;p&gt;用最小堆，维护一个大小为K的最小堆，每次比较当前元素与堆顶元素，若当前元素大，则删除堆顶元素，加入当前元素并重新排序，然后继续扫描下一个元素&lt;/p&gt;
&lt;h2 id=&quot;5-返回滑动窗口中的最大值&quot;&gt;5. 返回滑动窗口中的最大值&lt;/h2&gt;
&lt;p&gt;使用最大堆，同上理
使用双端队列， 每次窗口扫到一个新元素，则将新元素与窗口中第一个元素比较大小，如果新元素大，则将窗口中前面所有元素删除，新元素成为第一个元素。如果旧窗口中的元素大，则不作处理，新元素加入窗口中。 此举目的是保证窗口中始终把最大元素放在最左边位置即第一位，后续扫描只需要比较一次大小即可。&lt;/p&gt;
&lt;h2 id=&quot;6-有效的字母异位词&quot;&gt;6. 有效的字母异位词&lt;/h2&gt;
&lt;p&gt;单词中每个字母个数相同，排序不同。
使用排序，排序后比较是否一致
使用hashMap, 将每个字母出现的次数统计在map中，最后比较map是否一致&lt;/p&gt;

&lt;h3 id=&quot;有效的字母异位词&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/valid-anagram/&quot;&gt;有效的字母异位词&lt;/a&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 排序的方式
def isAnagram(self, s: str, t: str) -&amp;gt; bool:
        return sorted(s) == sorted(t)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# hashMap 的方式
    def isAnagram(self, s: str, t: str) -&amp;gt; bool:
        voc1 = {}
        voc2 = {}
        for char in s:
            voc1[char] = voc1.get(char, 0) + 1
        for char in t:
            voc2[char] = voc2.get(char, 0) + 1
        return voc1 == voc2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;7-两数之和&quot;&gt;7. 两数之和&lt;/h2&gt;
&lt;p&gt;2个for循环，暴力计算
用set, 遍历第一层，计算set中是否包含target-item的值&lt;/p&gt;

&lt;h3 id=&quot;两数之和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/two-sum/&quot;&gt;两数之和&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def twoSum(self, nums: List[int], target: int) -&amp;gt; List[int]:
        res = {}
        # 遍历nums， 输出index和每个item值, 这里map中存的是数值的index，方便返回
        for i, item in enumerate(nums):
            if (target-item) not in res:
                res[item] = i
            else:
                return [res[target-item], i]
        return []
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;8-三数之和输出所有三个数字之和为0的组合&quot;&gt;8. 三数之和，输出所有三个数字之和为0的组合&lt;/h2&gt;
&lt;p&gt;3层for循环，暴力计算，同上
用set，2个for循环，计算set中是否包含-item1-item2的值&lt;/p&gt;

&lt;h3 id=&quot;三数之和&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot;&gt;三数之和&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def threeSum(self, nums):
    nums.sort()
    res = set()
    for i,item in enumerate(nums[:-2]):
        # 此判断为了能快速判断，若item与前一位值相同则继续循环
        # 因为如果前面相同值有解，后面item的解一定与前面的相同，要求是答案中是不重复的，所以可以排除不遍历
​        if i &amp;gt;= 1 and item == nums[i-1]:
​            continue
​        d = {}
​        for item2 in nums[i+1:]:
​            if item2 not in d:

                # 这里的处理方式同两数之和，前2个数的负数就是第3个解，3数值和为0.
​                d[-item-item2] = 1
​            else:
​                res.add((item, -item-item2, item2))
​    return map(list, res)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;延伸  输出三数之和为0的所有index组合&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;9-验证二叉排序树&quot;&gt;9. 验证二叉排序树&lt;/h2&gt;
&lt;p&gt;中序遍历整个树，判断是否为有序数组
递归，每次递归当前节点的左子树，然后判断根节点的值是否比前继节点值大&lt;/p&gt;
&lt;h3 id=&quot;验证二叉搜索树&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/validate-binary-search-tree/&quot;&gt;验证二叉搜索树&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;给定一个二叉树，判断其是否是一个有效的二叉搜索树即二叉平衡树&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def isValidBST(self, root: TreeNode) -&amp;gt; bool:        
        self.prve = None
        def isBST(root):
            if not root:
                return True
            if not isBST(root.left):
                return False 
            # 这里为什么要小于 前继节点的值？
            # 因为这是中序遍历，会把左子树全部走完才会走到每个树的根节点，所以prve一定是比根节点小的值，因为都是左子树嘛
            # 那么这里一定是更节点 &amp;gt; prve的值
            if self.prve and self.prve.val &amp;gt;= root.val:
                return False
            # 这里赋值的原因是，要拿根节点与右子树比较
            self.prve = root 
            return isBST(root.right)
        return isBST(root)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;10-二叉树二叉搜索树的最近公共祖先&quot;&gt;10. 二叉树&amp;amp;二叉搜索树的最近公共祖先&lt;/h2&gt;
&lt;p&gt;从链表角度考虑，由子节点往根节点遍历，路径上所有点记录下来，比较2个路径中最后的相同节点。
递归，分别寻找左子树和右子树中是否包含P 和 Q这2个节点，如果包含返回节点，不包含则继续递归直到子树中出现节点或者到达叶子节点返回空，那么这个树就将单一的P或Q一直往上透传，直到在某个节点中与取到的P或Q组成一对，则返回当前根节点的值即为公共祖先&lt;/p&gt;
&lt;h3 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/&quot;&gt;二叉搜索树的最近公共祖先&lt;/a&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&amp;gt; 'TreeNode':
        # 简单递归
        def lower(root, p, q):
            if not root or root == p or root == q : return root
            left = lower(root, p,q) # 结果是p 或 q 或叶子节点
            right = lower(root, p ,q)
            if not left: return right # 如果左子树没有结果，结果一定在右边
            if not right: return left # 同理
            if left and right : return root # 如果左右子树都有值，说明当前节点就是左右子树的共同根节点
        return lower(root, left, right)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&amp;gt; 'TreeNode':
        # 排序递归
        if  root.val&amp;lt; p and root.val&amp;lt; q:
            return lowestCommonAncestor(root.right, p,q)
        if  root.val&amp;gt; p and root.val&amp;gt; q:
            return lowestCommonAncestor(root.left, p,q)
        if  root.val&amp;gt;p and root.val &amp;lt; q:
            return root
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&quot;&gt;二叉树的最近公共祖先&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 同上题简单递归，因为此题无序，无法使用排序逻辑
def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&amp;gt; 'TreeNode':
        def lowest(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -&amp;gt; 'TreeNode':
            # 此处如果root是空，也可以返回，表示后续没找到，走8，9行判断
            if not root or root == p or root == q: return root
            left = lowest(root.left, p, q)
            right = lowest(root.right, p, q)
            if not left: return right
            if not right:return left
            if left and right: return root
        return lowest(root, p, q)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;11-powxn--即x的n次方&quot;&gt;11. Pow(x,n)  即x的n次方&lt;/h2&gt;
&lt;p&gt;递归，分治的思想，x的n次方可以拆分为 x的n/2次方*x的n/2次方，  还可以继续往下拆分，有效避免了重复计算，时间复杂度是logn.&lt;/p&gt;

&lt;h3 id=&quot;powx-n&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot;&gt;Pow(x, n)&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;实现 pow(x, n) ，即计算 x 的 n 次幂函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # 使用递归方式,分治
    def myPow(self, x: float, n: int) -&amp;gt; float:
        if not n : return 1
        if n &amp;lt; 0 : return (1 / self.myPow(x, -n))
        if n %2 : # 奇数
            return x * self.myPow(x, n-1)
        return self.myPow(x*x, n/2) # 偶数
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;12-求众数即元素出现次数大于n2&quot;&gt;12. 求众数，即元素出现次数大于n/2&lt;/h2&gt;
&lt;p&gt;暴力计算，2个loop,  O(n²)
HashMap, 遍历所有元素，把出现次数保存到map中，再查找map中多次数的元素
排序后获取数组中间位置即为众数
分治思想，获取左右子集中的众数，如果左右众数一致则得出结果，不一致则继续分治拆分左右子集，统计出所有子集的众数，最多的为众数&lt;/p&gt;
&lt;h3 id=&quot;多数元素&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element/&quot;&gt;多数元素&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def majorityElement(self, nums: List[int]) -&amp;gt; int:

    # 摩尔投票法， 当一个数的重复次数超过数组长度的一半，每次将两个不相同的数删除，最终剩下的就是要找的数。
        res = 0
        count = 0
        for item in nums:
            if count == 0:
                res = item
                count = 1
            elif item == res:
                count += 1
            else:
                count -= 1
        if count &amp;gt; 0: return res

def majorityElement(self, nums: List[int]) -&amp;gt; int:
    # 哈希法
        res = {}
        maxItem = 0
        maxNums = 0
        for item in nums:
            res[item] = res.get(item, 0) + 1
        for item, value in res.items():
            if maxNums &amp;lt; value : 
                maxItem = item
                maxNums = value
        return maxItem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;13-买卖股票的最佳时机&quot;&gt;13. 买卖股票的最佳时机&lt;/h2&gt;
&lt;p&gt;DFS 深度优先搜索
贪心算法: 选择局部最优
动态规划&lt;/p&gt;
&lt;h2 id=&quot;14-二叉树层次遍历&quot;&gt;14. 二叉树层次遍历&lt;/h2&gt;
&lt;p&gt;BFS, Breadth First Search 广度优先搜索
DFS, Depth First Search  深度优先搜索&lt;/p&gt;
&lt;h3 id=&quot;二叉树的层序遍历&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-tree-level-order-traversal/&quot;&gt;二叉树的层序遍历&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def levelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]:   
        # BFS 用队列
        queue = []
        queue.append(root)
        result = []
        while queue:
            size = len(queue)
            current_level = []
            for _ in range(size):
                node = queue.pop(0)
                current_level.append(node.val)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
            result.append(current_level)
        return result
     

def levelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]:   
        # DFS用栈
        result = []
        def dfs(node, level):
            if not node: return []
            if len(result) &amp;lt; level+1:
                result.append([])
            result[level].append(node.val)
            dfs(node.left, level+1)
            dfs(node.right, level+1)
        dfs(root,0)
        return result
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;15-二叉树的最大和最小深度&quot;&gt;15. 二叉树的最大和最小深度&lt;/h2&gt;
&lt;p&gt;同上，可以使用BFS 和 DFS方法解决。
BFS则是使用 while循环遍历当前层级的queue中所有对象，（最小）如果其中一个节点是叶子节点，则结束遍历，输出当前层级即为最小深度。（最大）一直遍历整棵树，输出最后的层级即为最大深度
DFS则使用递归，递归每层的左右节点，结束条件是若当前节点是空返回0.&lt;/p&gt;
&lt;h2 id=&quot;16-生成有效括号组合&quot;&gt;16. 生成有效括号组合&lt;/h2&gt;
&lt;p&gt;同上，使用DFS递归来解决，注意2个递归条件，已使用的右括号必须小于左括号，才可继续增加右括号，否则没有多于的左括号去配对。当左右括号全部使用完毕将字符串添加到结果list中&lt;/p&gt;
&lt;h2 id=&quot;17-n皇后问题&quot;&gt;17. N皇后问题&lt;/h2&gt;
&lt;p&gt;使用DFS递归， 思想是类似围棋或象棋算法每一步都会产生一个分支，每个分支下一步棋又会产生一个分支，每条分支的每一步都会有成功或者失败的判断即剪枝的条件，如剪枝成立则此分支结束，回溯到上一分支继续走其他步。上上一步也可回溯继续走下去。只要某个条件下能够走将N个皇后走完，则代表前面的每一步都是成立的，且路径都会有记录。
使用DFS+位运算， 太复杂， 后续再研究&lt;/p&gt;
&lt;h2 id=&quot;18-数独问题&quot;&gt;18. 数独问题&lt;/h2&gt;
&lt;p&gt;依然使用DFS递归然后回溯去搜索解，剪枝的条件是横竖现有值不能重复，3&lt;em&gt;3的9宫格中数字不能重复。除此判断条件外，直接递归回溯直到走完所有9&lt;/em&gt;9输出答案&lt;/p&gt;
&lt;h2 id=&quot;19-实现一个求解平方根的函数&quot;&gt;19. 实现一个求解平方根的函数&lt;/h2&gt;
&lt;p&gt;用二分查找法，因为y=x²是单调递增，所以是有序有界的，可以通过mid*mid来逼近真实的x	
用牛顿迭代法，有数学公式&lt;/p&gt;

&lt;h2 id=&quot;20-实现一个字典树即trie树-字典树&quot;&gt;20. 实现一个字典树即Trie树 字典树&lt;/h2&gt;
&lt;p&gt;字典里面套字典，表示每个节点有多个边相对应，穿起来所有路径即为最终的单词，Trie树如下图，
例如insert  “apple” ，则生成Trie树为 {‘a’: {‘p’: {‘p’: {‘l’: {‘e’: {‘#’: ‘#’}}}}}}
最后一个字母e的分支只有结束标识符”#”
在上面的基础上insert “app”，  则树为 {‘a’: {‘p’: {‘p’: {‘l’: {‘e’: {‘#’: ‘#’}}, ‘#’: ‘#’}}}}
在p的分支有2个，一个是”l”, 一个是结束符”#” ,代表app可以结束，也可以只是前缀&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200925/16010192691189.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-二维网格中的单词搜索问题&quot;&gt;21. 二维网格中的单词搜索问题&lt;/h2&gt;
&lt;p&gt;在二维网格中搜索单词，可以用DFS，去递归+回溯。 也可用DFS+Trie树+回溯。把单词编制成Trie树，遍历网格中每个单词，若是树中的首字母，则接着递归首字母附件的4个字母是否存在于树中，不存在则回溯&lt;/p&gt;
&lt;h2 id=&quot;22-统计位1的个数&quot;&gt;22. 统计位1的个数&lt;/h2&gt;
&lt;p&gt;先学习一下常见的位运算
x&amp;amp;1 == 1 or == 0 判断奇偶性
x = x &amp;amp; (x-1)  清除x最低位的1
x&amp;amp;-x 拿到最低位的1&lt;/p&gt;
&lt;h2 id=&quot;23-2的幂次方问题比特位计数问题&quot;&gt;23. 2的幂次方问题&amp;amp;比特位计数问题&lt;/h2&gt;
&lt;p&gt;2的幂次方有个特点，2进制只有1位是1，其他全是0，可以用上面的位运算解决
比特位计数问题如果用上面的暴力算法是可以解决的，问题是每个数字都要计算一遍浪费时间，最好的方式是前面计算的结果，后面直接使用，公式是count[x] = count[x&amp;amp;(x-1)] +1 ,就是 x比x小1位的数字的个数+1. 这个一个循环得到结果，很巧妙&lt;/p&gt;
&lt;h3 id=&quot;2的幂&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-two/&quot;&gt;2的幂&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 2的幂次方 只有一位是1，其他全是0， 所以打掉1之后 就是0了
def isPowerOfTwo(self, n: int) -&amp;gt; bool:
        if n != 0 and n&amp;amp;(n-1) == 0:
            return True
        else:
            return False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;24-动态规划&quot;&gt;24. 动态规划&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;递推 （递归+记忆化）&lt;/li&gt;
  &lt;li&gt;状态的定义： opt[n], dp[n]…&lt;/li&gt;
  &lt;li&gt;状态转移方程： opt[n] = best_of(opt[n-1] ,opt[n-2] …)&lt;/li&gt;
  &lt;li&gt;最优子结构： 最终的结果是由最优的每一步得到的，每一步的最优结果都得到保存，所以如果问子结构中最优结果就可以直接得到
例如斐波拉切数列，F[n] = F[n-1] + F[n-2], 直接递归会有很多重复计算，例如F[4]=F[3]+F[2] = F[2]+F[1]+F[2],重复计算了F[2],如果将F[2]结果保存起来，就节省很多时间。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;25-动态规划dp-vs-回溯-vs-贪心&quot;&gt;25. 动态规划DP vs 回溯 vs 贪心&lt;/h2&gt;
&lt;p&gt;回溯(递归)  -&amp;gt; 重复计算， 可以做到总体最优，但是计算量大，性能低下
贪心 -&amp;gt; 永远局部最优,如果简单的每步局部最优就是总体最优，这样是可以的，但是往往没这么简单
DP -&amp;gt; 记录局部最优子结构， 
其实如果能够递归的问题，一般都可通过DP解决&lt;/p&gt;

&lt;h2 id=&quot;26-爬楼梯&quot;&gt;26. 爬楼梯&lt;/h2&gt;
&lt;p&gt;递推公式同 斐波拉切 F[n] = F[n-1] + F[n-2]
因为最后一步有多少种方法等于 前一步的方法 加上前2步的方法， 因为可以一次可以1个台阶或者2个台阶
DP定义：到第n层有多少种方法&lt;/p&gt;
&lt;h2 id=&quot;27-三角形的最小路径和&quot;&gt;27. 三角形的最小路径和&lt;/h2&gt;
&lt;p&gt;一种递归+回溯，能解决，只是时间很长，重复计算
动态规划，从底层开始，往上遍历，上层每次都选择下面2个其中小的一个， 推导出的DP转移方程为F[j]= min(F[j], F[j+1]) + t[i][j]
F[j]为指定层第j个位置到达底部最小路径，以此类推，顶部只需要计算下一层到他的最小路径即可。
DP定义：到第j层最小路径&lt;/p&gt;
&lt;h2 id=&quot;28-乘积最大子数组&quot;&gt;28. 乘积最大子数组&lt;/h2&gt;
&lt;p&gt;动态规划，计算连续的子数组积的最大值， 由于元素可能有正，有负， 如果始终只保留正数，可能后续元素出现负数积就变小了，可能之前的负数与负数的积是最大值。所以需要保留之前的最大值和最小值，乘后续数组元素后再覆盖最大值最小值
DP定义：到第i位最大值和最小值&lt;/p&gt;
&lt;h2 id=&quot;29-买卖股票的最佳时机---买卖股票的最佳时机-iii--买卖股票的最佳时机-ii&quot;&gt;29. 买卖股票的最佳时机  &amp;amp; 买卖股票的最佳时机 III &amp;amp; 买卖股票的最佳时机 II&lt;/h2&gt;
&lt;p&gt;用3维数组，分别代表0~n-1天， 0/1是否持股， 0~k次交易 能够满足大部分股票买卖的状态定义&lt;/p&gt;
&lt;h2 id=&quot;30-最长上升子序列&quot;&gt;30. 最长上升子序列&lt;/h2&gt;
&lt;p&gt;dp[i]状态为 在i点包含i的最长上升子序列， 不是i点的最长上升子序列，所以最后的结果是选择数组中最大的，而不是指定位置的&lt;/p&gt;
&lt;h2 id=&quot;31-零钱兑换&quot;&gt;31. 零钱兑换&lt;/h2&gt;
&lt;p&gt;dp[i] 为凑成当前金额最少的硬币数，则dp方程为 dp[i] = min{dp[i-conins[j] ]} +1, 例如银币金额是[1,2,5], 则dp[11] = min{ dp[10], dp[9], dp[6]} +1
可以把此题当成爬楼梯，到达11层，一次可以跨1步，2步，5步，最少需要多少步一样。&lt;/p&gt;
&lt;h2 id=&quot;32-编辑距离&quot;&gt;32. 编辑距离&lt;/h2&gt;
&lt;p&gt;把A单词转换成B单词最少需要多少步， 可以插入，删除，替换。dp[i][j] 表示从A单词的 i 位置到B单词 j 位置需要的最小操作数。
dp方程为dp[i][j] = if A[i] ==B[j] : dp[i-1][j-1] else:  min{dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}+1
如果当前ij字符相等，则dp[i][j]就等于上一步的结果，不需要变动。如果不等，则等于插入，删除，替换其中一个的最小步数+1&lt;/p&gt;
&lt;h2 id=&quot;33-dp套路-三部曲&quot;&gt;33. DP套路 三部曲&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;套路步骤1， 创建dp状态定义&lt;/li&gt;
  &lt;li&gt;套路步骤2， 初始化dp首位状态&lt;/li&gt;
  &lt;li&gt;套路步骤3， 大循环开始写递推公式，并赋值给dp状态&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;34-并查集&quot;&gt;34. 并查集&lt;/h2&gt;
&lt;p&gt;几个重要方法， 初始化，查找父类，合并。 查找父类可以做路径压缩的优化。&lt;/p&gt;
&lt;h2 id=&quot;35-岛屿数量&quot;&gt;35. 岛屿数量&lt;/h2&gt;
&lt;p&gt;染色法：遍历节点，把节点为“1”的相邻节点赋值为“0”， 并记录为一个岛。可用DFS也可BFS。
并查集：对为“1”的节点初始化，把相邻的合并，最后遍历有多少个roots&lt;/p&gt;
&lt;h2 id=&quot;36-布隆过滤器&quot;&gt;36. 布隆过滤器&lt;/h2&gt;
&lt;p&gt;是一个很长的二进制向量和一个映射函数，用于检索一个元素是否在集合中，如果判断不在集合中，那一定不在集合中。如果判断在集合中，不一定再
特点： 空间效率和查询时间远远超过一般算法，但是有一定误识别率和删除困难。&lt;/p&gt;
</description>
        <pubDate>Fri, 25 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/LeetCode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</guid>
        
        <category>LeetCode</category>
        
        
      </item>
    
      <item>
        <title>iOS 应用启动耗时分析及优化</title>
        <description>&lt;h2 id=&quot;ios-应用启动耗时分析及优化&quot;&gt;iOS 应用启动耗时分析及优化&lt;/h2&gt;

&lt;h3 id=&quot;app启动流程&quot;&gt;App启动流程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;main函数之前&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;1.iOS系统&lt;strong&gt;首先会加载解析该APP的Info.plist文件&lt;/strong&gt;，因为Info.plist文件中包含了支持APP加载运行所需要的众多Key，value配置信息，例如APP的运行条件(Required device capabilities)，是否全屏，APP启动图信息等。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;2.&lt;strong&gt;创建沙盒&lt;/strong&gt;(iOS8后，每次启动APP都会生成一个新的沙盒路径)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;3.根据Info.plist的配置&lt;strong&gt;检查相应权限状态&lt;/strong&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;4.&lt;strong&gt;加载Mach-O文件&lt;/strong&gt;读取dyld路径并&lt;strong&gt;运行dyld动态连接器&lt;/strong&gt;(内核加载了主程序，dyld只会负责动态库的加载)&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;4.1 首先dyld会寻找合适的CPU运行环境&lt;/li&gt;
          &lt;li&gt;4.2 然后加载程序运行所需的依赖库和我们自己写的.h.m文件编译成的.o可执行文件，并对这些库进行链接。&lt;/li&gt;
          &lt;li&gt;4.3 加载所有方法(runtime就是在这个时候被初始化的)&lt;/li&gt;
          &lt;li&gt;4.4 加载C函数&lt;/li&gt;
          &lt;li&gt;4.5 加载category的扩展(此时runtime会对所有类结构进行初始化)&lt;/li&gt;
          &lt;li&gt;4.6 加载C++静态函数，加载OC+load&lt;/li&gt;
          &lt;li&gt;4.7 最后dyld返回main函数地址，main函数被调用&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;main函数执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首屏渲染完成&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;执行UIApplicationMain&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;创建UIApplication对象&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;创建UIApplication的delegate对象&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;创建MainRunloop&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;delegate对象开始处理(监听)系统事件(没有storyboard)&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;根据Info.plist获得最主要storyboard的文件名,加载最主要的storyboard(有storyboard)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;程序启动完毕的时候, 就会调用代理的application:didFinishLaunchingWithOptions:方法
 在application:didFinishLaunchingWithOptions:中创建UIWindow
 创建和设置UIWindow的rootViewController&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;显示第一个窗口&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;各阶段耗时原因&quot;&gt;各阶段耗时原因&lt;/h3&gt;
&lt;h4 id=&quot;main函数之前阶段&quot;&gt;Main函数之前阶段&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;动态库加载越多，启动越慢。&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;减少非系统库的依赖&lt;/p&gt;

      &lt;p&gt;合并非系统库&lt;/p&gt;

      &lt;p&gt;使用静态资源，比如把代码加入主程序&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ObjC类越多，启动越慢&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;减少Objc类数量， 减少selector数量&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C的&lt;code class=&quot;highlighter-rouge&quot;&gt;constructor&lt;/code&gt;函数越多，启动越慢&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;减少C++虚函数数量&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C++静态对象越多，启动越慢&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;使用 struct（其实本质上就是为了减少符号的数量）&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ObjC的&lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;越多，启动越慢&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;减少load方法内的逻辑，在swift中已经拒绝开发者使用+load方法，推荐initializer&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;冷启动时cache hit越少，启动越慢&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;二进制重排&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;main函数之后&quot;&gt;Main函数之后&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;applicationWillFinishLaunching&lt;/code&gt;的耗时，内容越多越慢&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;延后任务管理&lt;/code&gt;解决&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第一屏渲染速度&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;延后和第一屏显示无关的业务逻辑&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;延后任务管理：监听主线程 runloop，在kCFRunloopBeforeWaiting 时执行， KCFRunloopAfterWaiting时停止（闲时主线程队列），或者异步线程执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;分析app耗时分析方法&quot;&gt;分析app耗时分析方法&lt;/h3&gt;

&lt;h4 id=&quot;app启动过程中的耗时分析&quot;&gt;app启动过程中的耗时分析&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;方法1：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Xcode&lt;/code&gt;的菜单中选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Project&lt;/code&gt;→&lt;code class=&quot;highlighter-rouge&quot;&gt;Scheme&lt;/code&gt;→&lt;code class=&quot;highlighter-rouge&quot;&gt;Edit Scheme...&lt;/code&gt;，然后找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Run&lt;/code&gt; → &lt;code class=&quot;highlighter-rouge&quot;&gt;Environment Variables&lt;/code&gt; →&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;DYLD_PRINT_STATISTICS&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;的环境变量。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200924/16009335233132.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;了解main函数之前各个阶段的方法耗时，就能针对耗时大的阶段使用相应前面提到的解决方案。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main()&lt;/code&gt;函数之前总共使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;165.85ms&lt;/code&gt; 中，加载动态库用了&lt;code class=&quot;highlighter-rouge&quot;&gt;120.63ms&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;指针重定位&lt;/code&gt;使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;4.74ms&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjC类&lt;/code&gt;初始化使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;8.00ms&lt;/code&gt;，各种初始化可执行文件使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;32.74ms&lt;/code&gt;,用时最多的几个初始化是&lt;code class=&quot;highlighter-rouge&quot;&gt;libSystem.B.dylib&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libBacktraceRecording.dylib&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libMainThreadChecker.dylib&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可以看到在加载动态库中用时最多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上图中&lt;code class=&quot;highlighter-rouge&quot;&gt;Module&lt;/code&gt;模块是主程序的可执行文件，如果这个阶段用时很多，可以查看&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;缺页中断(Page Fault)&lt;/code&gt;&lt;/strong&gt;发生的次数，因为&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;缺页中断(Page Fault)&lt;/code&gt;&lt;/strong&gt;相对来说会耗费大量时间，这需要了解&lt;strong&gt;虚拟内存&lt;/strong&gt;的工作原理。&lt;/p&gt;

&lt;p&gt;如果想查看真实 &lt;strong&gt;Page Fault&lt;/strong&gt; 次数 , 应该将应用卸载 , 查看第一次应用安装后的效果 , 或者先打开很多个其他应用 .&lt;/p&gt;

&lt;p&gt;因为之前运行过 &lt;code class=&quot;highlighter-rouge&quot;&gt;app&lt;/code&gt; , 应用其中一部分已经被加载到物理内存并做好映射表映射 , 这时再启动就会少触发一部分缺页中断 , 并且杀掉应用再打开也是如此 .&lt;/p&gt;

&lt;p&gt;其实就是希望将物理内存中之前加载的覆盖/清理掉 , 减少误差 .&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;打开Instruments 工具中是 System Trace.&lt;/li&gt;
  &lt;li&gt;选择真机和工程，点击左侧启动，当工程首页加载完成后点击停止。最好是将应用杀掉重新安装 , 因为冷热启动的界定其实由于进程的原因并不一定后台杀掉应用重新打开就是冷启动 .&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200924/16009354232018.png&quot; style=&quot;zoom:70%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;等分析完成，查看缺页次数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200924/16009354255236.png&quot; style=&quot;zoom:70%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这次缺页发生了1509次，耗时200ms，占总耗时的93%。缓存命中1955次只耗时6.42ms，可见缺页造成的耗时很大。&lt;/p&gt;

&lt;p&gt;这里需要用到二进制重排去优化。怎样查看main函数之前到底调用了哪些OC类和方法？可以通过clang插桩方式，详见&lt;a href=&quot;https://juejin.im/post/6844904130406793224#heading-0&quot;&gt;iOS 优化篇 - 启动优化之Clang插桩实现二进制重排
&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;clang静态插桩&lt;/strong&gt;实际上是在编译期就在每一个函数内部二进制源数据添加 hook 代码 ( 我们添加的 __sanitizer_cov_trace_pc_guard 函数 ) 来实现全局的方法 hook 的效果 .&lt;/p&gt;

&lt;p&gt;在build settings的 Other C Flags中, 添加&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-fsanitize-coverage=func,trace-pc-guard
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;添加hook代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void __sanitizer_cov_trace_pc_guard_init(uint32_t *start,
                                         uint32_t *stop) {
    static uint32_t N;  // Counter for the guards.
    
    if (start == stop || *start)return;  // Initialize only once.
    printf(&quot;INIT: %p %p\n&quot;, start, stop);
    for (uint32_t *x = start; x &amp;lt; stop; x++)
        *x = ++N;  // Guards should start from 1.
    
    printf(&quot;totasl count %i\n&quot;, N);
}

//  所以在每个函数调用时都会先跳转执行该函数
void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    // +load方法先于guard_init调用，此时guard为0
//    if(!*guard) { return }
    
    if (stopCollecting) {
        return;
    }
    // __builtin_return_address 获取当前调用栈信息，取第一帧地址（即下条要执行的指令地址，被插桩的函数地址）
    void *PC = __builtin_return_address(0);
    
    PointerNode *node = malloc(sizeof(PointerNode));
    *node = (PointerNode){PC, NULL};
    // 使用原子队列要存储帧地址
    OSAtomicEnqueue(&amp;amp;qHead, node, offsetof(PointerNode, next));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就能拿到调用的所有方法，包括main函数之前的方法。将函数保存成.order ，并在settings的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Order File&lt;/code&gt;中设置文件路径。再次编译查看link map就能看出，.order中的方法全部被编译在一起，减少缺页的发生。&lt;/p&gt;

&lt;h4 id=&quot;app启动后各个方法耗时&quot;&gt;app启动后各个方法耗时&lt;/h4&gt;

&lt;p&gt;OC中每个方法的调用最终都是会走到&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt;中，所以如果我们Hook了&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt;则能以最小改动计算每个方法的耗时。&lt;/p&gt;

&lt;p&gt;详细可见这篇介绍&lt;a href=&quot;https://juejin.im/post/6844904097338884104#heading-7&quot;&gt;iOS底层探索 - 通过objc_msgSend实现iOS方法耗时监控&lt;/a&gt;以及用到的fishhook的原理&lt;a href=&quot;https://juejin.im/post/6844904061557293069#heading-24&quot;&gt;iOS源码解析: 聊一聊iOS中的hook方案&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 24 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/iOS-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/iOS-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
