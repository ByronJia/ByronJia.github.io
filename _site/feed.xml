<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 10 Sep 2020 18:48:19 +0800</pubDate>
    <lastBuildDate>Thu, 10 Sep 2020 18:48:19 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>优秀程序员的九种素质</title>
        <description>&lt;h3 id=&quot;一&quot;&gt;一&lt;/h3&gt;

&lt;p&gt;上周看到一篇文章，大意是阿里云源代码泄露，涉及多少家企业云云，看起来耸人听闻，点进去发现是有企业在使用阿里云做代码托管的时候，private internal 和 public 傻傻分不清，创建仓库用了 internal，结果只要是登录用户都可以看到并 clone 这些代码。事实上，这三个设置不仅是惯例，internel 的注释也写的清清楚楚，但是挡不住程序员不看。你永远不知道一个人的水准会低到什么地步，也许这些人从来没用过 GitHub 和 GitLab 呢？&lt;/p&gt;

&lt;p&gt;阿里云其实可以采用安全最小化原则，也就是常说的多一事不如少一事。最小化可用原则，对于操作系统来说，就是装最小化的包，没用的服务不启动，操作命令最小化，权限最小化等等。对于阿里云上的托管用户来说，internal 应该是个可有可无的功能，去掉是不是更好呢，也许值得平台方思考。&lt;/p&gt;

&lt;p&gt;永远不要高估用户的聪明程度。&lt;/p&gt;

&lt;h3 id=&quot;二&quot;&gt;二&lt;/h3&gt;

&lt;p&gt;本周我们上线了一款基础课专栏《软件工程之美》，最新的文章中阐述了软件过程和软件危机：&lt;/p&gt;

&lt;p&gt;软件是怎么被创造出来的？&lt;/p&gt;

&lt;p&gt;首先，它们的诞生都是有人想要造一个东西。这其中的很多故事你都耳熟能详：张小龙创造微信、乔布斯创造 iOS、暴雪想做一款不一样的射击游戏……他们首先有着这样的意图，然后，他们立项做这样的产品。&lt;/p&gt;

&lt;p&gt;每一款软件项目背后，都有很多人在参与。你无法想象微信这样复杂的 App 靠张小龙自己可以开发出来；你也不会相信 iOS 是乔布斯一个人设计出来的；像守望先锋这种游戏的背后，有成百上千的游戏策划、美术设计、程序开发人员。&lt;/p&gt;

&lt;p&gt;从立项到第一个版本的发布，每个成功的软件都需要有计划、有步骤地进行，什么时候发布第一个版本、第一个版本有什么样的功能、什么时候发布第二个版本、第二个版本有哪些地方要改进，这些都是研发过程中需要考虑的问题。&lt;/p&gt;

&lt;p&gt;比如，守望先锋是在 2013 年立项，他们计划做一个基于职业的 MMO 游戏，他们先花了几个月的时间做了第一个 Demo 演示，只有四个英雄和一个张地图。&lt;/p&gt;

&lt;p&gt;然后，他们要在 2014 年的“暴雪嘉年华”发布这个游戏的试玩版，包含 12 个英雄和 4 张地图。&lt;/p&gt;

&lt;p&gt;最终这个游戏在 2016 年 5 月正式发布了。这样从立项一步步到最终发布，历时三年，中间经过了诸多环节。&lt;/p&gt;

&lt;p&gt;类似的例子还有微信，2010 年 11 月 20 日立项，2011 年 1 月 21 日第一版上线，当时的功能还非常简陋，只能发送文本消息和照片。之后才是一个个版本的迭代，直到你现在看到的微信。&lt;/p&gt;

&lt;p&gt;像这种有人参与、有计划、有步骤地造一件产品，我们通常称为「工程」。&lt;/p&gt;

&lt;p&gt;那什么是软件危机呢？有兴趣可以订阅专栏阅读。软件工程是你通向程序之巅的必经之路。&lt;/p&gt;

&lt;h3 id=&quot;三&quot;&gt;三&lt;/h3&gt;

&lt;p&gt;周末读村上的书，他说自己能够持续写作和跑步，就是因为具备两个特质，一个是集中力，一个是耐力。村上写长篇的时候每天早晨集中写作四小时，他一个人坐在书桌前，没有任何打扰，将意识集中倾斜在书稿中，其他什么都不考虑。另外，没有耐力也不行。你集中写了一星期然后伸伸懒腰说，我累了，然后就休息一个月，这样是写不成长篇的。你必须每天集中写作，坚持半年，一年，甚至更长才行。&lt;/p&gt;

&lt;p&gt;一个优秀的程序员需要什么特质呢？由此我想到之前读过的一篇文章，是 Redis 之父萨尔瓦托·桑菲利普（Salvatore Sanfilippo）写的 9 种高能程序员的特质，重新意译一下，推荐给读者：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、高效完成子任务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从处理编程子任务上，可以看出一个程序员的短板和长处，比如实现一个函数或者一个算法。事实上，擅于使用基本的编程技能来高效完成任务的程序员，并没有人们想象的那么多。有时候，团队里有些不称职的程序员，他们甚至不知道该怎么写一个简单的排序算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、合理使用自己的经验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;桑菲利普认为，经验就是一系列解决方案，它们已经被证实可以用于处理一些重复性的任务。经验老道的程序员知道该如何处理各种子任务，这样不但省掉了很多设计工作，而且避免了很多设计错误，而设计错误是简洁性最大的敌人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、准确预测工期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;花在编码上的时间不仅要看数量，也要看质量。造成注意力不集中的因素既有内部的，也有外部的。集中注意力和避免被打扰，对于提高编程效率来说是至关重要的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、设计权衡：用 5% 换取 90%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目的「非根本性」目标在很大程度上导致了设计的复杂性，或者导致无法达成其他更重要的目标，因为根本性功能和非根本性功能在设计上存在竞争关系。如果意识不到这点，复杂性就会随之而来。对于设计者来说，如果项目要最大化产出，就要把精力集中在重要的事情上，并在合理的时间内完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、简洁性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简洁性是成败之间最为明显的分界点，理解复杂性的产生过程有助于理解什么是简洁性。不愿意做出设计权衡和设计错误的累积是导致复杂性的两个主要因素。我在第一点里讲的 Internal 其实是提高了复杂度导致用户选择错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、拒绝完美主义（为了偏袒设计而放弃生产力）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;完美主义可以分为两种：一种是追求程序极致性能的工程文化，另一种是个人特质。不管是哪一种完美主义，它们都会对程序员实现快速交付造成阻碍。完美主义和对外部评判的恐惧会导致设计上的偏袒，程序员根据主观的心理因素和无关紧要的衡量参数做出设计决策，却忽略了健壮性、简洁性和及时交付。&lt;/p&gt;

&lt;p&gt;我曾经服务过的一家公司就犯了这种错误。当然，错误不止于此。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、理解知识理论的价值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在处理复杂任务时，具备一些理论方面的知识会对设计产生重要影响，比如数据结构方面的知识、了解计算能力的局限性和一些重要的算法。虽然程序员没有必要成为无所不知的超级专家，但是至少要知道一些问题的潜在解决方案，避免设计出复杂、缓慢、低内存效能的解决方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、理解机器原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序的很多问题都是源于对计算机工作原理的误解，即使是使用高级语言开发的程序也不外乎如此。这种情况可能导致一个项目需要重新设计和实现，因为项目所使用的工具和算法出现了根本性的错误。&lt;/p&gt;

&lt;p&gt;7 和 8 说的道理差不多，这也是极客时间会连续推出数学、算法、数据结构、网络协议、软件工程等课程的原因，后面还有架构设计、操作系统、编译原理等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、调试技能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;查找和解决 bug 经常会占用程序员大量的时间。查找引起 bug 的问题根源，在合理的步骤内修复 bug，以简单的方式编写包含较少 bug 的代码，对于程序员来说，做到这几点就可以显著提升效率。&lt;/p&gt;

&lt;p&gt;能否运用调试技能快速解决问题是衡量一个程序员水平的重要标准。&lt;/p&gt;

&lt;p&gt;你具备这些特质嘛？我觉得村上说的没错，程序员同时还需要集中力和耐力。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/</guid>
        
        <category>闲谈</category>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(四)</title>
        <description>&lt;h2 id=&quot;四framework层绘制&quot;&gt;四、Framework层绘制&lt;/h2&gt;
&lt;p&gt;在引擎层的处理过程会调用到window.onBeginFrame()和onDrawFrame，回到framework层从这个两个方法开始说起。&lt;/p&gt;

&lt;h3 id=&quot;41-schedulerbindinginitinstances&quot;&gt;4.1 SchedulerBinding.initInstances&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin SchedulerBinding on BindingBase, ServicesBinding {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    ui.window.onBeginFrame = _handleBeginFrame; //[见小节4.2]
    ui.window.onDrawFrame = _handleDrawFrame;  //[见小节4.4]
    SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可见，引擎层中的Window::BeginFrame()调用的两个方法，进入到dart层则分别是_handleBeginFrame()和_handleDrawFrame()方法&lt;/p&gt;

&lt;h4 id=&quot;411-window初始化&quot;&gt;4.1.1 Window初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Window {
    Window._()

    FrameCallback get onBeginFrame =&amp;gt; _onBeginFrame;
    FrameCallback _onBeginFrame;

    VoidCallback get onDrawFrame =&amp;gt; _onDrawFrame;
    VoidCallback _onDrawFrame;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Window初始化过程，可以知道onBeginFrame和onDrawFrame分别保存_onBeginFrame和_onDrawFrame方法。&lt;/p&gt;

&lt;h3 id=&quot;42-_handlebeginframe&quot;&gt;4.2 _handleBeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _handleBeginFrame(Duration rawTimeStamp) {
  if (_warmUpFrame) {
    _ignoreNextEngineDrawFrame = true;
    return;
  }
  handleBeginFrame(rawTimeStamp);  //[见小节4.3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;43-handlebeginframe&quot;&gt;4.3 handleBeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void handleBeginFrame(Duration rawTimeStamp) {
  Timeline.startSync('Frame', arguments: timelineWhitelistArguments);
  _firstRawTimeStampInEpoch ??= rawTimeStamp;
  _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp);
  if (rawTimeStamp != null)
    _lastRawTimeStamp = rawTimeStamp;

  profile(() {
    _profileFrameNumber += 1;
    _profileFrameStopwatch.reset();
    _profileFrameStopwatch.start();
  });

  //此时阶段等于SchedulerPhase.idle;
  _hasScheduledFrame = false;
  try {
    Timeline.startSync('Animate', arguments: timelineWhitelistArguments);
    _schedulerPhase = SchedulerPhase.transientCallbacks;
    //执行动画的回调方法
    final Map&amp;lt;int, _FrameCallbackEntry&amp;gt; callbacks = _transientCallbacks;
    _transientCallbacks = &amp;lt;int, _FrameCallbackEntry&amp;gt;{};
    callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) {
      if (!_removedIds.contains(id))
        _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);
    });
    _removedIds.clear();
  } finally {
    _schedulerPhase = SchedulerPhase.midFrameMicrotasks;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作，可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员，再来简单看看这两个方法。&lt;/p&gt;

&lt;h4 id=&quot;431-scheduleframecallback&quot;&gt;4.3.1 scheduleFrameCallback&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int scheduleFrameCallback(FrameCallback callback, { bool rescheduling = false }) {
  scheduleFrame();  //触发帧绘制的调度
  _nextFrameCallbackId += 1;
  _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling);
  return _nextFrameCallbackId;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;callback保存在_FrameCallbackEntry对象里面&lt;/p&gt;

&lt;h4 id=&quot;432-cancelframecallbackwithid&quot;&gt;4.3.2 cancelFrameCallbackWithId&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void cancelFrameCallbackWithId(int id) {
  assert(id &amp;gt; 0);
  _transientCallbacks.remove(id);
  _removedIds.add(id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;44-_handledrawframe&quot;&gt;4.4 _handleDrawFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _handleDrawFrame() {
  if (_ignoreNextEngineDrawFrame) {
    _ignoreNextEngineDrawFrame = false;
    return;
  }
  handleDrawFrame();  //[见小节4.5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;45-handledrawframe&quot;&gt;4.5 handleDrawFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void handleDrawFrame() {
  assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);
  Timeline.finishSync(); // 标识结束&quot;Animate&quot;阶段
  try {
    _schedulerPhase = SchedulerPhase.persistentCallbacks;
    //执行PERSISTENT FRAME回调
    for (FrameCallback callback in _persistentCallbacks)
      _invokeFrameCallback(callback, _currentFrameTimeStamp); //[见小节4.5.1]

    _schedulerPhase = SchedulerPhase.postFrameCallbacks;
    // 执行POST-FRAME回调
    final List&amp;lt;FrameCallback&amp;gt; localPostFrameCallbacks = List&amp;lt;FrameCallback&amp;gt;.from(_postFrameCallbacks);
    _postFrameCallbacks.clear();
    for (FrameCallback callback in localPostFrameCallbacks)
      _invokeFrameCallback(callback, _currentFrameTimeStamp);
  } finally {
    _schedulerPhase = SchedulerPhase.idle;
    Timeline.finishSync(); //标识结束”Frame“阶段
    profile(() {
      _profileFrameStopwatch.stop();
      _profileFramePostEvent();
    });
    _currentFrameTimeStamp = null;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行；&lt;/li&gt;
  &lt;li&gt;遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;451-_invokeframecallback&quot;&gt;4.5.1 _invokeFrameCallback&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _invokeFrameCallback(FrameCallback callback, Duration timeStamp, [ StackTrace callbackStack ]) {
  try {
    callback(timeStamp);  //[见小节4.5.2]
  } catch (exception, exceptionStack) {
    FlutterError.reportError(FlutterErrorDetails(...));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的callback是_persistentCallbacks列表中的成员，再来看看其成员是如何添加进去的。&lt;/p&gt;

&lt;h4 id=&quot;452-widgetsbindinginitinstances&quot;&gt;4.5.2 WidgetsBinding.initInstances&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding {
  @override
  void initInstances() {
    super.initInstances();  //[见小节4.5.3]
    _instance = this;
    buildOwner.onBuildScheduled = _handleBuildScheduled;
    ui.window.onLocaleChanged = handleLocaleChanged;
    ui.window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;
    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);
    SystemChannels.system.setMessageHandler(_handleSystemMessage);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在flutter app启动过程，也就是执行runApp过程会有WidgetsFlutterBinding初始化过程，WidgetsBinding的initInstances()，根据mixin的顺序，可知此处的super.initInstances() 便是RendererBinding类。&lt;/p&gt;

&lt;h4 id=&quot;453-rendererbindinginitinstances&quot;&gt;4.5.3 RendererBinding.initInstances&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, SemanticsBinding, HitTestable {

  void initInstances() {
    super.initInstances();
    _instance = this;
    _pipelineOwner = PipelineOwner(
      onNeedVisualUpdate: ensureVisualUpdate,
      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,
      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,
    );
    ui.window
      ..onMetricsChanged = handleMetricsChanged
      ..onTextScaleFactorChanged = handleTextScaleFactorChanged
      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged
      ..onSemanticsAction = _handleSemanticsAction;
    initRenderView();
    _handleSemanticsEnabledChanged();
    addPersistentFrameCallback(_handlePersistentFrameCallback); //[见小节4.5.4]
  }

  void _handlePersistentFrameCallback(Duration timeStamp) {
    drawFrame();  //[见小节4.6]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;454-schedulerbindingaddpersistentframecallback&quot;&gt;4.5.4 SchedulerBinding.addPersistentFrameCallback&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin SchedulerBinding on BindingBase, ServicesBinding {

  void addPersistentFrameCallback(FrameCallback callback) {
    _persistentCallbacks.add(callback);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;46-widgetsbindingdrawframe&quot;&gt;4.6 WidgetsBinding.drawFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void drawFrame() {
  try {
    if (renderViewElement != null)
      buildOwner.buildScope(renderViewElement);   //[见小节4.6.1]
    super.drawFrame();   //[见小节4.6.4]
    buildOwner.finalizeTree();  //[见小节4.12]
  } finally {
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;461-buildownerbuildscope&quot;&gt;4.6.1 BuildOwner.buildScope&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void buildScope(Element context, [VoidCallback callback]) {
  if (callback == null &amp;amp;&amp;amp; _dirtyElements.isEmpty)
    return;
  Timeline.startSync('Build', arguments: timelineWhitelistArguments);
  try {
    _scheduledFlushDirtyElements = true;
    if (callback != null) {
      _dirtyElementsNeedsResorting = false;
      callback();  //执行回调方法
    }
    _dirtyElements.sort(Element._sort); //排序
    _dirtyElementsNeedsResorting = false;
    int dirtyCount = _dirtyElements.length;
    int index = 0;
    while (index &amp;lt; dirtyCount) {
      try {
        //具体Element子类执行重建操作 [见小节4.6.2]
        _dirtyElements[index].rebuild();
      } catch (e, stack) {
      }
      index += 1;
      if (dirtyCount &amp;lt; _dirtyElements.length || _dirtyElementsNeedsResorting) {
        _dirtyElements.sort(Element._sort);
        _dirtyElementsNeedsResorting = false;
        dirtyCount = _dirtyElements.length;
        while (index &amp;gt; 0 &amp;amp;&amp;amp; _dirtyElements[index - 1].dirty) {
          index -= 1;
        }
      }
    }
  } finally {
    for (Element element in _dirtyElements) {
      element._inDirtyList = false;
    }
    _dirtyElements.clear();
    _scheduledFlushDirtyElements = false;
    _dirtyElementsNeedsResorting = null;
    Timeline.finishSync();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;462-elementrebuild&quot;&gt;4.6.2 Element.rebuild&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void rebuild() {
  if (!_active || !_dirty)
    return;
  performRebuild();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;performRebuild具体执行方法，取决于相应的Element子类，这里以ComponentElement为例&lt;/p&gt;

&lt;h4 id=&quot;463-componentelementperformrebuild&quot;&gt;4.6.3 ComponentElement.performRebuild&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performRebuild() {
  Widget built;
  try {
    built = build();  //执行build方法
  } catch (e, stack) {
    built = ErrorWidget.builder(_debugReportException('building $this', e, stack));
  } finally {
    _dirty = false;
  }
  try {
    _child = updateChild(_child, built, slot); //更新子元素
  } catch (e, stack) {
    built = ErrorWidget.builder(_debugReportException('building $this', e, stack));
    _child = updateChild(null, built, slot);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;464-rendererbindingdrawframe&quot;&gt;4.6.4 RendererBinding.drawFrame&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void drawFrame() {
  pipelineOwner.flushLayout();  //[见小节4.7]
  pipelineOwner.flushCompositingBits();  //[见小节4.8]
  pipelineOwner.flushPaint(); //[见小节4.9]
  renderView.compositeFrame();  //[见小节4.10]
  pipelineOwner.flushSemantics(); //[见小节4.11]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RendererBinding的initInstances()过程注册了一个Persistent的帧回调方法_handlePersistentFrameCallback()，故handleDrawFrame()过程会调用该方法。pipelineOwner管理渲染管道，提供了一个用于驱动渲染管道的接口，并存储了哪些渲染对象请求访问状态，要刷新管道，需要按顺序运行如下5个阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[flushLayout]：更新需要计算其布局的渲染对象，在此阶段计算每个渲染对象的大小和位置，渲染对象可能会弄脏其绘画或者合成状态，这个过程可能还会调用到build过程。
耗时对应timeline的‘Layout’过程&lt;/li&gt;
  &lt;li&gt;[flushCompositingBits]：更新具有脏合成位的任何渲染对象，在此阶段每个渲染对象都会了解其子项是否需要合成。在绘制阶段使用此信息选择如何实现裁剪等视觉效果。如果渲染对象有一个自己合成的子项，它需要使用布局信息来创建裁剪，以便将裁剪应用于已合成的子项
耗时对应timeline的‘Compositing bits’过程&lt;/li&gt;
  &lt;li&gt;[flushPaint]：访问需要绘制的任何渲染对象，在此阶段，渲染对象有机会将绘制命令记录到[PictureLayer]，并构建其他合成的[Layer]；
    &lt;ul&gt;
      &lt;li&gt;耗时对应timeline的‘Paint’过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[compositeFrame]：将Compositing bits发送给GPU；
    &lt;ul&gt;
      &lt;li&gt;耗时对应timeline的‘Compositing’过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[flushSemantics]：编译渲染对象的语义，并将语义发送给操作系统；
    &lt;ul&gt;
      &lt;li&gt;耗时对应timeline的‘Semantics’过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;packages/flutter/lib/src/rendering/debug.dart，这里面记录着关于render过程相关的调试开关，可以逐一实践。&lt;/p&gt;

&lt;h3 id=&quot;47-pipelineownerflushlayout&quot;&gt;4.7 PipelineOwner.flushLayout&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushLayout() {
  profile(() {
    Timeline.startSync('Layout', arguments: timelineWhitelistArguments);
  });
  try {
    //遍历所有的渲染对象
    while (_nodesNeedingLayout.isNotEmpty) {
      final List&amp;lt;RenderObject&amp;gt; dirtyNodes = _nodesNeedingLayout;
      _nodesNeedingLayout = &amp;lt;RenderObject&amp;gt;[];
      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&amp;gt; a.depth - b.depth)) {
        //如果渲染对象需要重新布局，则执行布局操作 [见小节4.7.1]
        if (node._needsLayout &amp;amp;&amp;amp; node.owner == this)
          node._layoutWithoutResize();
      }
    }
  } finally {
    profile(() {
      Timeline.finishSync();
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;471-_layoutwithoutresize&quot;&gt;4.7.1 _layoutWithoutResize&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _layoutWithoutResize() {
  try {
    performLayout();  //执行布局操作[]
    markNeedsSemanticsUpdate();  //[见小节4.7.2]
  } catch (e, stack) {
    _debugReportException('performLayout', e, stack);
  }
  _needsLayout = false; //完成layout操作
  markNeedsPaint(); // [见小节4.7.3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;performLayout操作：参数sizedByParent为false需要同时改变渲染对象和指导子项的布局，性能更慢；&lt;/li&gt;
  &lt;li&gt;markNeedsSemanticsUpdate：标记需要更新语义；&lt;/li&gt;
  &lt;li&gt;markNeedsPaint：标记需要绘制；&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SchedulerBinding.scheduleWarmUpFrame
  RenderView.performLayout
    RenderObject.layout
      _RenderLayoutBuilder.performLayout
        _LayoutBuilderElement._layout
          BuildOwner.buildScope
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;472-markneedssemanticsupdate&quot;&gt;4.7.2 markNeedsSemanticsUpdate&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void markNeedsSemanticsUpdate() {
  if (!attached || owner._semanticsOwner == null) {
    _cachedSemanticsConfiguration = null;
    return;
  }

  final bool wasSemanticsBoundary = _semantics != null &amp;amp;&amp;amp; _cachedSemanticsConfiguration?.isSemanticBoundary == true;
  _cachedSemanticsConfiguration = null;
  bool isEffectiveSemanticsBoundary = _semanticsConfiguration.isSemanticBoundary &amp;amp;&amp;amp; wasSemanticsBoundary;
  RenderObject node = this;

  while (!isEffectiveSemanticsBoundary &amp;amp;&amp;amp; node.parent is RenderObject) {
    if (node != this &amp;amp;&amp;amp; node._needsSemanticsUpdate)
      break;
    node._needsSemanticsUpdate = true;

    node = node.parent;
    isEffectiveSemanticsBoundary = node._semanticsConfiguration.isSemanticBoundary;
    if (isEffectiveSemanticsBoundary &amp;amp;&amp;amp; node._semantics == null) {
      return;
    }
  }
  if (node != this &amp;amp;&amp;amp; _semantics != null &amp;amp;&amp;amp; _needsSemanticsUpdate) {
    owner._nodesNeedingSemantics.remove(this);
  }
  if (!node._needsSemanticsUpdate) {
    node._needsSemanticsUpdate = true;
    if (owner != null) {
      //记录需要更新语义的渲染对象
      owner._nodesNeedingSemantics.add(node);
      owner.requestVisualUpdate();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;473-markneedspaint&quot;&gt;4.7.3 markNeedsPaint&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void markNeedsPaint() {
  if (_needsPaint)
    return;
  _needsPaint = true;
  if (isRepaintBoundary) {
    if (owner != null) {
      //记录需要重新绘制的渲染对象
      owner._nodesNeedingPaint.add(this);
      owner.requestVisualUpdate();
    }
  } else if (parent is RenderObject) {
    final RenderObject parent = this.parent;
    parent.markNeedsPaint();
  } else {
    if (owner != null)
      owner.requestVisualUpdate();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;48-pipelineownerflushcompositingbits&quot;&gt;4.8 PipelineOwner.flushCompositingBits&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushCompositingBits() {
  profile(() { Timeline.startSync('Compositing bits'); });
  _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&amp;gt; a.depth - b.depth);
  for (RenderObject node in _nodesNeedingCompositingBitsUpdate) {
    //根据需要来决定是否更新位合成
    if (node._needsCompositingBitsUpdate &amp;amp;&amp;amp; node.owner == this)
      node._updateCompositingBits(); // [见小节4.8.1]
  }
  _nodesNeedingCompositingBitsUpdate.clear();  //清空需要位合成的渲染对象
  profile(() { Timeline.finishSync(); });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;481-_updatecompositingbits&quot;&gt;4.8.1 _updateCompositingBits&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _updateCompositingBits() {
  if (!_needsCompositingBitsUpdate)
    return;
  final bool oldNeedsCompositing = _needsCompositing;
  _needsCompositing = false;
  visitChildren((RenderObject child) {
    //遍历所有子项来更新位合成
    child._updateCompositingBits();
    if (child.needsCompositing)
      _needsCompositing = true;
  });
  if (isRepaintBoundary || alwaysNeedsCompositing)
    _needsCompositing = true;
  if (oldNeedsCompositing != _needsCompositing)
    markNeedsPaint();
  _needsCompositingBitsUpdate = false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;49-pipelineownerflushpaint&quot;&gt;4.9 PipelineOwner.flushPaint&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushPaint() {
  profile(() { Timeline.startSync('Paint', arguments: timelineWhitelistArguments); });
  try {
    final List&amp;lt;RenderObject&amp;gt; dirtyNodes = _nodesNeedingPaint;
    _nodesNeedingPaint = &amp;lt;RenderObject&amp;gt;[];
    //排序脏节点，深度最大的节点排第一位
    for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&amp;gt; b.depth - a.depth)) {
      if (node._needsPaint &amp;amp;&amp;amp; node.owner == this) {
        //此节点是否连接到树中，如果连接则重绘，否则跳过
        if (node._layer.attached) {
          PaintingContext.repaintCompositedChild(node);  //[小节4.9.1]
        } else {
          node._skippedPaintingOnLayer();
        }
      }
    }
  } finally {
    profile(() { Timeline.finishSync(); });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;491-repaintcompositedchild&quot;&gt;4.9.1 repaintCompositedChild&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void repaintCompositedChild(RenderObject child, { bool debugAlsoPaintedParent = false }) {
  _repaintCompositedChild(
    child,
    debugAlsoPaintedParent: debugAlsoPaintedParent,
  );
}

static void _repaintCompositedChild(
  RenderObject child, {
  bool debugAlsoPaintedParent = false,
  PaintingContext childContext,
}) {
  if (child._layer == null) {
    child._layer = OffsetLayer();
  } else {
    child._layer.removeAllChildren();
  }
  childContext ??= PaintingContext(child._layer, child.paintBounds);
  child._paintWithContext(childContext, Offset.zero);
  childContext.stopRecordingIfNeeded();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;410-renderviewcompositeframe&quot;&gt;4.10 RenderView.compositeFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/view.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void compositeFrame() {
  Timeline.startSync('Compositing', arguments: timelineWhitelistArguments);
  try {
    //创建SceneBuilder [见小节4.10.1]
    final ui.SceneBuilder builder = ui.SceneBuilder();
    //创建Scene [见小节4.10.2]
    final ui.Scene scene = layer.buildScene(builder);
    if (automaticSystemUiAdjustment)
      _updateSystemChrome();
    ui.window.render(scene); // [见小节4.10.3]
    scene.dispose();
  } finally {
    Timeline.finishSync();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分别创建Flutter框架(dart)和引擎层(C++)的两个SceneBuilder；&lt;/li&gt;
  &lt;li&gt;分别创建Flutter框架(dart)和引擎层(C++)的两个Scene；&lt;/li&gt;
  &lt;li&gt;执行render()将layer树发送给GPU线程；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4101-scenebuilder初始化&quot;&gt;4.10.1 SceneBuilder初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/ui/compositing.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SceneBuilder extends NativeFieldWrapperClass2 {
  @pragma('vm:entry-point')
  SceneBuilder() { _constructor(); }
  void _constructor() native 'SceneBuilder_constructor';
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;SceneBuilder_constructor这是native方法，最终调用到引擎中的lib/ui/compositing/scene_builder.h中的SceneBuilder::create()方法， 创建C++的SceneBuilder对象。&lt;/p&gt;

&lt;h4 id=&quot;4102-offsetlayerbuildscene&quot;&gt;4.10.2 OffsetLayer.buildScene&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/layer.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ui.Scene buildScene(ui.SceneBuilder builder) {
  updateSubtreeNeedsAddToScene();  //遍历layer树，将需要子树加入到scene
  addToScene(builder); //将layer添加到SceneBuilder
  return builder.build(); //调用C++层的build来构建Scene对象。
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;遍历layer树，将需要更新的全部都加入到SceneBuilder。再调用build()，同样也是native方法，执行SceneBuilder::build()来构建Scene对象。&lt;/p&gt;

&lt;h4 id=&quot;4103-windowrender&quot;&gt;4.10.3 Window::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window/window.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Render(Dart_NativeArguments args) {
  Dart_Handle exception = nullptr;
  Scene* scene = tonic::DartConverter&amp;lt;Scene*&amp;gt;::FromArguments(args, 1, exception);
  if (exception) {
    Dart_ThrowException(exception);
    return;
  }
  UIDartState::Current()-&amp;gt;window()-&amp;gt;client()-&amp;gt;Render(scene);  // [4.10.4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ui.window.render()位于window.dart文件，这是一个native方法，会调用到window.cc的Render()方法。&lt;/p&gt;

&lt;h4 id=&quot;4104-runtimecontrollerrender&quot;&gt;4.10.4 RuntimeController::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/runtime/runtime_controller.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RuntimeController::Render(Scene* scene) {
  //从scene中取出layer树 [见小节4.10.5]
  client_.Render(scene-&amp;gt;takeLayerTree());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4105-enginerender&quot;&gt;4.10.5 Engine::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::Render(std::unique_ptr&amp;lt;flow::LayerTree&amp;gt; layer_tree) {
  if (!layer_tree)
    return;

  SkISize frame_size = SkISize::Make(viewport_metrics_.physical_width,
                                     viewport_metrics_.physical_height);
  if (frame_size.isEmpty())
    return;

  layer_tree-&amp;gt;set_frame_size(frame_size);
  animator_-&amp;gt;Render(std::move(layer_tree));  // [4.10.6]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4106-animatorrender&quot;&gt;4.10.6 Animator::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::Render(std::unique_ptr&amp;lt;flow::LayerTree&amp;gt; layer_tree) {
  if (dimension_change_pending_ &amp;amp;&amp;amp;
      layer_tree-&amp;gt;frame_size() != last_layer_tree_size_) {
    dimension_change_pending_ = false;
  }
  last_layer_tree_size_ = layer_tree-&amp;gt;frame_size();

  if (layer_tree) {
    layer_tree-&amp;gt;set_construction_time(fml::TimePoint::Now() -
                                      last_begin_frame_time_);
  }

  //提交待处理的continuation，本次PipelineProduce完成 //[见小节4.10.7]
  producer_continuation_.Complete(std::move(layer_tree));

  delegate_.OnAnimatorDraw(layer_tree_pipeline_); //[见小节4.10.8]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;UI线程的耗时从doFrame(frameTimeNanos)中的frameTimeNanos为起点，以Animator::Render()方法结束为终点， 并将结果保存到LayerTree的成员变量construction_time_，这便是UI线程的耗时时长。&lt;/p&gt;

&lt;h4 id=&quot;4107-producercontinuationcomplete&quot;&gt;4.10.7 ProducerContinuation.Complete&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/synchronization/pipeline.h]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ProducerContinuation {
  void Complete(ResourcePtr resource) {
    if (continuation_) {
      continuation_(std::move(resource), trace_id_);
      continuation_ = nullptr;
      TRACE_EVENT_ASYNC_END0(&quot;flutter&quot;, &quot;PipelineProduce&quot;, trace_id_);
      TRACE_FLOW_STEP(&quot;flutter&quot;, &quot;PipelineItem&quot;, trace_id_);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4108-shellonanimatordraw&quot;&gt;4.10.8 Shell::OnAnimatorDraw&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/shell.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnAnimatorDraw(
    fml::RefPtr&amp;lt;flutter::Pipeline&amp;lt;flow::LayerTree&amp;gt;&amp;gt; pipeline) {

  //向GPU线程提交绘制任务
  task_runners_.GetGPUTaskRunner()-&amp;gt;PostTask(
      [rasterizer = rasterizer_-&amp;gt;GetWeakPtr(),
       pipeline = std::move(pipeline)]() {
        if (rasterizer) {
          //由GPU线程来负责栅格化操作
          rasterizer-&amp;gt;Draw(pipeline);
        }
      });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个方法主要是向GPU线程提交绘制任务。&lt;/p&gt;

&lt;h3 id=&quot;411-pipelineownerflushsemantics&quot;&gt;4.11 PipelineOwner.flushSemantics&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/view.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushSemantics() {
  if (_semanticsOwner == null)
    return;
  profile(() { Timeline.startSync('Semantics'); });
  try {
    final List&amp;lt;RenderObject&amp;gt; nodesToProcess = _nodesNeedingSemantics.toList()
      ..sort((RenderObject a, RenderObject b) =&amp;gt; a.depth - b.depth);
    _nodesNeedingSemantics.clear();
    //遍历_nodesNeedingSemantics，更新需要更新语义的渲染对象
    for (RenderObject node in nodesToProcess) {
      if (node._needsSemanticsUpdate &amp;amp;&amp;amp; node.owner == this)
        node._updateSemantics(); // [见小节4.11.1]
    }
    _semanticsOwner.sendSemanticsUpdate(); // 发送语义更新[见小节4.11.2]
  } finally {
    profile(() { Timeline.finishSync(); });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4111-_updatesemantics&quot;&gt;4.11.1 _updateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _updateSemantics() {
  if (_needsLayout) {
    //此子树中没有足够的信息来计算语义，子树可能被视图窗口保持活着但没有布局
    return;
  }
  final _SemanticsFragment fragment = _getSemanticsForParent(
    mergeIntoParent: _semantics?.parent?.isPartOfNodeMerging ?? false,
  );
  final _InterestingSemanticsFragment interestingFragment = fragment;
  final SemanticsNode node = interestingFragment.compileChildren(
    parentSemanticsClipRect: _semantics?.parentSemanticsClipRect,
    parentPaintClipRect: _semantics?.parentPaintClipRect,
  ).single;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4112-sendsemanticsupdate&quot;&gt;4.11.2 sendSemanticsUpdate&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/semantics/semantics.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void sendSemanticsUpdate() {
  if (_dirtyNodes.isEmpty)
    return;
  final Set&amp;lt;int&amp;gt; customSemanticsActionIds = Set&amp;lt;int&amp;gt;();
  final List&amp;lt;SemanticsNode&amp;gt; visitedNodes = &amp;lt;SemanticsNode&amp;gt;[];
  while (_dirtyNodes.isNotEmpty) {
    final List&amp;lt;SemanticsNode&amp;gt; localDirtyNodes = _dirtyNodes.where((SemanticsNode node) =&amp;gt; !_detachedNodes.contains(node)).toList();
    _dirtyNodes.clear();
    _detachedNodes.clear();
    localDirtyNodes.sort((SemanticsNode a, SemanticsNode b) =&amp;gt; a.depth - b.depth);
    visitedNodes.addAll(localDirtyNodes);
    for (SemanticsNode node in localDirtyNodes) {
      if (node.isPartOfNodeMerging) {
        //如果合并到父节点，确保父节点已被添加到脏列表
        if (node.parent != null &amp;amp;&amp;amp; node.parent.isPartOfNodeMerging)
          node.parent._markDirty(); //将节点添加到脏列表
      }
    }
  }
  visitedNodes.sort((SemanticsNode a, SemanticsNode b) =&amp;gt; a.depth - b.depth);
  final ui.SemanticsUpdateBuilder builder = ui.SemanticsUpdateBuilder();
  for (SemanticsNode node in visitedNodes) {
    if (node._dirty &amp;amp;&amp;amp; node.attached)
      node._addToUpdate(builder, customSemanticsActionIds);
  }
  _dirtyNodes.clear();
  for (int actionId in customSemanticsActionIds) {
    final CustomSemanticsAction action = CustomSemanticsAction.getAction(actionId);
    builder.updateCustomAction(id: actionId, label: action.label, hint: action.hint, overrideId: action.action?.index ?? -1);
  }
  ui.window.updateSemantics(builder.build());  // [见小节4.11.3]
  notifyListeners(); //通知已注册的监听器
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看看监听器的数据，是否影响性能。&lt;/p&gt;

&lt;p&gt;updateSemantics这是window.dart中的一个native方法，调用到如下方法。&lt;/p&gt;

&lt;h4 id=&quot;4113-windowupdatesemantics&quot;&gt;4.11.3 Window::updateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window/window.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void UpdateSemantics(Dart_NativeArguments args) {
  Dart_Handle exception = nullptr;
  SemanticsUpdate* update =
      tonic::DartConverter&amp;lt;SemanticsUpdate*&amp;gt;::FromArguments(args, 1, exception);
  if (exception) {
    Dart_ThrowException(exception);
    return;
  }
  UIDartState::Current()-&amp;gt;window()-&amp;gt;client()-&amp;gt;UpdateSemantics(update); // [见小节4.11.4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4114-runtimecontrollerupdatesemantics&quot;&gt;4.11.4 RuntimeController::UpdateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/runtime/runtime_controller.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RuntimeController::UpdateSemantics(SemanticsUpdate* update) {
  if (window_data_.semantics_enabled) {
    client_.UpdateSemantics(update-&amp;gt;takeNodes(), update-&amp;gt;takeActions()); // [见小节4.11.5]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4115-engineupdatesemantics&quot;&gt;4.11.5 Engine::UpdateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::UpdateSemantics(blink::SemanticsNodeUpdates update,
                             blink::CustomAccessibilityActionUpdates actions) {
  delegate_.OnEngineUpdateSemantics(std::move(update), std::move(actions)); // [见小节4.11.6]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4116-shellonanimatordraw&quot;&gt;4.11.6 Shell::OnAnimatorDraw&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/shell.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnEngineUpdateSemantics(
    blink::SemanticsNodeUpdates update,
    blink::CustomAccessibilityActionUpdates actions) {

  task_runners_.GetPlatformTaskRunner()-&amp;gt;PostTask(
      [view = platform_view_-&amp;gt;GetWeakPtr(), update = std::move(update),
       actions = std::move(actions)] {
        if (view) {
          view-&amp;gt;UpdateSemantics(std::move(update), std::move(actions));
        }
      });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个方法主要是向平台线程提交Semantic任务。&lt;/p&gt;

&lt;p&gt;再回到小节4.6，可知接下来再执行finalizeTree()操作；&lt;/p&gt;

&lt;h3 id=&quot;412-buildownerfinalizetree&quot;&gt;4.12 BuildOwner.finalizeTree&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void finalizeTree() {
  Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments);
  try {
    lockState(() {
      //遍历所有的Element，执行unmount()动作，且取消GlobalKeys的注册
      _inactiveElements._unmountAll();
    });
  } catch (e, stack) {
    _debugReportException('while finalizing the widget tree', e, stack);
  } finally {
    Timeline.finishSync();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;遍历所有的Element，执行相应具体Element子类的unmount()操作，下面以常见的StatefulElement为例来说明。&lt;/p&gt;

&lt;h4 id=&quot;4121-statefulelementunmount&quot;&gt;4.12.1 StatefulElement.unmount&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void unmount() {
  super.unmount(); //[见小节4.12.2]
  _state.dispose(); //执行State的dispose()方法
  _state._element = null;
  _state = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4122-elementunmount&quot;&gt;4.12.2 Element.unmount&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void unmount() {
  if (widget.key is GlobalKey) {
    final GlobalKey key = widget.key;
    key._unregister(this);  //取消GlobalKey的注册
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;本文涉及到相关源码文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flutter/shell/common/
    - vsync_waiter.cc
    - engine.cc
    - animator.cc
    - shell.cc
    - rasterizer.cc

flutter/shell/platform/android/
    - vsync_waiter_android.cc
    - platform_view_android_jni.cc
    - library_loader.cc
    - io/flutter/view/VsyncWaiter.java

flutter/runtime/runtime_controller.cc
flutter/synchronization/pipeline.h
flutter/fml/message_loop_impl.cc
flutter/lib/ui/window/window.cc
flutter/lib/ui/window.dart
flutter/lib/ui/hooks.dart

lib/src/widgets/framework.dart
lib/src/widgets/binding.dart
lib/src/scheduler/binding.dart
lib/src/semantics/semantics.dart

lib/src/rendering/
    - binding.dart
    - object.dart
    - view.dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 25 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E5%9B%9B)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E5%9B%9B)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(三)</title>
        <description>&lt;h2 id=&quot;三engine层绘制&quot;&gt;三、Engine层绘制&lt;/h2&gt;
&lt;h3 id=&quot;31-doframe&quot;&gt;3.1 doFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; Choreographer.java]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void doFrame(long frameTimeNanos) {
    //Android FW每次当vsync信号触发，则会调用该方法 [见下方]
    nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vsync注册过程见[小节2.6] Choreographer.FrameCallback()。注册了Vysnc信号后，一旦底层Vsync信号触发，经过层层调用回到FrameDisplayEventReceiver的过程，然后会有一个通过handler的方式post到线程”FlutterVsyncThread”来执行操作， 具体流程见Choreographer原理。紧接着再处理所有注册的doCallbacks方法，则会执行Choreographer.FrameCallback中的doFrame()方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Choreographer.FrameCallback() {
    @Override
    public void doFrame(long frameTimeNanos) {
        //frameTimeNanos是VYSNC触发的时间点，也就是计划绘制的时间点 [见小节3.2]
        nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-onnativevsync&quot;&gt;3.2 OnNativeVsync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/io/flutter/view/VsyncWaiter.java]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class VsyncWaiter {
    ...
    // [见小节3.2.1]
    private static native void nativeOnVsync(long frameTimeNanos,
                                             long frameTargetTimeNanos,
                                             long cookie);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由[小节2.5.3]可知，VsyncWaiter.java中的nativeOnVsync对应于vsync_waiter_android.cc的OnNativeVsync()，具体过程在jni加载过程初始化，如下所示。&lt;/p&gt;

&lt;h4 id=&quot;321-onnativevsyncc&quot;&gt;3.2.1 OnNativeVsync[C++]&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void OnNativeVsync(JNIEnv* env, jclass jcaller,
                          jlong frameTimeNanos,
                          jlong frameTargetTimeNanos,
                          jlong java_baton) {
  auto frame_time = fml::TimePoint::FromEpochDelta(
      fml::TimeDelta::FromNanoseconds(frameTimeNanos));
  auto target_time = fml::TimePoint::FromEpochDelta(
      fml::TimeDelta::FromNanoseconds(frameTargetTimeNanos));
  //消费pending回调[见小节3.3]
  ConsumePendingCallback(java_baton, frame_time, target_time);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;33-consumependingcallback&quot;&gt;3.3 ConsumePendingCallback&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void ConsumePendingCallback(jlong java_baton,
                                   fml::TimePoint frame_start_time,
                                   fml::TimePoint frame_target_time) {
  auto* weak_this = reinterpret_cast&amp;lt;std::weak_ptr&amp;lt;VsyncWaiter&amp;gt;*&amp;gt;(java_baton);
  auto shared_this = weak_this-&amp;gt;lock();
  delete weak_this;

  if (shared_this) {
    //shared_this指向VsyncWaiter的弱引用 [见小节3.4]
    shared_this-&amp;gt;FireCallback(frame_start_time, frame_target_time);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;34-vsyncwaiterfirecallback&quot;&gt;3.4 VsyncWaiter::FireCallback&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/vsync_waiter.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void VsyncWaiter::FireCallback(fml::TimePoint frame_start_time,
                               fml::TimePoint frame_target_time) {
  Callback callback;
  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(callback_mutex_);
    callback = std::move(callback_);
  }
  if (!callback) {
    TRACE_EVENT_INSTANT0(&quot;flutter&quot;, &quot;MismatchedFrameCallback&quot;);
    return;
  }

  TRACE_EVENT0(&quot;flutter&quot;, &quot;VsyncFireCallback&quot;);
  //将任务放入task队列[见小节3.4.1]
  task_runners_.GetUITaskRunner()-&amp;gt;PostTaskForTime(
    [callback, flow_identifier, frame_start_time, frame_target_time]() {
      FML_TRACE_EVENT(&quot;flutter&quot;, kVsyncTraceName, &quot;StartTime&quot;,
                      frame_start_time, &quot;TargetTime&quot;, frame_target_time);
      fml::tracing::TraceEventAsyncComplete(
          &quot;flutter&quot;, &quot;VsyncSchedulingOverhead&quot;, fml::TimePoint::Now(),
          frame_start_time);
      //开始执行vync [见小节3.5]
      callback(frame_start_time, frame_target_time);
      TRACE_FLOW_END(&quot;flutter&quot;, kVsyncFlowName, flow_identifier);
    },
    frame_start_time);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将任务闭包放入task队列，消息Loop一旦接受到消息则会读取出来。&lt;/p&gt;

&lt;h4 id=&quot;341-messageloopimplrunexpiredtasks&quot;&gt;3.4.1 MessageLoopImpl::RunExpiredTasks&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/fml/message_loop_impl.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void MessageLoopImpl::RunExpiredTasks() {
  TRACE_EVENT0(&quot;fml&quot;, &quot;MessageLoop::RunExpiredTasks&quot;);
  std::vector&amp;lt;fml::closure&amp;gt; invocations;

  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(delayed_tasks_mutex_);
    //当没有待处理的task则直接返回
    if (delayed_tasks_.empty()) {
      return;
    }

    auto now = fml::TimePoint::Now();
    while (!delayed_tasks_.empty()) {
      const auto&amp;amp; top = delayed_tasks_.top();
      if (top.target_time &amp;gt; now) {
        break;
      }
      invocations.emplace_back(std::move(top.task));
      delayed_tasks_.pop();
    }
    WakeUp(delayed_tasks_.empty() ? fml::TimePoint::Max()
                                  : delayed_tasks_.top().target_time);
  }

  for (const auto&amp;amp; invocation : invocations) {
    invocation();  // [见小节3.5]
    for (const auto&amp;amp; observer : task_observers_) {
      observer.second();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于ui线程处于消息loop状态，一旦有时间到达的任务则开始执行，否则处于空闲等等状态。前面[小节3.4] VsyncWaiter::FireCallback过程已经向该ui线程postTask。 对于不可复用layer tree的情况则调用Animator::BeginFrame()方法。&lt;/p&gt;

&lt;h3 id=&quot;35-callback&quot;&gt;3.5 callback&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self = weak_factory_.GetWeakPtr()](fml::TimePoint frame_start_time,
                                    fml::TimePoint frame_target_time) {
  if (self) {
    if (self-&amp;gt;CanReuseLastLayerTree()) {
      self-&amp;gt;DrawLastLayerTree();
    } else {
      //根据默认参数regenerate_layer_tree_为true，则执行该分支 [见小节3.6]
      self-&amp;gt;BeginFrame(frame_start_time, frame_target_time);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此次的callback赋值过程位于[小节2.3]Animator::AwaitVSync()方法的闭包参数，相关说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;frame_start_time：计划开始绘制时间点，来源于doFrame()方法中的参数；&lt;/li&gt;
  &lt;li&gt;frame_target_time：从frame_start_time加上一帧时间(16.7ms)的时间，作为本次绘制的deadline。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;36-animatorbeginframe&quot;&gt;3.6 Animator::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::BeginFrame(fml::TimePoint frame_start_time,
                          fml::TimePoint frame_target_time) {
  TRACE_EVENT_ASYNC_END0(&quot;flutter&quot;, &quot;Frame Request Pending&quot;, frame_number_++);
  TRACE_EVENT0(&quot;flutter&quot;, &quot;Animator::BeginFrame&quot;);

  frame_scheduled_ = false;
  notify_idle_task_id_++;
  regenerate_layer_tree_ = false;
  //信号量加1，可以注册新的vsync信号，也就是能执行Animator::RequestFrame()
  pending_frame_semaphore_.Signal();

  if (!producer_continuation_) {
    //[小节3.6.1]/[小节3.6.2]
    producer_continuation_ = layer_tree_pipeline_-&amp;gt;Produce();
    //pipeline已满，说明GPU线程繁忙，则结束本次UI绘制，重新注册Vsync
    if (!producer_continuation_) {
      RequestFrame();
      return;
    }
  }

  //从pipeline中获取有效的continuation，并准备为可能的frame服务
  last_begin_frame_time_ = frame_start_time;
  //获取当前帧绘制截止时间，用于告知可GC的空闲时长
  dart_frame_deadline_ = FxlToDartOrEarlier(frame_target_time);
  {
    TRACE_EVENT2(&quot;flutter&quot;, &quot;Framework Workload&quot;, &quot;mode&quot;, &quot;basic&quot;, &quot;frame&quot;,
                 FrameParity());
    //此处delegate_为Shell [小节3.7]
    delegate_.OnAnimatorBeginFrame(last_begin_frame_time_);
  }

  if (!frame_scheduled_) {
    task_runners_.GetUITaskRunner()-&amp;gt;PostDelayedTask(
        [self = weak_factory_.GetWeakPtr(),
         notify_idle_task_id = notify_idle_task_id_]() {
          if (!self.get()) {
            return;
          }
          // 该任务id和当前任务id一致，则不再需要审查frame，可以通知引擎当前处于空闲状态，100ms
          if (notify_idle_task_id == self-&amp;gt;notify_idle_task_id_) {
            self-&amp;gt;delegate_.OnAnimatorNotifyIdle(Dart_TimelineGetMicros() +
                                                 100000);
          }
        },
        kNotifyIdleTaskWaitTime); //延迟51ms再通知引擎空闲状态
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要功能说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;layer_tree_pipeline_是在Animator对象初始化的过程中创建的LayerTreePipeline，其类型为Pipeline&lt;/li&gt;
  &lt;li&gt;此处kNotifyIdleTaskWaitTime等于51ms，等于3帧的时间+1ms，之所以这样设计是由于在某些工作负载下（比如父视图调整大小，通过viewport metrics事件传达给子视图）实际上还没有schedule帧，尽管在下一个vsync会生成一帧(将在收到viewport事件后schedule)，因此推迟调用OnAnimatorNotifyIdle一点点，从而避免可能垃圾回收在不希望的时间触发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;361-layertreepipeline初始化&quot;&gt;3.6.1 LayerTreePipeline初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Animator::Animator(Delegate&amp;amp; delegate,
                   TaskRunners task_runners,
                   std::unique_ptr&amp;lt;VsyncWaiter&amp;gt; waiter)
    : delegate_(delegate),
      task_runners_(std::move(task_runners)),
      waiter_(std::move(waiter)),
      last_begin_frame_time_(),
      dart_frame_deadline_(0),
      layer_tree_pipeline_(fml::MakeRefCounted&amp;lt;LayerTreePipeline&amp;gt;(2)),
      ... {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此处LayerTreePipeline的初始化过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using LayerTreePipeline = Pipeline&amp;lt;flutter::LayerTree&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在pipeline.h的过程会初始化Pipeline，可见初始值empty_ = 2，available_ = 0；&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pipeline(uint32_t depth) : empty_(depth), available_(0) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;362-pipelineproduce&quot;&gt;3.6.2 Pipeline::Produce&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/synchronization/pipeline.h]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProducerContinuation Produce() {
  //当管道不为空，则不允许再次向管道加入数据
  if (!empty_.TryWait()) {
    return {};
  }

  //[见小节3.6.3]
  return ProducerContinuation{
      std::bind(&amp;amp;Pipeline::ProducerCommit, this, std::placeholders::_1,
                std::placeholders::_2),  // continuation
      GetNextPipelineTraceID()};  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过信号量empty_的初始值为depth(默认等于2)，来保证同一个管道的任务最多不超过depth个，每次UI线程执行Produce()会减1，当GPU线程执行完成Consume()方法后才会执行加1操作。&lt;/p&gt;

&lt;h4 id=&quot;363-producercontinuation初始化&quot;&gt;3.6.3 ProducerContinuation初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/synchronization/pipeline.h]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProducerContinuation(Continuation continuation, size_t trace_id)
    : continuation_(continuation), trace_id_(trace_id) {
  TRACE_FLOW_BEGIN(&quot;flutter&quot;, &quot;PipelineItem&quot;, trace_id_);
  TRACE_EVENT_ASYNC_BEGIN0(&quot;flutter&quot;, &quot;PipelineProduce&quot;, trace_id_);
}
3.6.3 Pipeline.ProducerCommit
[-&amp;gt; flutter/synchronization/pipeline.h]

void ProducerCommit(ResourcePtr resource, size_t trace_id) {
  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(queue_mutex_);
    queue_.emplace(std::move(resource), trace_id);
  }

  available_.Signal();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;37-shellonanimatorbeginframe&quot;&gt;3.7 Shell::OnAnimatorBeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/shell.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnAnimatorBeginFrame(fml::TimePoint frame_time) {
  if (engine_) {
    engine_-&amp;gt;BeginFrame(frame_time);  // [小节3.8]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;38-enginebeginframe&quot;&gt;3.8 Engine::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::BeginFrame(fml::TimePoint frame_time) {
  TRACE_EVENT0(&quot;flutter&quot;, &quot;Engine::BeginFrame&quot;);
  runtime_controller_-&amp;gt;BeginFrame(frame_time);  // [小节3.9]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;39-runtimecontrollerbeginframe&quot;&gt;3.9 RuntimeController::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/runtime/runtime_controller.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool RuntimeController::BeginFrame(fml::TimePoint frame_time) {
  if (auto* window = GetWindowIfAvailable()) {
    window-&amp;gt;BeginFrame(frame_time);  // [小节3.10]
    return true;
  }
  return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;310-windowbeginframe&quot;&gt;3.10 Window::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window/window.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Window::BeginFrame(fml::TimePoint frameTime) {
  std::shared_ptr&amp;lt;tonic::DartState&amp;gt; dart_state = library_.dart_state().lock();
  if (!dart_state)
    return;
  tonic::DartState::Scope scope(dart_state);
  //注意此处的frameTime便是前面小节3.1中doFrame方法中的参数frameTimeNanos
  int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds();

  // [见小节4.2]
  DartInvokeField(library_.value(), &quot;_beginFrame&quot;,
                  {Dart_NewInteger(microseconds)});

  //执行MicroTask
  UIDartState::Current()-&amp;gt;FlushMicrotasksNow();

  // [见小节4.4]
  DartInvokeField(library_.value(), &quot;_drawFrame&quot;, {});
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Window::BeginFrame()过程主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行_beginFrame&lt;/li&gt;
  &lt;li&gt;执行FlushMicrotasksNow&lt;/li&gt;
  &lt;li&gt;执行_drawFrame&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。&lt;/p&gt;

&lt;p&gt;DartInvokeField()通过dart虚拟机调用了window.onBeginFrame()和onDrawFrame方法，见hooks.dart文件中如下过程：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@pragma('vm:entry-point')
void _beginFrame(int microseconds) {
  _invoke1&amp;lt;Duration&amp;gt;(window.onBeginFrame, window._onBeginFrameZone, new Duration(microseconds: microseconds));
}

@pragma('vm:entry-point')
void _drawFrame() {
  _invoke(window.onDrawFrame, window._onDrawFrameZone);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 19 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%B8%89)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%B8%89)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(二)</title>
        <description>&lt;h2 id=&quot;二-vsync注册流程&quot;&gt;二、 VSYNC注册流程&lt;/h2&gt;
&lt;h3 id=&quot;21-enginescheduleframe&quot;&gt;2.1 Engine::ScheduleFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::ScheduleFrame(bool regenerate_layer_tree) {
    //[见小节2.2]
    animator_-&amp;gt;RequestFrame(regenerate_layer_tree);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;animator_的赋值过程是在Engine对象初始化过程完成，而Engine初始化过程在Shell创建过程，此处animator_便是Animator对象；&lt;/li&gt;
  &lt;li&gt;ScheduleFrame的参数regenerate_layer_tree决定是否需要重新生成layer tree，还是直接复用上一次生成的layer tree；&lt;/li&gt;
  &lt;li&gt;绝大多数情况下，调用RequestFrame()时将regenerate_layer_tree_设置为true或者用默认值true，执行完Animator::BeginFrame()则设置该变量为false；
    &lt;ul&gt;
      &lt;li&gt;当无参数调用该方法时，regenerate_layer_tree为默认值为true。&lt;/li&gt;
      &lt;li&gt;特别的例子就是Shell::OnPlatformViewMarkTextureFrameAvailable()过程，设置参数为false，那么计划绘制一帧的时候就不需要重绘layer tree；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-animatorrequestframe&quot;&gt;2.2 Animator::RequestFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::RequestFrame(bool regenerate_layer_tree) {
  if (regenerate_layer_tree) {
    // regenerate_layer_tree_决定Vsync信号到来时，是否执行BeginFrame
    regenerate_layer_tree_ = true;
  }

  //当调用Animator::Stop()则会停止动画绘制
  if (paused_ &amp;amp;&amp;amp; !dimension_change_pending_) {
    return;
  }

  //调用sem_trywait来保证不会同时有多个vsync请求
  if (!pending_frame_semaphore_.TryWait()) {
    return;
  }

  task_runners_.GetUITaskRunner()-&amp;gt;PostTask([self = weak_factory_.GetWeakPtr(),
                                             frame_number = frame_number_]() {
    if (!self.get()) {
      return;
    }
    TRACE_EVENT_ASYNC_BEGIN0(&quot;flutter&quot;, &quot;Frame Request Pending&quot;, frame_number);
    self-&amp;gt;AwaitVSync();  // [见小节2.3]
  });
  frame_scheduled_ = true;  //标注已经schedule绘画帧
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;过程说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pending_frame_semaphore_：非负信号量，初始值为1，第一次调用TryWait减1，而后再次调用则会失败直接返回。当消费了这次vsync回调，也就是调用了Animator的BeginFrame()或者DrawLastLayerTree()方法后，改信号量会加1[见小节3.6]，可以再次执行vysnc的注册；&lt;/li&gt;
  &lt;li&gt;通过Animator的Start()或者BeginFrame调用到的RequestFrame方法，则肯定需要重新生成layer tree；通过Engine的ScheduleFrame方法是否重建layer tree看小节2.1；&lt;/li&gt;
  &lt;li&gt;此处通过post把Animator::AwaitVSync任务放入到UI Task Runner来执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-animatorawaitvsync&quot;&gt;2.3 Animator::AwaitVSync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::AwaitVSync() {
  // [见小节2.4]
  waiter_-&amp;gt;AsyncWaitForVsync(
      [self = weak_factory_.GetWeakPtr()](fml::TimePoint frame_start_time,
                                          fml::TimePoint frame_target_time) {
        if (self) {
          //是否能复用上次layer树，取决于regenerate_layer_tree_
          if (self-&amp;gt;CanReuseLastLayerTree()) {
            //复用上次layer树，直接把任务post到gpu线程做栅格化操作
            self-&amp;gt;DrawLastLayerTree();
          } else {
            self-&amp;gt;BeginFrame(frame_start_time, frame_target_time);
          }
        }
      });

  delegate_.OnAnimatorNotifyIdle(dart_frame_deadline_);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;waiter_的赋值是在Animator初始化过程，取值为VsyncWaiterAndroid对象，当调用了RequestFrame()，默认参数regenerate_layer_tree_为true，意味着需要重新生成layer树，故不能重复使用上一次的layer树，接着来看一下AsyncWaitForVsync()方法的实现。&lt;/p&gt;

&lt;h3 id=&quot;24-vsyncwaiterasyncwaitforvsync&quot;&gt;2.4 VsyncWaiter::AsyncWaitForVsync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/vsync_waiter.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void VsyncWaiter::AsyncWaitForVsync(Callback callback) {
  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(callback_mutex_);
    //赋值callback_
    callback_ = std::move(callback);
  }
  TRACE_EVENT0(&quot;flutter&quot;, &quot;AsyncWaitForVsync&quot;);
  AwaitVSync(); // [见小节2.5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此次的callback_便是[小节2.3]方法中的参数，该方法根据regenerate_layer_tree_来决定执行流。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当regenerate_layer_tree_=false，则执行DrawLastLayerTree();&lt;/li&gt;
  &lt;li&gt;当regenerate_layer_tree_=false，则执行BeginFrame();&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;25-vsyncwaiterandroidawaitvsync&quot;&gt;2.5 VsyncWaiterAndroid::AwaitVSync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void VsyncWaiterAndroid::AwaitVSync() {
  std::weak_ptr&amp;lt;VsyncWaiter&amp;gt;* weak_this =
      new std::weak_ptr&amp;lt;VsyncWaiter&amp;gt;(shared_from_this());
  //获取VsyncWaiter的弱引用
  jlong java_baton = reinterpret_cast&amp;lt;jlong&amp;gt;(weak_this);

  JNIEnv* env = fml::jni::AttachCurrentThread();
  // 此次调用到Java层的asyncWaitForVsync方法，java_baton指向VsyncWaiter
  env-&amp;gt;CallStaticVoidMethod(g_vsync_waiter_class-&amp;gt;obj(),     //
                            g_async_wait_for_vsync_method_,  //
                            java_baton                       //
  );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此处g_vsync_waiter_class，g_async_wait_for_vsync_method_的赋值过程是由JNI_OnLoad完成，如下所示。&lt;/p&gt;

&lt;h4 id=&quot;251-jni_onload&quot;&gt;2.5.1 JNI_OnLoad&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/library_loader.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
  // 初始化Java虚拟机
  fml::jni::InitJavaVM(vm);

  JNIEnv* env = fml::jni::AttachCurrentThread();
  bool result = false;

  // 注册FlutterMain.
  result = shell::FlutterMain::Register(env);

  // 注册PlatformView [见小节2.5.2]
  result = shell::PlatformViewAndroid::Register(env);

  // 注册VSyncWaiter [见小节2.5.3]
  result = shell::VsyncWaiterAndroid::Register(env);

  return JNI_VERSION_1_4;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;首次加载共享库时虚拟机会调用此方法。&lt;/p&gt;

&lt;h4 id=&quot;252-register&quot;&gt;2.5.2 Register&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/platform_view_android_jni.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool PlatformViewAndroid::Register(JNIEnv* env) {
  //记录FlutterCallbackInformation类的全局引用
  g_flutter_callback_info_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(
      env, env-&amp;gt;FindClass(&quot;io/flutter/view/FlutterCallbackInformation&quot;));
  //记录FlutterCallbackInformation构造函数
  g_flutter_callback_info_constructor = env-&amp;gt;GetMethodID(
      g_flutter_callback_info_class-&amp;gt;obj(), &quot;&amp;lt;init&amp;gt;&quot;,
      &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V&quot;);
  //记录FlutterJNI类的全局引用
  g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(
      env, env-&amp;gt;FindClass(&quot;io/flutter/embedding/engine/FlutterJNI&quot;));
  //记录SurfaceTexture类的全局引用
  g_surface_texture_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(
      env, env-&amp;gt;FindClass(&quot;android/graphics/SurfaceTexture&quot;));

  static const JNINativeMethod callback_info_methods[] = {
      {
          .name = &quot;nativeLookupCallbackInformation&quot;,
          .signature = &quot;(J)Lio/flutter/view/FlutterCallbackInformation;&quot;,
          .fnPtr = reinterpret_cast&amp;lt;void*&amp;gt;(&amp;amp;shell::LookupCallbackInformation),
      },
  };
  //注册FlutterCallbackInformation的nativeLookupCallbackInformation()方法
  env-&amp;gt;RegisterNatives(g_flutter_callback_info_class-&amp;gt;obj(),
                           callback_info_methods,
                           arraysize(callback_info_methods)) != 0);

  g_is_released_method =
      env-&amp;gt;GetMethodID(g_surface_texture_class-&amp;gt;obj(), &quot;isReleased&quot;, &quot;()Z&quot;);

  fml::jni::ClearException(env);

  g_attach_to_gl_context_method = env-&amp;gt;GetMethodID(
      g_surface_texture_class-&amp;gt;obj(), &quot;attachToGLContext&quot;, &quot;(I)V&quot;);

  g_update_tex_image_method =
      env-&amp;gt;GetMethodID(g_surface_texture_class-&amp;gt;obj(), &quot;updateTexImage&quot;, &quot;()V&quot;);

  g_get_transform_matrix_method = env-&amp;gt;GetMethodID(
      g_surface_texture_class-&amp;gt;obj(), &quot;getTransformMatrix&quot;, &quot;([F)V&quot;);

  g_detach_from_gl_context_method = env-&amp;gt;GetMethodID(
      g_surface_texture_class-&amp;gt;obj(), &quot;detachFromGLContext&quot;, &quot;()V&quot;);

  return RegisterApi(env);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该方法的主要工作：&lt;/p&gt;

&lt;p&gt;记录和注册类FlutterCallbackInformation、FlutterJNI以及SurfaceTexture类的相关方法，用于Java和C++层方法的相互调用。&lt;/p&gt;
&lt;h4 id=&quot;253-register&quot;&gt;2.5.3 Register&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool VsyncWaiterAndroid::Register(JNIEnv* env) {
  static const JNINativeMethod methods[] = ;

  jclass clazz = env-&amp;gt;FindClass(&quot;io/flutter/view/VsyncWaiter&quot;);

  g_vsync_waiter_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(env, clazz);

  g_async_wait_for_vsync_method_ = env-&amp;gt;GetStaticMethodID(
      g_vsync_waiter_class-&amp;gt;obj(), &quot;asyncWaitForVsync&quot;, &quot;(J)V&quot;);

  return env-&amp;gt;RegisterNatives(clazz, methods, arraysize(methods)) == 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该注册过程主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将Java层的VsyncWaiter类的nativeOnVsync()方法，映射到C++层的OnNativeVsync()方法，用于该方法的Java调用C++的过程；&lt;/li&gt;
  &lt;li&gt;将Java层的VsyncWaiter类的asyncWaitForVsync()方法，保存到C++层的g_async_wait_for_vsync_method_变量，用于该方法C++调用Java的过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，将调用VsyncWaiter类的asyncWaitForVsync()方法&lt;/p&gt;

&lt;h3 id=&quot;26-asyncwaitforvsync&quot;&gt;2.6 asyncWaitForVsync&lt;/h3&gt;
&lt;p&gt;[Java]
[-&amp;gt; flutter/shell/platform/android/io/flutter/view/VsyncWaiter.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class VsyncWaiter {
    // FlutterView的刷新时间周期（16.7ms）
    public static long refreshPeriodNanos = 1000000000 / 60;

    private static HandlerThread handlerThread;
    private static Handler handler;

    static {
        handlerThread = new HandlerThread(&quot;FlutterVsyncThread&quot;);
        handlerThread.start();
    }

    public static void asyncWaitForVsync(final long cookie) {
        if (handler == null) {
            handler = new Handler(handlerThread.getLooper());
        }
        handler.post(new Runnable() {
            @Override
            public void run() {
                //注册帧回调方法，见小节[2.6.1]/[2.6.2]
                Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {
                    @Override
                    public void doFrame(long frameTimeNanos) {
                        //frameTimeNanos是VYSNC触发的时间点，也就是计划绘制的时间点
                        nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);
                    }
                });
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过Handler将工作post到FlutterVsyncThread线程，具体的工作是通过Choreographer来注册回调方法doFrame()以监听系统VSYNC信号。&lt;/p&gt;

&lt;h4 id=&quot;261-choreographergetinstance&quot;&gt;2.6.1 Choreographer.getInstance&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; Choreographer.java]&lt;/p&gt;

&lt;p&gt;```public static Choreographer getInstance() {
    return sThreadInstance.get(); //单例模式
}&lt;/p&gt;

&lt;p&gt;private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance =
    new ThreadLocal&lt;Choreographer&gt;() {&lt;/Choreographer&gt;&lt;/Choreographer&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected Choreographer initialValue() {
    //获取当前线程FlutterVsyncThread的Looper
    Looper looper = Looper.myLooper();
    // 初始化Choreographer对象
    return new Choreographer(looper);
} };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;private Choreographer(Looper looper) {
    mLooper = looper;
    //创建Handler对象
    mHandler = new FrameHandler(looper);
    //创建用于接收VSync信号的对象
    mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;
    mLastFrameTimeNanos = Long.MIN_VALUE;  //上一次帧绘制时间点
    mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());
    mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];&lt;br /&gt;
    for (int i = 0; i &amp;lt;= CALLBACK_LAST; i++) {
        mCallbackQueues[i] = new CallbackQueue();
    }
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此处Choreographer的mLooper和mHandler都运行在FlutterVsyncThread线程。

#### 2.6.2 postFrameCallback
[-&amp;gt; Choreographer.java]

```public void postFrameCallback(FrameCallback callback) {
    postFrameCallbackDelayed(callback, 0);
}

public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
    postCallbackDelayedInternal(CALLBACK_ANIMATION,
            callback, FRAME_CALLBACK_TOKEN, delayMillis);
}

private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) {
    synchronized (mLock) {
        final long now = SystemClock.uptimeMillis();
        final long dueTime = now + delayMillis;
        //添加到mCallbackQueues队列
        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);
        if (dueTime &amp;lt;= now) {
          scheduleFrameLocked(now);
        } else {
          ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将FrameCallback方法加入到mCallbackQueues[CALLBACK_ANIMATION]回调队列中。&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%BA%8C)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%BA%8C)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(一)</title>
        <description>&lt;h2 id=&quot;一ui线程渲染&quot;&gt;一、UI线程渲染&lt;/h2&gt;
&lt;p&gt;Flutter是谷歌开源的移动UI框架，可以快速在Android和iOS上构建出高质量的原生用户界面，目前全世界越来越多的开发者加入到Flutter的队伍。 Flutter相比RN性能更好，由于Flutter自己实现了一套UI框架，丢弃了原生的UI框架，非常接近原生的体验。&lt;/p&gt;

&lt;p&gt;为了揭秘Flutter高性能，本文从源码角度来看看Flutter的渲染绘制机制，跟渲染直接相关的两个线程是UI线程和GPU线程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;UI线程：运行着UI Task Runner，是Flutter Engine用于执行Dart root isolate代码，将其转换为layer tree视图结构；&lt;/li&gt;
  &lt;li&gt;GPU线程：该线程依然是在CPU上执行，运行着GPU Task Runner，处理layer tree，将其转换成为GPU命令并发送到GPU。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过VSYNC信号使UI线程和GPU线程有条不紊的周期性的渲染界面，本文介绍VSYNC的产生过程、UI线程在引擎和框架的绘制工作，下一篇文章会介绍GPU线程的绘制工作。&lt;/p&gt;

&lt;h3 id=&quot;11-ui渲染原理&quot;&gt;1.1 UI渲染原理&lt;/h3&gt;
&lt;h4 id=&quot;111-ui渲染概览&quot;&gt;1.1.1 UI渲染概览&lt;/h4&gt;
&lt;p&gt;通过VSYNC信号使UI线程和GPU线程有条不紊的周期性的渲染界面，如下图所示：
&lt;img src=&quot;http://gityuan.com/img/flutter_ui/flutter_draw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当需要渲染则会调用到Engine的ScheduleFrame()来注册VSYNC信号回调，一旦触发回调doFrame()执行完成后，便会移除回调方法，也就是说一次注册一次回调；&lt;/li&gt;
  &lt;li&gt;当需要再次绘制则需要重新调用到ScheduleFrame()方法，该方法的唯一重要参数regenerate_layer_tree决定在帧绘制过程是否需要重新生成layer tree，还是直接复用上一次的layer tree；&lt;/li&gt;
  &lt;li&gt;UI线程的绘制过程，最核心的是执行WidgetsBinding的drawFrame()方法，然后会创建layer tree视图树&lt;/li&gt;
  &lt;li&gt;再交由GPU Task Runner将layer tree提供的信息转化为平台可执行的GPU指令。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;112-ui绘制核心工作&quot;&gt;1.1.2 UI绘制核心工作&lt;/h4&gt;
&lt;p&gt;1）Vsync单注册模式：保证在一帧的时间窗口里UI线程只会生成一个layer tree发送给GPU线程，原理如下：&lt;/p&gt;

&lt;p&gt;Animator中的信号量pending_frame_semaphore_用于控制不能连续频繁地调用Vsync请求，一次只能存在Vsync注册。 pending_frame_semaphore_初始值为1，在Animator::RequestFrame()消费信号会减1，当而后再次调用则会失败直接返回； Animator的BeginFrame()或者DrawLastLayerTree()方法会执行信号加1操作。&lt;/p&gt;

&lt;p&gt;2）UI绘制最核心的方法是drawFrame()，包含以下几个过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Animate: 遍历_transientCallbacks，执行动画回调方法；&lt;/li&gt;
  &lt;li&gt;Build: 对于dirty的元素会执行build构造，没有dirty元素则不会执行，对应于buildScope()&lt;/li&gt;
  &lt;li&gt;Layout: 计算渲染对象的大小和位置，对应于flushLayout()，这个过程可能会嵌套再调用build操作；&lt;/li&gt;
  &lt;li&gt;Compositing bits: 更新具有脏合成位的任何渲染对象， 对应于flushCompositingBits()；&lt;/li&gt;
  &lt;li&gt;Paint: 将绘制命令记录到Layer， 对应于flushPaint()；&lt;/li&gt;
  &lt;li&gt;Compositing: 将Compositing bits发送给GPU， 对应于compositeFrame()；&lt;/li&gt;
  &lt;li&gt;Semantics: 编译渲染对象的语义，并将语义发送给操作系统， 对应于flushSemantics()。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;UI线程的耗时从doFrame(frameTimeNanos)中的frameTimeNanos为起点，以小节[4.10.6]Animator::Render()方法结束为终点， 并将结果保存到LayerTree的成员变量construction_time_，这便是UI线程的耗时时长。&lt;/p&gt;

&lt;h4 id=&quot;113-timeline说明&quot;&gt;1.1.3 Timeline说明&lt;/h4&gt;
&lt;p&gt;3）以上几个过程在Timeline中ui线程中都有体现，如下图所示：
&lt;img src=&quot;http://gityuan.com/img/flutter_ui/timeline_ui_draw.png&quot; alt=&quot;&quot; /&gt;
另外Timeline中还有两个比较常见的标签项&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Frame Request Pending”：从Animator::RequestFrame 到Animator::BeginFrame()结束；&lt;/li&gt;
  &lt;li&gt;”PipelineProduce“： 从Animator::BeginFrame()到Animator::Render()结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-ui线程渲染流程图&quot;&gt;1.2 UI线程渲染流程图&lt;/h3&gt;
&lt;h4 id=&quot;121-vsync注册流程&quot;&gt;1.2.1 VSYNC注册流程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://gityuan.com/img/flutter_ui/Vsync.jpg&quot; alt=&quot;&quot; /&gt;
当调用到引擎Engine的ScheduleFrame()方法过程则会注册VSYNC信号回调，一旦Vsync信号达到，则会调用到doFrame()方法。 对于调用ScheduleFrame()的场景有多种，比如动画的执行AnimationController.forward()，再比如比如surface创建的时候shell::SurfaceCreated()。&lt;/p&gt;
&lt;h4 id=&quot;122-engine层绘制&quot;&gt;1.2.2 Engine层绘制&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://gityuan.com/img/flutter_ui/UIDraw_engine.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;doFrame()经过多层调用后通过PostTask将任务异步post到UI TaskRunner线程来执行，最后调用到Window的BeginFrame()方法。&lt;/p&gt;

&lt;h4 id=&quot;123-framework层绘制&quot;&gt;1.2.3 Framework层绘制&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://gityuan.com/img/flutter_ui/UIDraw_fwk.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中window.cc中的一个BeginFrame()方法，会调用到window.dart中的onBeginFrame()和onDrawFrame()两个方法。&lt;/p&gt;

&lt;h3 id=&quot;13-核心类图&quot;&gt;1.3 核心类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://gityuan.com/img/flutter_ui/ClassEngine.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了让大家更容易理解源码，先看一张关于Shell、Engine、Animator等Flutter等Flutter引擎中核心类的类图。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Window类：是连接Flutter框架层(Dart)与引擎层(C++)的关键类，在框架层中window.dart文件里的一些方法在引擎层的window.cc文件有相对应的方法，比如scheduleFrame()方法。 在window.cc里面通过Window::RegisterNatives()注册了一些框架层与引擎层的方法对应关系；&lt;/li&gt;
  &lt;li&gt;RuntimeController类：可通过其成员root_isolate_找到Window类；&lt;/li&gt;
  &lt;li&gt;Shell类：同时继承了PlatformView::Delegate，Animator::Delegate，Engine::Delegate，所以在Engine，Animator，PlatformView中的成员变量delegate_都是指Shell对象， 从图中也能看出其中心地位，代理多项业务，该类是由AndroidShellHolder过程中初始化创建的；另外Shell类还继承了ServiceProtocol::Handler，图中省略而已。&lt;/li&gt;
  &lt;li&gt;PlatformViewAndroid类：在Android平台上PlatformView的实例采用的便是PlatformViewAndroid类。&lt;/li&gt;
  &lt;li&gt;Dart层与C层之间可以相互调用，从Window一路能调用到Shell类，也能从Shell类一路调用回Window。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 02 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%B8%80)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%B8%80)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
  </channel>
</rss>
