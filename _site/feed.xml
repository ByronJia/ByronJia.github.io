<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 11 Dec 2020 14:20:21 +0800</pubDate>
    <lastBuildDate>Fri, 11 Dec 2020 14:20:21 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>音视频基础知识</title>
        <description>&lt;h3 id=&quot;码率&quot;&gt;码率：&lt;/h3&gt;
&lt;p&gt;也叫比特率， Bits per second 每秒传输的数据量。 可以理解成吞吐量或带宽。 目的是用最低的比特率达到最少的失真&lt;/p&gt;

&lt;p&gt;###帧率：
Frames per second 每秒显示帧数。&lt;/p&gt;

&lt;h3 id=&quot;常见编码标准&quot;&gt;常见编码标准:&lt;/h3&gt;
&lt;p&gt;MPEG-4， 其中第10部分提出新的视频编码方案，即与另一个组织共同开发的H.264。第三部分提出AAC音频编码方案，旨在替代MP3。  第14部分提出MP4封装格式包括音频编码方案和视频编码方案。&lt;/p&gt;

&lt;h3 id=&quot;h264&quot;&gt;H.264:&lt;/h3&gt;
&lt;p&gt;定义了三种帧，I帧 P帧 B帧
1）I 帧：I帧即帧内编码帧、关键帧，可以理解为一帧画面的完整保留，解码时只需要本帧数据就可以完成，不需要参考其他画面，数据量比较大；
2）P 帧：P帧即前向预测编码帧，记录当前帧跟上一关键帧（或P帧）的差别，解码时依赖之前缓存的画面，叠加上本帧定义的差别，才能生成最终画面，数据量较 I 帧小很多；
3）B 帧：B帧即双向预测编码帧，记录当前帧跟前后帧的差别，解码时依赖前面的I帧（或P帧）和后面的P帧，数据量比I帧和P帧小很多。
直播场景中一般不适用B帧，因为受到一个B帧后还要等待之后的P帧才能解码，会有滞后性。&lt;/p&gt;

&lt;p&gt;编码计算复杂度是H.263的3倍， 解码复杂度是H.263的2倍。但是相同视频 质量，可以比H.263节省50%码率&lt;/p&gt;

&lt;h3 id=&quot;h265&quot;&gt;H.265:&lt;/h3&gt;
&lt;p&gt;High Efficiency Video Coding 简称HEVC。  与H.264类似，包含帧内预测，帧间预测，转化，量化，滤波，熵编码等。
在H.264基础上使用先进技术用以改善码流，编码质量，延时和算法复杂度之间的关系。
在码率减少51-74%情况下，265的视频质量与264近似甚至更好。
iOS11开始原生支持HEVC   H.265&lt;/p&gt;

&lt;h3 id=&quot;gop&quot;&gt;GOP:&lt;/h3&gt;
&lt;p&gt;Group of Pictures 一组连续的画面，由一张I帧和多张B/P帧组成，是视频编解码存取的基本单位。GOP组的长度格式也决定了码流的大小,形容一个I帧到下一个I帧之间间隔多少帧，增大GOP能有效减少编码后视频体积，但也会降低视频质量。&lt;/p&gt;

&lt;h3 id=&quot;idr帧&quot;&gt;IDR帧：&lt;/h3&gt;
&lt;p&gt;一个序列的首个I帧叫做IDR帧，IDR帧都是I帧.
引入目的是为了解码的重同步,如果前序列出现重大错误，这里可以获得重新同步机会。
当解码到IDR帧时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始新序列。&lt;/p&gt;

&lt;h3 id=&quot;nal&quot;&gt;NAL:&lt;/h3&gt;
&lt;p&gt;Network abstract layer 网络抽象层&lt;/p&gt;

&lt;h3 id=&quot;sps&quot;&gt;SPS:&lt;/h3&gt;
&lt;p&gt;Sequence Parameter Set ，序列参数集，保存了一组编码视频序列的全局参数，一般SPS 和PPS在整个码流的起始位置，特殊情况下也可能在中间出现，例如中间需要重新解码，或者参数信息发生编发例如屏幕宽高比变化。&lt;/p&gt;

&lt;h3 id=&quot;pps&quot;&gt;PPS:&lt;/h3&gt;
&lt;p&gt;Picture Parameter Set  图形参数集，类似于SPS， 在马六周年单独保存在一个NAL Unit中，保存在视频文件的文件头中。&lt;/p&gt;

&lt;h3 id=&quot;dts&quot;&gt;DTS&lt;/h3&gt;
&lt;p&gt;Decoding Time Stamp 解码时间戳，表示送入解码器的顺序&lt;/p&gt;

&lt;h3 id=&quot;pts&quot;&gt;PTS&lt;/h3&gt;
&lt;p&gt;Presentation Time Stamp 显示时间戳，表示解码后的帧显示时间
在没有B帧情况下，DTS和PTS输出顺序一致。 因为B帧需要依赖后续的帧，所以B帧解码要在后续P帧之后，但是显示又在后续P帧之前&lt;/p&gt;

&lt;h3 id=&quot;音视频同步&quot;&gt;音视频同步：&lt;/h3&gt;
&lt;p&gt;音频没有类似视频中的B帧，所以音频帧的DTS 和PTS顺序是一致的。
通常需要选择一个参考时钟，参考时间的时间是线性递增的，编码音视频流时一句参考时钟上的时间给每个数据打上时间戳，播放时读取数据帧上的时间戳，同时参考PTS安排播放。&lt;/p&gt;

&lt;h3 id=&quot;视频传输协议优化&quot;&gt;视频传输协议优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;服务端节点之间尽量使用RTMP，降低整体传输延迟&lt;/li&gt;
  &lt;li&gt;如果终端使用RTMP播放，应该在尽量靠近收流节点进行转码，这样传输的视频流从一开始就是最优大小&lt;/li&gt;
  &lt;li&gt;如有必要，使用定制的UDP协议替换TCP协议，省去弱网环境下的丢包重传。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;视频传输网络优化&quot;&gt;视频传输网络优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在服务端节点中缓存GOP，配合播放器端的首开优化&lt;/li&gt;
  &lt;li&gt;服务端实时记录每个视频流在每个环节的帧率和码率，检测波动&lt;/li&gt;
  &lt;li&gt;客户端通过查询服务端准实时获取当前最优节点(5秒一次)， 准实时下线当前故障节点和线路&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;推流播放优化&quot;&gt;推流、播放优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;考察发送端系统的网络buffer大小&lt;/li&gt;
  &lt;li&gt;播放端的缓存对首开延迟也有较大影响，甚至可以在0缓存的情况下，将第一帧数据直接解码显示。但是如果弱网状态下，需要考虑网络波动造成的卡顿，还是需要增加一定的缓存。&lt;/li&gt;
  &lt;li&gt;可以使用动态缓存策略，参考第一帧的下载耗时决定后续播放过程中的缓存大小。&lt;/li&gt;
  &lt;li&gt;动态码率，在增加缓存依然无法满足当前码率的情况下，采用动态码率，减少延迟，当网络有所改善后，再动态增加码率。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS Crash 分析</title>
        <description>&lt;h3 id=&quot;关于crash&quot;&gt;关于Crash&lt;/h3&gt;
&lt;p&gt;当app发生crash时，系统会生成crash report 存储在设备上，其中会描述app在何种情况下被系统终止，一般会包括完整的线程调用堆栈。包括以下2种report:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Crash report:包含堆栈信息，被符号化之前是运行内容中的实际函数地址，需要将report与 .dSYM或 .app共同分析出内存中的实际地址映射的函数方法，从而便于定位问题。&lt;/li&gt;
  &lt;li&gt;Low Memory report:没有堆栈信息，由于低内存引发crash，下面会详细介绍&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;符号化&quot;&gt;符号化&lt;/h3&gt;
&lt;p&gt;crash符号化常用的3个文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;symbolicatecrash：是系统提供的符号化执行程序，依赖于.dSYM、.crash 和.app  3个文件&lt;/li&gt;
  &lt;li&gt;.dSYM : 编译器在把你的源代码转换成机器码的同时，也会生成一份对应的Debug符号表,保存十六进制函数地址映射信息，通过他能得知log中的堆栈地址与具体方法的地址的映射关系&lt;/li&gt;
  &lt;li&gt;.crash : 是系统保存的崩溃日志文件，包括所有线程状态，和方法调用堆栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也可使用atos命令符号化， 只需要.crash和 .dSYM和app其中一个即可。
以下是符号化之前和符号化之后的堆栈信息，第3行符号化之后即可看到自己实现的函数名
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201211/16076544840576.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201211/16076544907887.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么系统函数的堆栈能打印出来？
因为系统函数的符号表在xcode中已经内置，且不同系统版本不一样，所以每次我们在升级xcode后，就会包含xcode支持的最新iOS系统的符号表。&lt;/p&gt;

&lt;h3 id=&quot;异常信息&quot;&gt;异常信息&lt;/h3&gt;
&lt;p&gt;carsh report 中的字段能提供异常信息，便于从宏观角度分析crash的原因。&lt;/p&gt;

&lt;p&gt;下面是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;uncaught Objective-C exception&lt;/code&gt;而导致的进程被停止的crash report的摘录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception Type: EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note: EXC_CORPSE_NOTIFY
Triggered by Thread: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是由于反向引用了一个NULL指针而造成进程被终止的crash report的摘录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000
Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [0]
Triggered by Thread: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中
&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Type&lt;/code&gt;: 异常类型，下面会详细定义不同类型的含义。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Codes&lt;/code&gt; ：和异常是有关的处理器指定信息，这些信息会被编码成一个或者多个64位二进制数字。一般来说，这个字段不应该存在，因为crash report生成时会把exception code转化成可读的信息并在其它字段进行体现。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Subtype&lt;/code&gt;：可读的exception code的名称。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Message&lt;/code&gt;：从exception code中解析出来的附加的可读信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Note&lt;/code&gt;：不特指某一种异常的额外信息。如果这个字段包含”SIMULATED”(不是Crash)，则进程并没有发生crash，而是在系统层面被kill掉了，比如看门狗机制。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Termination Reason&lt;/code&gt;：当进程被终止时的原因及信息。关键的信息模块，不论是进程内还是进程外，当遇到一个致命错误（fatal error，例如bad code signature，缺失依赖库，不恰当的访问私有敏感信息等）。MacOS Sierra,iOS 10, watch OS3和tvOS 10 已经采用新的架构去记录这些错误信息，所以这些系统之下的crash report会在Termination Reason这个字段里描述error message信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Triggered by Thread&lt;/code&gt;：指出异常是在哪个线程发生的&lt;/p&gt;

&lt;h3 id=&quot;看门狗&quot;&gt;看门狗&lt;/h3&gt;
&lt;p&gt;为了防止应用占用过多系统资源，看门狗机制能检测应用性能，若超出阈值，看门狗会强制终结这个应用的进程。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;触发时机&lt;/th&gt;
      &lt;th&gt;看门狗出动的时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;启动&lt;/td&gt;
      &lt;td&gt;20秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;恢复运行&lt;/td&gt;
      &lt;td&gt;10秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;挂起进程&lt;/td&gt;
      &lt;td&gt;10秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;退出应用&lt;/td&gt;
      &lt;td&gt;6秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;后台运行&lt;/td&gt;
      &lt;td&gt;10分钟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;常见异常类型&quot;&gt;常见异常类型&lt;/h3&gt;
&lt;h4 id=&quot;bad-memory-access-exc_bad_access--sigsegv--sigbus&quot;&gt;Bad Memory Access [EXC_BAD_ACCESS // SIGSEGV // SIGBUS]&lt;/h4&gt;
&lt;p&gt;进程试图访问无效的内存空间，或尝试访问的方法不允许(例如去写只读的内存空间)&lt;/p&gt;

&lt;h4 id=&quot;abnormal-exit-exc_crash--sigabrt&quot;&gt;Abnormal Exit [EXC_CRASH // SIGABRT]&lt;/h4&gt;
&lt;p&gt;进程异常退出，常见原因是&lt;code class=&quot;highlighter-rouge&quot;&gt;uncaught Objective-C/C++ exception&lt;/code&gt; 并且调用了abort()。&lt;/p&gt;

&lt;h4 id=&quot;trace-trap-exc_breakpoint--sigtrap&quot;&gt;Trace Trap [EXC_BREAKPOINT // SIGTRAP]&lt;/h4&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Abnormal Exit&lt;/code&gt;类似，这种异常是由于在特殊的节点加入debugger调试节点的原因。&lt;/p&gt;

&lt;h4 id=&quot;illegal-instruction-exc_bad_instruction--sigill&quot;&gt;Illegal Instruction [EXC_BAD_INSTRUCTION // SIGILL]&lt;/h4&gt;
&lt;p&gt;尝试执行一个非法或者未定义的指令时会触发该异常。&lt;/p&gt;

&lt;h4 id=&quot;quit-sigquit&quot;&gt;Quit [SIGQUIT]&lt;/h4&gt;
&lt;p&gt;这个异常是由于其他进程拥有高优先级且可以管理本进程所导致（被高优先级进程kill掉）。&lt;/p&gt;

&lt;h4 id=&quot;killedsigkill&quot;&gt;Killed[SIGKILL]&lt;/h4&gt;
&lt;p&gt;进程收到系统指令被干掉，可以自行查看Termination Reason来定位线程被干掉的原因。&lt;/p&gt;

&lt;h4 id=&quot;guarded-resource-violation-exc_guard&quot;&gt;Guarded Resource Violation [EXC_GUARD]&lt;/h4&gt;
&lt;p&gt;进程访问了一个被保护的资源。&lt;/p&gt;

&lt;h4 id=&quot;resource-limit-exc_resource&quot;&gt;Resource Limit [EXC_RESOURCE]&lt;/h4&gt;
&lt;p&gt;进程的资源超过限定阈值，表示进程占用太多资源，&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Subtype&lt;/code&gt;会提示原因，例如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEMORY&lt;/code&gt;:暗示了进程占用已经超过系统限制。如果之后出现由于系统占用过多进程被Kill，可能和这有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WAKEUP&lt;/code&gt;:暗示线程每秒被进程唤醒太多次了，进而导致CPU被频繁唤醒并且造成电量损耗。
通常，这种事发生在线程间通信（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;peformSelector:onThread:&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;），而且会远比预想的发生的更频繁。因为发生这种异常的通信被触发的如此频繁，所以很多后台线程会出现彼此高度雷同的堆栈信息——恰恰暗示了它们是从哪儿来的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;other-exception-types&quot;&gt;Other Exception Types&lt;/h4&gt;
&lt;p&gt;有些report可能出现无名的&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Type&lt;/code&gt;，取而代之出现的是16进制的地址(0x12387617823)，下面列举一些&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xbaaaaaad&lt;/code&gt;: 则说明此条logs是系统堆栈快照，并非crash report。可以通过同时按（手机）侧边按钮和音量键来记录堆栈快照。通常情况下，这些logs是用户无意中生成的，并非表示错误。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xbad22222&lt;/code&gt;: 表示一个VoIP应用因为频繁暂停被iOS系统终止掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x8badf00d&lt;/code&gt;:（读起来像badfood）则说明一个应用因为触发了看门狗机制被iOS系统终止掉，有可能是应用花了太长时间启动，终止，或者是响应系统事件。一种常见原因是在主线程上做网络同步逻辑。不论Thread0上（也就是主线程）想做什么（重要的事），都应该转移到后台线程，或者换一种方式触发，这样它才不会阻塞主线程。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xc00010ff&lt;/code&gt;: 则说明app因为环境过热（的事件）被iOS系统干掉了。这个也许是和发生crash的特定设备有关，或者是和它所在的环境有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xdead10cc&lt;/code&gt;: (读起来像deadlock)则说明一个应用被系统终止掉，原因是在应用挂起时拿到了文件锁或者sqlite数据库所长期不释放直到被冻结。如果你的app在挂起时拿到了文件锁或者sqlite数据库锁，它必须请求额外的后台执行时间(request additional background execution time )并在被挂起前完成解锁操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2bad45ec&lt;/code&gt;: 则说明app因为违规操作（安全违规）被iOS系统终止。终止描述会写：“进程被查到在安全模式进行非安全操作”，暗示app尝试在禁止屏幕绘制的时候绘制屏幕，例如当屏幕锁定时。用户可能会忽略这种异常，尤其当屏幕是关闭的或者当这种终止发生时正好锁屏。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS-Crash-%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS-Crash-%E5%88%86%E6%9E%90/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>视频秒开优化方案</title>
        <description>&lt;h3 id=&quot;前置metadata&quot;&gt;前置metadata：&lt;/h3&gt;
&lt;p&gt;需要获取文件的metadata，解析出文件的编码，帧率等信息后才能开始边下边播，所以尽量让metadata或 MOOV box在靠近文件头部的位置，保证播放器尽快播放&lt;/p&gt;

&lt;h3 id=&quot;选择合适的缓冲策略&quot;&gt;选择合适的缓冲策略：&lt;/h3&gt;
&lt;p&gt;AVPlayer的 automaticallyWaitsToMinimizeStalling属性就是尽量多缓存一段时间，保证播放过程中减少卡顿&lt;/p&gt;

&lt;h3 id=&quot;使用httpdns加快建连&quot;&gt;使用HTTPDNS加快建连：&lt;/h3&gt;
&lt;p&gt;获取最优的CDN节点地址，并每隔一段时间获取一次最佳CDN节点，准实时的保证使用最佳节点。&lt;/p&gt;

&lt;h3 id=&quot;提升cdn命中率&quot;&gt;提升CDN命中率：&lt;/h3&gt;
&lt;p&gt;减少CDN的资源部命中，减少回源，比如URL中减少随机性的值，增加匹配命中概率。&lt;/p&gt;

&lt;h3 id=&quot;域名解析&quot;&gt;域名解析：&lt;/h3&gt;
&lt;p&gt;使用HTTPDNS快速获取最佳CDN节点信息。&lt;/p&gt;

&lt;h3 id=&quot;socket-cache&quot;&gt;Socket cache:&lt;/h3&gt;
&lt;p&gt;TCP的数据收发都是在缓冲区中完成拼装，通过调整缓冲区的大小。设置太小，影响效率，设置太大， 会短时间吃掉带宽(根据带宽探测原理可知),通过ffmpeg提供的api可修改。&lt;/p&gt;

&lt;h3 id=&quot;探测buffer&quot;&gt;探测buffer:&lt;/h3&gt;
&lt;p&gt;一开始需要先读一段数据，再对数据进行探测，得到封装格式、分辨率等信息。这个buffer可以设置。&lt;/p&gt;

&lt;h3 id=&quot;格式探测&quot;&gt;格式探测：&lt;/h3&gt;
&lt;p&gt;播放端开始时会探测数据格式，根据自己支持的格式探测出一个分数，得到相应的格式，如果短视频格式确定，就可以减少不必要的探测类型。&lt;/p&gt;

&lt;h3 id=&quot;播放-buffer&quot;&gt;播放 buffer:&lt;/h3&gt;
&lt;p&gt;减少播放的缓冲，一般缓冲buffer会按照帧数设置，但是短视频可以减小这个数字，达到尽快解码播放。&lt;/p&gt;

&lt;h3 id=&quot;分辨率视频格式&quot;&gt;分辨率、视频格式：&lt;/h3&gt;
&lt;p&gt;一定程度降低分辨率，减小文件大小。使用HEVC格式。&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E8%A7%86%E9%A2%91%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E8%A7%86%E9%A2%91%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>网络优化策略</title>
        <description>&lt;h3 id=&quot;网络优化策略&quot;&gt;网络优化策略&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;NSCache缓存，Last-Modified, ETag&lt;/li&gt;
  &lt;li&gt;DNS解析&lt;/li&gt;
  &lt;li&gt;数据压缩，protobuf, WebP&lt;/li&gt;
  &lt;li&gt;失败重发，缓存请求有网发送&lt;/li&gt;
  &lt;li&gt;弱网下设置不同超时时间&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nscache缓存&quot;&gt;NSCache缓存&lt;/h4&gt;
&lt;p&gt;Get类似SQL查找，所以默认会缓存，Post是提交数据，类似UPDATE，所以不会缓存。
Last-Modified：资源最后修改时间，来判断是否过期
请求response中会包含该字段和时间，下次请求时加上if-Modified-since : xxxx， 如果资源无变化返回304 Not Changed。&lt;/p&gt;

&lt;p&gt;ETag:资源文件的hash值，与当前资源文件比对是否一致，不一致则返回新值，一致则不返回。&lt;/p&gt;

&lt;h4 id=&quot;dns解析&quot;&gt;DNS解析&lt;/h4&gt;
&lt;p&gt;使用HTTPDNS 解析域名，代替从localDNS获取IP。 当HTTPDNS解析失败时再走localDNS.
或者本地维护IP list，与HTTPDNS的结果做更新&lt;/p&gt;

&lt;h4 id=&quot;数据压缩&quot;&gt;数据压缩&lt;/h4&gt;
&lt;p&gt;webP图片格式比PNG和jpg 体积小，但是webP图片需要解析才能成为可用的jpg图片， app内解析肯定要花费一定的性能。
在wifi条件下，较大的图片直接使用png/jpg, 减少解析时间。  4G条件下，建议用webP,对流量比较友好&lt;/p&gt;

&lt;h4 id=&quot;失败重发&quot;&gt;失败重发&lt;/h4&gt;
&lt;p&gt;超时或失败的请求建立重发机制，待网络通畅后再次发送&lt;/p&gt;

&lt;h4 id=&quot;弱网下设置不同超时时间&quot;&gt;弱网下设置不同超时时间&lt;/h4&gt;
&lt;p&gt;不同网络状态下超时时间设置不同，例如4G只需要10秒，3G需要20秒，在超时后依然无法与服务端建立连接，可排查网络链路通畅性，例如使用HTTPDNS切换新的服务器站点，尝试连接。&lt;/p&gt;

&lt;h3 id=&quot;http2相比http1x的升级&quot;&gt;HTTP2相比HTTP1.x的升级：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP/2采用二进制格式传输数据 ，而不是1.x的文本格式。&lt;/li&gt;
  &lt;li&gt;对消息头进行压缩传输，节省消息头占用的流量。 1.x每次请求携带大量冗余头信息，浪费资源&lt;/li&gt;
  &lt;li&gt;多路复用，一个域名下的请求可以通过一个TCP连接并发完成，毕竟新开一个TCP连接都需要慢慢提升传输速度。 1.x虽然通过pipeline也能并发请求，但是多个请求之间响应会被阻塞。采用二进制分帧，数据流可以乱序发送，接收后可以重新组装。&lt;/li&gt;
  &lt;li&gt;server push， 服务端提前把资源推送给客户端&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>各iOS版本适配概要</title>
        <description>&lt;h3 id=&quot;ios9&quot;&gt;iOS9：&lt;/h3&gt;
&lt;p&gt;App Thinning: 包括slicing, bitcode都是在不同设备上打包不同的app版本，&lt;/p&gt;

&lt;h3 id=&quot;ios10&quot;&gt;iOS10:&lt;/h3&gt;
&lt;p&gt;UIRefreshControl: 原来只是TableViewController的属性，现在增加成 UIScrollView的属性。可以脱离controller使用
跳转到设置的方式：可以用 UIApplicationOpenSettingsURLString
UITableView和UICollectionView的 Pre-Feching 预加载和生命周期的优化，例如prepareForReuse方法比之前版本要提前，且是一个一个的加载，而不是之前的一行一行的加载，且会把滑出屏幕的cell保存一段时间，防止又滑回来导致重新走一遍cell的生命周期。
scroolview卡顿优化方式处理离屏渲染等方式，还可以使用pre fetch方式，子线程预加载数据来实现一定的性能提升&lt;/p&gt;

&lt;h3 id=&quot;ios11&quot;&gt;iOS11:&lt;/h3&gt;
&lt;p&gt;UIScrollView: 废弃了UIViewController的 automaticllyAdjustsScrollViewInsets属性，新增contentInsetAdjustmentBehavior,当超出安全区域时系统自动跳转safeAreaInsets。 进而影响adjustContentInset。&lt;/p&gt;

&lt;h3 id=&quot;ios12&quot;&gt;iOS12：&lt;/h3&gt;
&lt;p&gt;libc++替代 libstdc++&lt;/p&gt;

&lt;h3 id=&quot;ios13&quot;&gt;iOS13:&lt;/h3&gt;
&lt;p&gt;通过KVC调用一些私有API的导致crash, 例如testField的 _placeholderLabel,    UISearchbar的 _searchField，13新增searchTextField属性
DeviceToken格式变化了
必须支持 Sign with apple 
modalPresentationStyle 默认值13开始变为automatic, 之前都是fullscreen
DarkMode 
Xcode11新工程要支持Scene多屏， 低版本黑屏
UIWebView废弃
蓝牙权限需要申请&lt;/p&gt;

&lt;h3 id=&quot;ios14&quot;&gt;iOS14：&lt;/h3&gt;
&lt;p&gt;####隐私权限更新：
*1. 照片： 增加选择部分照片权限limited，建议使用PHPicker
*2. 通讯录: 不需要权限，可以给textfile设置contenttype，设为通讯录，这样键盘会自动提示，app无需处理
*3. 定位： 增加精确定位和模糊定位的开关
Mac 地址对随着连接不同wifi而变化，且24小时也会更新一次。之前mac地址不会变，目的是防止运营商对用户数据收集和追踪
IDFA 默认关闭用户追踪开关&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E5%90%84iOS%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D%E6%A6%82%E8%A6%81/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E5%90%84iOS%E7%89%88%E6%9C%AC%E9%80%82%E9%85%8D%E6%A6%82%E8%A6%81/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS 组件化方案选型</title>
        <description>&lt;h2 id=&quot;一组件化概念&quot;&gt;一、组件化概念&lt;/h2&gt;
&lt;h3 id=&quot;11项目状态&quot;&gt;1.1、项目状态&lt;/h3&gt;
&lt;p&gt;各模块直接调用，耦合严重。业务模块间划分不清晰，相互引用，模块之间耦合度很大，非常难维护。
所有模块代码都编写在一个项目中，测试某个模块或功能，需要编译运行整个项目，不能独立运行。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024733598436.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12解决方案&quot;&gt;1.2、解决方案&lt;/h3&gt;
&lt;p&gt;所有的模块间的调用都会经过中间层中转(参考Router)，但是发现增加这个中间层后，耦合还是存在的。
中间层对被调用模块存在耦合，其他模块也需要耦合中间层才能发起调用。这样还是存在之前的相互耦合的问题，虽然可解决了统一调用的问题，而且本质上比之前更麻烦了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734216154.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;13正确的组件化解耦&quot;&gt;1.3、正确的组件化解耦&lt;/h3&gt;
&lt;p&gt;正确的解耦应该是，只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合。
对于这个问题，可以采用组件化的架构，将每个模块作为一个组件。并且建立一个主项目，这个主项目负责集成所有组件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734534438.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二组件化主流方案&quot;&gt;二、组件化主流方案&lt;/h2&gt;
&lt;h3 id=&quot;21url-block-代表蘑菇街组件化方案mgjrouter&quot;&gt;2.1、url-block (代表：蘑菇街组件化方案MGJRouter)&lt;/h3&gt;
&lt;p&gt;蘑菇街通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MGJRouter&lt;/code&gt;实现中间层，通过MGJRouter进行组件间的消息转发，从名字上来说更像是路由器。实现方式大致是，在提供服务的组件中提前注册block，然后在调用方组件中通过URL调用block，下面是调用方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;架构设计
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734970626.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MGJRouter组件化架构
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024735173869.png&quot; style=&quot;zoom=20%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MGJRouter是一个单例对象，在其内部维护着一个“URL -&amp;gt; block”格式的注册表，通过这个注册表来保存服务方注册的block，以及使调用方可以通过URL映射出block，并通过MGJRouter对服务方发起调用。&lt;/li&gt;
  &lt;li&gt;在程序开始运行时，需要将所有服务方的接口类实例化，以完成这个注册工作，使MGJRouter中所有服务方的block可以正常提供服务。在这个服务注册完成后，就可以被调用方调起并提供服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 、MGJRouter调用，代码模拟对详情页的注册、调用，在调用过程中传递id参数。下面是注册的示例代码。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter registerURLPattern:@&quot;mgj://detail?id=id&quot; toHandler:^(NSDictionary *routerParameters) {
// 下面可以在拿到参数后，为其他组件提供对应的服务
NSString uid = routerParameters[@&quot;id&quot;];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.1.2、通过openURL:方法传入的URL参数，对详情页已经注册的block方法发起调用。调用方式类似于GET请求，URL地址后面拼接参数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter openURL:@&quot;mgj://detail?id=404&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.1.3、也可以通过字典方式传参，MGJRouter提供了带有字典参数的方法，这样就可以传递非字符串之外的其他类型参数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter openURL:@&quot;mgj://detail?&quot; withParam:@{@&quot;id&quot; : @&quot;404&quot;}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;短链管理这时候会发现一个问题，在蘑菇街组件化架构中，存在了很多硬编码的URL和参数。&lt;/li&gt;
  &lt;li&gt;在代码实现过程中URL编写出错会导致调用失败，而且参数是一个字典类型，调用方不知道服务方需要哪些参数，这些都是个问题。&lt;/li&gt;
  &lt;li&gt;对于这些数据的管理，蘑菇街开发了一个web页面，这个web页面统一来管理所有的URL和参数，Android和iOS都使用这一套URL，可以保持统一性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22protocol方案代表阿里的beehive&quot;&gt;2.2、Protocol方案(代表：阿里的BeeHive)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;面向接口调用，我们知道只要直接引用代码，就会有依赖，比如：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// A 模块
- (void)getSomeDataFromB {
B.getSomeData();
}
// B 模块
- (void)getSomeData {
return self.data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;那么我们可以实现一个 getSomeDataFromB 的接口，让 A 只依赖这个接口，而 B 来实现这个接口，这样就实现了 A 与 B 的解耦。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 接口
@protocol BService &amp;lt;NSObject&amp;gt;
- (void)getSomeData;
@end
// A 模块, 只依赖接口
- (void)getSomeDataFromB {
id b = findService(@protocol(BService));
b.getSomeData;
}
// B 模块，实现BService接口
@interface B : NSObject &amp;lt;BService&amp;gt;
- (void)getSomeData {
return self.data;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就可以实现了即满足了模块之间调用，也实现了解耦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口类似代码，可以非常灵活的定义函数和回调等。&lt;/li&gt;
  &lt;li&gt;解决了硬编码的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。&lt;/li&gt;
  &lt;li&gt;使用较为麻烦，每个调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;BeeHive框架&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Module负责管理模块的注册和释放&lt;/li&gt;
  &lt;li&gt;Protocol负责公开组件开放的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024736500731.jpg&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优势：扩展组件的生命周期，大厂开源 注意：BeeHive采用GPL开源协议，若有修改，不允许私有化，必须开源分享。&lt;/p&gt;

&lt;h3 id=&quot;23target-action方案casatwy组件化方案&quot;&gt;2.3、Target-Action方案(casatwy组件化方案)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.3.1、调用方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整体架构casatwy组件化方案分为两种调用方式，远程调用和本地调用，对于两个不同的调用方式分别对应两个接口。&lt;/li&gt;
  &lt;li&gt;远程调用通过AppDelegate代理方法传递到当前应用后，调用远程接口并在内部做一些处理，处理完成后会在远程接口内部调用本地接口，以实现本地调用为远程调用服务。&lt;/li&gt;
  &lt;li&gt;本地调用由performTarget:action:params:方法负责，但调用方一般不直接调用performTarget:方法。CTMediator会对外提供明确参数和方法名的方法，在方法内部调用performTarget:方法和参数的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.3.2、架构设计思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;casatwy是通过CTMediator类实现组件化的，在此类中对外提供明确参数类型的接口，接口内部通过performTarget方法调用服务方组件的Target、Action。&lt;/li&gt;
  &lt;li&gt;由于CTMediator类的调用是通过runtime主动发现服务的，所以服务方对此类是完全解耦的。&lt;/li&gt;
  &lt;li&gt;但如果CTMediator类对外提供的方法都放在此类中，将会对CTMediator造成极大的负担和代码量。&lt;/li&gt;
  &lt;li&gt;解决方法就是对每个服务方组件创建一个CTMediator的Category，并将对服务方的performTarget调用放在对应的Category中，这些Category都属于CTMediator中间件，从而实现了感官上的接口分离。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.3.3、casatwy组件化实现细节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于服务方的组件来说，每个组件都提供一个或多个Target类，在Target类中声明Action方法。&lt;/li&gt;
  &lt;li&gt;Target类是当前组件对外提供的一个“服务类”，Target将当前组件中所有的服务都定义在里面，CTMediator通过runtime主动发现服务。&lt;/li&gt;
  &lt;li&gt;在Target中的所有Action方法，都只有一个字典参数，所以可以传递的参数很灵活，这也是casatwy提出的去Model化的概念。&lt;/li&gt;
  &lt;li&gt;在Action的方法实现中，对传进来的字典参数进行解析，再调用组件内部的类和方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三组件化方案对比&quot;&gt;三、组件化方案对比&lt;/h2&gt;
&lt;h3 id=&quot;31url-block方式&quot;&gt;3.1、url-block方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;硬编码问题，每个组件参数调用都需要查找对应。蘑菇街为此开发了一个web页面，这个web页面统一来管理所有的URL和参数。&lt;/li&gt;
  &lt;li&gt;需要在内存中维护url-block的表，组件多了可能会有内存问题。&lt;/li&gt;
  &lt;li&gt;url的参数传递受到限制，只能传递常规的字符串参数，无法传递非常规参数，如UIImage、NSData等类型。&lt;/li&gt;
  &lt;li&gt;没有区分本地调用和远程调用的情况，尤其是远程调用，会因为url参数受限，导致一些功能受限。&lt;/li&gt;
  &lt;li&gt;组件本身依赖了中间件，且分散注册使的耦合较多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32protocol方案&quot;&gt;3.2、Protocol方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;0硬编码，代码可读性高;&lt;/li&gt;
  &lt;li&gt;Protocol方案需要在启动的时候向ProtocolManager注册，侵入较大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33target_action方案&quot;&gt;3.3、Target_Action方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;侵入最小，但硬编码较多。&lt;/li&gt;
  &lt;li&gt;runtime编译阶段不检查,运行时才检查对应类或者方法是否存在，对开发要求较高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四组件化实现原则&quot;&gt;四、组件化实现原则&lt;/h2&gt;
&lt;h3 id=&quot;41抽象化原则&quot;&gt;4.1、抽象化原则&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;越底层的模块，应该越稳定，越抽象，越具有高复用度。&lt;/li&gt;
  &lt;li&gt;稳定的最直观表现就是API很久都不用变化，所有的变化因子不要暴露出来，避免传递给依赖它的模块。&lt;/li&gt;
  &lt;li&gt;但是要做到设计一套API很久都不用改变，那么就需要设计的时候能越抽象, 即需要我们抽象总结的能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42稳定性原则&quot;&gt;4.2、稳定性原则&lt;/h3&gt;
&lt;p&gt;不要让稳定的模块依赖不稳定的模块， 减少依赖，稳定性 还有一个特点就是会传递，比如 B 模块依赖了 A 模块，如果 B 模块很稳定，但是 A 模块不稳定，那么B模块也会变的不稳定了。&lt;/p&gt;

&lt;h3 id=&quot;43自备性完整&quot;&gt;4.3、自备性完整&lt;/h3&gt;
&lt;p&gt;提升模块的复用度，自完备性有时候要优于代码复用；什么是自完备性，就是尽可能的依赖少的模块来达到代码可复用；我有个模块 Utils 里面放了大量的category工具方法等，在日常UI产品开发中，依赖这个Utils会很方便，但是我现在要写一个比较基础的模块，应该就要求复用度更高一些，这个时候需要用到Utils里面的几个方法，那这个时候还适合直接依赖Utils吗，当然不合适了，这与我们上面的设计原则相悖了啊，因此我们这时候为了这个模块的自完备性，就可以重新实现下这几个方法，而不是依赖Utils模块。&lt;/p&gt;

&lt;h3 id=&quot;44不要让common出现&quot;&gt;4.4、不要让Common出现&lt;/h3&gt;
&lt;p&gt;每个模块只做好一件事情，不要让Common出现，按照你架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合。&lt;/p&gt;

&lt;h3 id=&quot;45业务模块真正解耦&quot;&gt;4.5、业务模块真正解耦&lt;/h3&gt;
&lt;p&gt;为什么要解耦吧，模块化并不是说你把工程的代码拆分成 50 个 pod 或者framework就算完事了，要实现模块之间真正的解耦才算真正的模块化，否则如果模块之间还都是互相调用代码，循环依赖，那么和原本放文件夹里面没啥两样。那么什么是模块间的解耦呢？模块解耦的目标就是, 在基于模块设计原则上, 让模块之间没有循环依赖, 让业务模块之间解除依赖。&lt;/p&gt;

&lt;h3 id=&quot;46单向依赖&quot;&gt;4.6、单向依赖&lt;/h3&gt;
&lt;p&gt;基础模块下沉，这块其实还是讲的模块设计，一个工程的架构可能会分为很多层，然而在开发的过程中，很容易有人不注意让应该处于较底层的模块依赖了上层的模块，这种情况下应该对模块的设计进行改造实现单向依赖。&lt;/p&gt;

&lt;h2 id=&quot;五组件化具体实施步骤&quot;&gt;五、组件化具体实施步骤&lt;/h2&gt;
&lt;h3 id=&quot;51组件化第一步剥离产品公共库和基础库&quot;&gt;5.1、组件化第一步，剥离产品公共库和基础库&lt;/h3&gt;
&lt;p&gt;包括组件中间件，网络请求，第三方SDK管理封装，WebView(封装js，且以服务形式提供)，自定义键盘，UI基础组件，分类。然后在项目里用pod进行管理。其中，针对三方库，最好再封装一层，使我们的项目不直接依赖三方库，方便后续开发过程中的更换。&lt;/p&gt;

&lt;h3 id=&quot;52组件化第二步独立业务模块单独成库&quot;&gt;5.2、组件化第二步，独立业务模块单独成库&lt;/h3&gt;
&lt;p&gt;拆分粒度可以先粗后细，将相对独立的组件拆分出来。在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。&lt;/p&gt;

&lt;h3 id=&quot;53组件化第三步对外服务最小化&quot;&gt;5.3、组件化第三步，对外服务最小化&lt;/h3&gt;
&lt;p&gt;在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(8)- 性能优化</title>
        <description>&lt;h3 id=&quot;减少卡顿&quot;&gt;减少卡顿&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;尽量减少视图数量和层次&lt;/li&gt;
  &lt;li&gt;减少透明的视图&lt;/li&gt;
  &lt;li&gt;尽量避免出现离屏渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;离屏渲染&quot;&gt;离屏渲染&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。
如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;GPU离屏渲染：采用画家算法，把每一层依次输出到画布，如果父layer剪裁成圆角，容器子layer因为父容器有圆角，也要被剪裁，但这时还在渲染队列中，此时需要在新内存中，把容器以及子layer依次画好，剪裁完成，再放到&lt;code class=&quot;highlighter-rouge&quot;&gt;frame buffer&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&quot;消耗性能原因&quot;&gt;消耗性能原因&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要创建新的缓冲区&lt;/li&gt;
  &lt;li&gt;整个过程需要多次切换上下文环境，从&lt;code class=&quot;highlighter-rouge&quot;&gt;on-screen&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;off-screen&lt;/code&gt;，等渲染结束后，将离屏缓冲区结果显示到屏幕上，再讲上下文从&lt;code class=&quot;highlighter-rouge&quot;&gt;off-screen&lt;/code&gt;切换到&lt;code class=&quot;highlighter-rouge&quot;&gt;on-screen&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;哪些会触发离屏渲染&quot;&gt;哪些会触发离屏渲染&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;光栅化   &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shouldRasterize= YES&lt;/code&gt;。 隐式的创建一个位图，各种阴影遮罩效果保存在位图中缓存，如果对应的layer极其sublayers没有发生改变，在下一帧的时候可以直接复用，减少渲染频率。但是否有助于优化性能取决于缓存的位图是否被有效复用。&lt;/li&gt;
  &lt;li&gt;遮罩   &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.mask&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圆角   同时设置&lt;code class=&quot;highlighter-rouge&quot;&gt;layer.maskToBounds = YES&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.cornerRadius &amp;gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;阴影 &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shadowoffset...&lt;/code&gt;,    但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shadowPath&lt;/code&gt;不会产生离屏渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;卡顿检测&quot;&gt;卡顿检测&lt;/h3&gt;
&lt;p&gt;通过使用监听 runloop的状态切换的耗时达到监控卡顿的目的&lt;/p&gt;

&lt;h3 id=&quot;app启动优化&quot;&gt;APP启动优化&lt;/h3&gt;
&lt;p&gt;启动分为3大阶段&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyld(dynamic link editor)&lt;/code&gt; 动态链接，装在Mach-O文件
    &lt;ul&gt;
      &lt;li&gt;装在APP可执行文件，递归加载所有依赖的动态库&lt;/li&gt;
      &lt;li&gt;都完毕后，通知runtime进行下一步处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;map_images&lt;/code&gt; 进行执行文件内容的解析和处理&lt;/li&gt;
      &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;load_images&lt;/code&gt;中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;call_load_methods&lt;/code&gt;， 调用所有class和&lt;code class=&quot;highlighter-rouge&quot;&gt;category&lt;/code&gt;的 &lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;方法&lt;/li&gt;
      &lt;li&gt;进行objc结构初始化，注册类，初始化对象等&lt;/li&gt;
      &lt;li&gt;可执行文件和动态库中所有符号Class,Protocol, Selctor, IMP 都已经加载完成&lt;/li&gt;
      &lt;li&gt;调用Main函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationMain&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;didFinishLaunchingWithOptions&lt;/code&gt;方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化方案：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyld&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;减少动态库，合并动态库&lt;/li&gt;
      &lt;li&gt;减少Objc类，分类的数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;+initialize&lt;/code&gt;方法和dispath_once代替+load方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;按需加载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细优化方案见&lt;a href=&quot;https://byronjia.github.io/2020/09/iOS-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/&quot;&gt;iOS 应用启动耗时分析及优化&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(8)-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(8)-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(7)- 内存管理</title>
        <description>&lt;h2 id=&quot;浅拷贝和深拷贝&quot;&gt;浅拷贝和深拷贝&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;拷贝的最终目的是产生一个副本，修改副本不会对原对象产生影响。故到底是深拷贝还是浅拷贝要根据这个规则来判断。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;[任意对象 copy] 产生一个不可变对象，如果原对象是不可变对象，那么就是浅拷贝，因为不可变对象本身就不能修改，所以没必要创新分配内存。原对象是可变对象，就是深拷贝。&lt;/li&gt;
  &lt;li&gt;[任意对象 mutableCopy] 产生一个可变对象，不论原对象是否是可变对象，都是深拷贝，因为要产生修改不影响原对象的副本，必须重新分配内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208497217.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;定义属性时使用copy修饰词，目的是在赋值之后产生一个不可变对象，那么在修改外部变量的时候不影响内部，例如UI控件的text都是copy修饰，防止外部修改影响内部实现。&lt;/p&gt;

&lt;h2 id=&quot;cadisplaylink-和-nstimer使用问题&quot;&gt;CADisplayLink 和 NSTimer使用问题&lt;/h2&gt;
&lt;p&gt;会对target 强引用，如果target也强引用他们，就发生循环引用问题
解决方法是使用NSProxy，是和NSObject同一级别的基类，但是没有实现和声明多余的方法，只有alloc等。
作用是只要方法列表里找不到方法，跳过动态方法解析，直接做转发。且NXProxy中弱引用target即可。&lt;/p&gt;

&lt;h2 id=&quot;内存布局&quot;&gt;内存布局&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208614585.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tagged-pointer&quot;&gt;Tagged Pointer&lt;/h2&gt;
&lt;p&gt;从64位开始引入，目的是优化NSNumber, NSDate， NSString等小对象的存储，提高内存使用率&lt;br /&gt;
原来NSNumber占用一个对象的空间，指针还指向堆地址的值，最终可能只是为了存一个3。 就浪费很大空间&lt;/p&gt;

&lt;p&gt;在使用Tagged pointer技术后，NSNumber 3的地址0x327, Tag+Data 的形式存储，从地址就能读到真实值，不需要额外空间。当内存地址长度超过64位后，才使用动态分配内存的方式存储数据。&lt;/p&gt;

&lt;p&gt;如果地址最低有效位是1， 则是Tagged pointer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ： 字符串想要使用tagged pointer, 初始化要用&lt;code class=&quot;highlighter-rouge&quot;&gt;[NSString stringWithFormat:]&lt;/code&gt;，如果是@”xx”创建的是常规对象存在常量区。&lt;/p&gt;
&lt;h2 id=&quot;引用计数管理&quot;&gt;引用计数管理&lt;/h2&gt;
&lt;p&gt;新建OC对象引用计数默认是1，当调用alloc,new,copy,mutableCopy时对象引用计数会+1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引用计数存储&lt;/strong&gt;：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208775066.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在64位优化后的isa共用体结构中，引用计数=extra_rc + sidetable_rc.refcnts[self].count,不是每个对象都会使用sidetable_rc,要看isa的标志位has_sidetable_rc.  &lt;br /&gt;
如果isa不是共用体结构，引用计数=sidetable_rc.refcnts[self].count
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208883784.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;refcnts是一个散列表，使用对象的地址为key,value为引用计数。
获取引用计数、retain、release操作都是获取extra_rc的值+sidetable的值+1或-1. 如果是release则判断是否为0，为0就dealloc。&lt;/p&gt;

&lt;h2 id=&quot;weak-指针原理&quot;&gt;weak 指针原理&lt;/h2&gt;
&lt;p&gt;__weak: 弱引用对象，当对象销毁时指针置为空&lt;br /&gt;
__unsafe_unretain: 弱引用对象，当对象销毁时，指针不变，使用会发生坏内存访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;weak能在对象销毁置为空的原理：&lt;/strong&gt;
当自动调用dealloc方法时，判断是否有弱引用和&lt;code class=&quot;highlighter-rouge&quot;&gt;sidetable_rc&lt;/code&gt;,（弱引用和超过计数器时都使用到了sidetable），有弱引用就将sidetable中自己对应的value取出来，得到一个__weak对象的地址集合(不确定是不是数组，因为用到C++的遍历器)， 并遍历将其置为nil
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209058628.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h2&gt;
&lt;p&gt;主要通过AutoreleasePoolPage来管理，结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209189251.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在@autoreleasePool代码开始时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoreleasePoolPage&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;方法，将&lt;code class=&quot;highlighter-rouge&quot;&gt;BOUNDARY&lt;/code&gt; 添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，标记为开始，后续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;的对象也会添加到该&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，在括号结束时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;方法时传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;的内存地址，会从最后一个入栈的对象开始发送&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;消息，直到遇到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象释放时机&quot;&gt;对象释放时机&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MRC&lt;/strong&gt;: 对象创建时调用了autorelease方法   &lt;br /&gt;
系统在主线程的Runloop中注册了2个Observer,1个监听kCFRunLoopEntry时间，调用objc_autoreleasePoolPush()。另一个监听kCFRunLoopBeforeWaiting事件，调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()。
监听kCFRunLoopBeforeExit事件调用objc_autoreleasePoolPop() &lt;br /&gt;
例如：viewdidload和viewwillappear 在一个loop中，即一次执行所有的block和sources，直到执行完毕loop睡眠，在睡眠之前会释放对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARC&lt;/strong&gt;:
在括号结束时，LLVM编译器自动给对象release一次，而不是在runloop中执行。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(6)- runLoop &amp; 多线程</title>
        <description>&lt;h2 id=&quot;runloop&quot;&gt;runloop&lt;/h2&gt;
&lt;h3 id=&quot;常见类型&quot;&gt;常见类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;runloop&lt;/strong&gt; 和线程一一对应，子线程默认不开启runloop,当第一次获取runloop时就会创建runloop。存在全局map中，key是线程，value是runloop&lt;/p&gt;

&lt;p&gt;runloopModel结构体如下
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023184791593.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见2种Mode:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kCFRunLoopDefaultMode&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDefaultRunLoopMode&lt;/code&gt;）：App的默认Mode，通常主线程是在这个Mode下运行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UITrackingRunLoopMode&lt;/code&gt;：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目的是不同组的&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;能分隔开来，互不影响，处理不同的事件，只能同一时间运行一种模式&lt;/p&gt;

&lt;h3 id=&quot;线程保活&quot;&gt;线程保活&lt;/h3&gt;

&lt;p&gt;一般线程启动后，如果事情做完会直接销毁，因为启动runloop 如果Mode里没有任何&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;，RunLoop会立马退出。 唯一办法是在runloop中添加前面所说的几个事件。
做法：
在当前线程中调用以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init]   forMode:NSDefaultRunLoopMode];
while (1){
    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样添加一个port的 &lt;code class=&quot;highlighter-rouge&quot;&gt;source1&lt;/code&gt; 事件，并启动本次runMode, 一旦响应一次事件后本次会结束，所以需要while 运行runModel 。其实就是阻塞了当前runloop的一个事件，导致后续事件无法运行，以此保证runloop和线程的存活&lt;/p&gt;

&lt;h2 id=&quot;多线程&quot;&gt;多线程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185008204.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;线程死锁&quot;&gt;线程死锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁)&lt;/strong&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector:withObject:afterDelay: &lt;/code&gt;方法是用你NSTimer实现定时，且是加在当前线程runloop中，但是如果当前是&lt;code class=&quot;highlighter-rouge&quot;&gt;asyn&lt;/code&gt;产生的线程runloop没启动的话这种方法无效。需要手动启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;线程锁&quot;&gt;线程锁&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt; 自旋锁，一直处于忙等状态&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;os_unfair_lock&lt;/code&gt; 互斥锁，等待锁的线程处于休眠状态，节省资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185133777.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt; 互斥锁，等待锁的线程处于休眠状态
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185345005.jpg&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;的条件锁
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185451423.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;  对于pthread_mutex的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSRecursiveLock&lt;/code&gt;  对于pthread_mutex的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;  对于pthread_mutex 和 condition的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue(DISPATCH_QUEUE_SERIAL)&lt;/code&gt; 把不同线程的任务放在同步队列中执行，能达到锁的效果&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt; 信号量， 初始化赋一个最多同时执行线程数量，如果是1就实现了锁的效果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁都是由于不同线程的问题导致的，如果条件锁在一个线程有wait，没有其他线程signal,就会永远睡眠下去。wait后的代码不会执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队列和线程是2个概念，队列中的任务可以在不同的线程中去执行。例如用globalQueue来创建不同的线程任务，所以可以使用串行队列来实现线程锁的问题，只要保证任务都加入到队列中执行即可&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;atomic 用于保证setter、 getter的操作原子性，在方法内部加上线程同步锁&lt;/p&gt;

&lt;h3 id=&quot;读写安全方案-保证同一时间只有一个线程写可以多个线程读不能同时读写&quot;&gt;读写安全方案 ,保证同一时间只有一个线程写，可以多个线程读，不能同时读写&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_rwlock&lt;/code&gt; 读写锁&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt; 异步栅栏调用
  &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_asyn(que)&lt;/code&gt; 用于读操作
  &lt;code class=&quot;highlighter-rouge&quot;&gt;diapatch_barrier_async(que)&lt;/code&gt; 用于写操作，可以保证当前队列中只有栅栏中的任务在执行，其他全部暂停。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uievent-uitouch-uiresponder-和-uicontrol&quot;&gt;UIEvent 、UITouch 、UIResponder 和 UIControl&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;触摸事件的传递：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;电容屏幕检测到电流变化，定位得到触摸点，生成&lt;code class=&quot;highlighter-rouge&quot;&gt;Touch Event&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IOKit.framework&lt;/code&gt;处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Touch Event&lt;/code&gt;,并封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;IOHIDEvent&lt;/code&gt;对象，通过内核的&lt;code class=&quot;highlighter-rouge&quot;&gt;mach port&lt;/code&gt;机制，传递为window上当前app的主线程&lt;/li&gt;
  &lt;li&gt;app主线程&lt;code class=&quot;highlighter-rouge&quot;&gt;runloop&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mach port&lt;/code&gt;监听的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;IOHIDEvent&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;事件，内部进一步分发为&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;，Source0事件是自定义的，非基于端口port,包括触摸，滚动，selector事件，并封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;UIEvent&lt;/code&gt;事件， 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication&lt;/code&gt;对象&lt;code class=&quot;highlighter-rouge&quot;&gt;sendEvent&lt;/code&gt;方法传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt;判断最佳响应者&lt;/li&gt;
  &lt;li&gt;Hit-Testing寻找最佳响应者，自下而上传递，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication -&amp;gt; UIWindow -&amp;gt; 子视图 -&amp;gt; ...-&amp;gt;子视图中的子视图&lt;/code&gt;;即响应链&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;UIEvent&lt;/strong&gt;: 代表一个单一类型的UIKit事件，可以是触摸，震动，按压等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UITouch&lt;/strong&gt;:一次触摸生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;UITouch&lt;/code&gt;,例如滑动由多个&lt;code class=&quot;highlighter-rouge&quot;&gt;UITouch&lt;/code&gt;组合，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;UIEvent&lt;/code&gt;里包含多个触摸对象，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;allTouches&lt;/code&gt;获取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UIResponder&lt;/strong&gt;: 继承&lt;code class=&quot;highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;的实例对象可以对随机事件进行相应处理,例如&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationDelegate&lt;/code&gt;, 默认实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesBegin&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesMove&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesEnded&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesCancelled&lt;/code&gt;四个方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UIControl&lt;/strong&gt;:继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;, 能够以&lt;code class=&quot;highlighter-rouge&quot;&gt;target-action&lt;/code&gt;模式处理触摸事件，有&lt;code class=&quot;highlighter-rouge&quot;&gt;addTarget:action:forControlEvent:&lt;/code&gt;方法，保存&lt;code class=&quot;highlighter-rouge&quot;&gt;target-action&lt;/code&gt;到字典中，在接收到相应Event事件时取出对应action执行。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(6)runLoop-&-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(6)runLoop-&-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(5)-Block</title>
        <description>&lt;h2 id=&quot;block本质&quot;&gt;Block本质&lt;/h2&gt;
&lt;p&gt;本质是一个OC对象，编译之后是一个结构体包含isa指针，block中封装了调用的函数和调用环境。调用环境值&lt;code class=&quot;highlighter-rouge&quot;&gt;variables&lt;/code&gt;是block捕获的变量(如果block中访问了一些需要被捕获的变量，例如局部变量)
block的变量捕获机制：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;局部变量， &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;临时变量会捕获到block内部，且用的值传递。&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 会捕获，用的指针传递。&lt;/li&gt;
  &lt;li&gt;全局变量，不会捕获，block运行的时候会直接访问&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;auto临时变量代表 autorelease的在一个作用域内的临时变量&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098593774.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中FuncPtr指的block函数的指针。 
block分为3种类型，分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSGlobalBlock__&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSStackBlock__&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSMallocBlock__&lt;/code&gt;，分为位于以下内存区域，那么什么样的block会属于什么样的类型？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098896250.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098896265.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图表示不同的block因为操作的变量类型不一样，所以block类型也不一样。因为auto变量是临时变量会存在&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;中自动销毁，所以相应block就是&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;。没访问auto变量则存在常量区&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;为什么block用copy修饰&quot;&gt;为什么block用copy修饰？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;由于&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stackblock&lt;/code&gt;在栈中，且捕获的是在栈中的变量，如果变量销毁，有可能block访问的就的数据就是野指针，&lt;strong&gt;所以&lt;/strong&gt;需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;stackblock&lt;/code&gt;通过调用&lt;strong&gt;copy&lt;/strong&gt;方法转为&lt;code class=&quot;highlighter-rouge&quot;&gt;mallocblock&lt;/code&gt;即保存到堆中，保证由用户自己创建自己销毁，不会造成程序异常。所以block变量用&lt;strong&gt;copy&lt;/strong&gt;修饰或者直接调用&lt;strong&gt;copy&lt;/strong&gt;方法&lt;/p&gt;

&lt;h2 id=&quot;block如果捕获变量&quot;&gt;block如果捕获变量&lt;/h2&gt;
&lt;p&gt;当block内部访问了对象类型的auto变量时：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果block在栈上，则不会对auto变量强引用&lt;/li&gt;
  &lt;li&gt;如果block被拷贝到堆上：会调用block内部的copy函数（&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_object_assgin&lt;/code&gt;），会根据对象的修饰符__strong, __weak等作出强引用或弱引用&lt;/li&gt;
  &lt;li&gt;如果block从堆上移除：调用block内部dispose函数，对变量release&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;__block与__weak__strong&quot;&gt;__block与__weak、__strong&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt;修饰一个变量会把他包装成一个结构体对象，其中的一个属性就是这个变量。且这个结构体对象会把捕获的对象进行引用，根据对象前面是否使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;__strong&lt;/code&gt; 决定是弱引用还是强引用。
block中的&lt;code class=&quot;highlighter-rouge&quot;&gt;forwarding&lt;/code&gt;指针是指向自己位于堆中的地址，如果修饰的是对象，block中还会增加2个内存管理方法,&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dispose&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;__weak 和 __strong 目的是在变量被block捕获的时候以什么引用方式。&lt;/p&gt;

&lt;h2 id=&quot;循环引用问题&quot;&gt;循环引用问题：&lt;/h2&gt;
&lt;p&gt;对象 强引用 block; block  强引用  对象 导致无法释放， 解决办法是将其中一条链路变为弱引用，则能完成释放。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(5)-Block/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(5)-Block/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
