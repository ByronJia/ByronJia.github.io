<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 19 Sep 2020 09:34:42 +0800</pubDate>
    <lastBuildDate>Sat, 19 Sep 2020 09:34:42 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>iOS高级面试题(超全)</title>
        <description>&lt;h2 id=&quot;oc&quot;&gt;OC&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.Block&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Block的本质是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;block本质是对象，底层是用结构体struct实现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Block对应的数据结构是什么样子的？&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;struct Block_descriptor {
    unsigned long int reserved;
    unsigned long int size;
    void (*copy)(void *dst, void *src);
    void (*dispose)(void *);
};

struct Block_layout {
    void *isa;
    int flags;
    int reserved;
    void (*invoke)(void *, ...);
    struct Block_descriptor *descriptor;
    /* Imported variables. */
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;isa 指针，所有对象都有该指针，用于实现对象相关的功能。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flags，用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;reserved，保留变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;invoke，函数指针，指向具体的 block 实现的函数调用地址。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;descriptor， 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;variables，capture 过来的变量，block 能够访问它外部的局部变量，就是因为将这些变量（或变量的地址）复制到了结构体中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;__block的作用是什么？它对应的数据结构又是什么样子的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;__block的作用是让block可以捕获该变量，捕获之后的变量会进入到block内部，通过反编译的代码我们可以看到该对象是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;struct __Block_byref_i_0 {
    void *__isa;
    __Block_byref_i_0 *__forwarding;
    int __flags;
    int __size;
    int val; //变量名
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. GCD中的Block是在堆上还是栈上？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;堆上,可以通过block的isa指针确认。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. NSCoding协议是干什么用的？(初级)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一种编码协议，归档时和解档时需要依赖该协议定义的编码和解码方法。Foundation和Cocoa Touch中的大部分类都遵循了这个协议，一般被NSKeyedArchiver做自定义对象持久化时使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. KVO的实现原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;利用Runtime生成一个中间对象，让原对象的isa指针指向它，然后重写setter方法，插入willChangeValueForKey和didChangeValueForKey方法。当属性变化时会调用，会调用这两个方法通知到外界属性变化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. NSOperation有哪些特性比着GCD有哪些优点，它有哪些API？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;NSOperation是对GCD的封装，具有面向对象的特点，可以更方便的进行封装，可以设置依赖关系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. NSNotificaiton是同步还是异步的，如果发通知时在子线程，接收在哪个线程？&lt;/strong&gt;
同步。子线程。&lt;/p&gt;

&lt;h3 id=&quot;引用计数&quot;&gt;引用计数&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;ARC方案的原理是什么？它是在什么时候做的隐式添加release操作？
ARC(Automatic Reference Cunting)自动引用计数，意即通过LLVM编译器自动管理对应的引用计数状态。ARC开启时无需再次键入retain或者release代码。&lt;br /&gt;
它是在编译阶段添加retain或者release代码的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;循环引用有哪些场景，如何避免？(初级)
循环引用及两个及以上对象出现引用环，导致对象无法释放的情况。一般在block，delegate，NSTimer时容易出现这个问题。&lt;br /&gt;
解决方案就是让环的其中一环节实现弱引用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为什么当我们在使用block时外面是weak 声明一个weakSelf，还要在block内部使用strong再持有一下？（可扩展提问）
block外界声明weakSelf是为了实现block方法块内部对obj的弱持有避免循环引用，而里面的storng作用是为了保证在block内部时对象不会随意释放。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Autoreleasepool&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Autoreleasepool是实现机制是什么？&lt;br /&gt;
Autoreleasepool的原理是一个双向链表，它会对加入其中的对象实现延迟释放。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它是什么时候释放内部的对象的？&lt;br /&gt;
当Autoreleasepool调用drain方法时会释放内部标记为autorelease的对象。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;它内部的数据结构是什么样的？&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt; class AutoreleasePoolPage {
     magic_t const magic;
     id *next;
     pthread_t const thread;
     AutoreleasePoolPage * const parent;
     AutoreleasePoolPage *child;
     uint32_t const depth;
     uint32_t hiwat;
 };
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;哨兵对象的作用是什么，为什么要设计它？&lt;br /&gt;
 哨兵对象类似一个指针，指向自动释放池的栈顶位置，它的作用就是用于标记当前自动释放池需要释放内部对象时，释放到那个地方结束，每次入栈时它用于确定添加的位置，然后再次移动到栈顶。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;哪些对象会放入到Autoreleasepool中？&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;非alloc/new/copy/mutablecopy 开始的方式初始化时。&lt;/li&gt;
      &lt;li&gt;id的指针或对象的指针在没有显示指定时&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;weak的实现原理是什么？当引用对象销毁时它是如何管理内部的Hash表的？（这里要参阅weak源码）
 runTime会把对weak修饰的对象放到一个全局的哈希表中，用weak修饰的对象的内存地址为key，weak指针为值，在对象进行销毁时，用通过自身地址去哈希表中查找到所有指向此对象的weak指针，并把所有的weak指针置为nil。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;runtime&quot;&gt;Runtime&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.消息发送的流程是怎样的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OC中的方法调用会转化成给对象发送消息，发送消息会调用这个方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ObjectiveC&quot;&gt;objc_msgSend(receiver, @selector(message))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;该过程有以下关键步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;先确定调用方法的类已经都加载完毕，如果没加载完毕的话进行加载&lt;/li&gt;
  &lt;li&gt;从cache中查找方法&lt;/li&gt;
  &lt;li&gt;cache中没有找到对应的方法，则到方法列表中查，查到则缓存&lt;/li&gt;
  &lt;li&gt;如果本类中查询到没有结果，则遍历所有父类重复上面的查找过程，直到NSObject&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.关联对象时什么情况下会导致内存泄露？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;关联对象可以理解就是持有了一个对象，如果是retain等方式的持有，而该对象也持有了本类，那就是导致了循环引用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.消息转发的流程是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;消息转发是发生在接收者（receiver）没有找到对应的方法（method）的时候，该步骤有如下几个关键步骤：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;消息转发的时候，如果是实例方法会走resolveInstanceMethod:，如果是类方法会走resolveClassMethod:，它们的返回值都是Bool，需要我们确定是否进行转发。&lt;/li&gt;
  &lt;li&gt;如果第一步返回YES，确定转发就会进到下个方法forwardingTargetForSelector，这个方法需要我们指定一个被用receiver。&lt;/li&gt;
  &lt;li&gt;methodSignatureForSelector用于指定方法签名，forwardInvocation用于处理Invocation，进行完整转发。&lt;/li&gt;
  &lt;li&gt;如果消息转发也没有处理即为无法处理，会调用doesNotRecognizeSelector，引发崩溃。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4.category能否添加属性，为什么？能否添加实例变量，为什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以添加属性，这里的属性指@property，但跟类里的@property又不一样。类里的@property为：实例变量Ivar + Setter + Getter 方法，分类里的@property这三者都没有，需要我们手动实现。&lt;/p&gt;

&lt;p&gt;分类是运行时被编译的，这时类的结构已经固定了，所以我们无法添加实例变量。&lt;/p&gt;

&lt;p&gt;对于分类自定义Setter和Getter方法，我们可以通过关联对象（Associated Object）进行实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.元类的作用是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;元类的作用是存储类方法，同时它也是为了让OC的类结构能够形成闭环。&lt;/p&gt;

&lt;p&gt;对于为什么设计元类有以下原因；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在OC的世界里一切皆对象（借鉴于Smalltalk），metaclass的设计就是要为满足这一点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在OC中Class也是一种对象，它对应的类就是metaclass，metaclass也是一种对象，它的类是root metaclass，在往上根元类（root metaclass）指向自己，形成了一个闭环，一个完备的设计。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果不要metaclass可不可以？也是可以的，在objc_class再加一个类方法指针。但是这样的设计会将消息传递的过程复杂化，所以为了消息传递流程的复用，为了一切皆对象的思想，就有了metaclass。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.类方法是存储到什么地方的？类属性呢？&lt;/strong&gt; &lt;br /&gt;
    类方法和类属性都是存储到元类中的。&lt;/p&gt;

&lt;p&gt;类属性在Swift用的多些，OC中很少有人用到，但其实它也是有的，写法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ObjectiveC&quot;&gt;@interface Person : NSObject
// 在属性类别中加上class
@property (class, nonatomic, copy) NSString *name;
@end
// 调用方式
NSString *temp = Person.name;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要注意的是跟实例属性不一样，类属性不会自动生成实例变量和setter，getter方法，需要我们手动实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.讲几个runtime的应用场景&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hook系统方法进行方法交换。&lt;/li&gt;
  &lt;li&gt;了解一个类（闭源）的私有属性和方法。&lt;/li&gt;
  &lt;li&gt;关联对象，实现添加分类属性的功能。&lt;/li&gt;
  &lt;li&gt;修改isa指针，自定义KVO。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;runloop&quot;&gt;Runloop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.讲一下对Runloop的理解？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Runloop就是一个运行循环，它保证了在没有任务的时候线程不退出，有任务的时候即使响应。Runloop跟线程，事件响应，手势识别，页面更新，定时器都有着紧密联系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.可以用Runloop实现什么功能？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;检测卡顿&lt;/li&gt;
  &lt;li&gt;线程保活&lt;/li&gt;
  &lt;li&gt;性能优化，将一些耗时操作放到runloop wait的情况处理。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;kvc--kvo&quot;&gt;KVC &amp;amp; KVO&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1：谈谈你对KVC的理解&lt;/strong&gt;
KVC可以通过key直接访问对象的属性，或者给对象的属性赋值，这样可以在运行时动态的访问或修改对象的属性&lt;/p&gt;

&lt;p&gt;当调用 &lt;strong&gt;setValue：&lt;/strong&gt;属性值 forKey：@”name“ 的代码时，&lt;strong&gt;底层的执行机制如下&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;程序优先调用set&lt;Key&gt;:属性值方法，代码通过setter方法完成设置。注意，这里的&lt;key&gt;是指成员变量名，首字母大小写要符合KVC的命名规则，下同&lt;/key&gt;&lt;/Key&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没有找到 setName：方法，KVC机制会检查+ (BOOL)accessInstanceVariablesDirectly 方法有没有返回YES，默认该方法会返回YES，如果你重写了该方法让其返回NO的话，那么在这一步KVC会执行setValue：forUndefinedKey：方法，不过一般开发者不会这么做。所以KVC机制会搜索该类里面有没有名为&lt;key&gt;的成员变量，无论该变量是在类接口处定义，还是在类实现处定义，也无论用了什么样的访问修饰符，只在存在以&lt;key&gt;命名的变量，KVC都可以对该成员变量赋值。&lt;/key&gt;&lt;/key&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果该类即没有set&lt;key&gt;：方法，也没有_&lt;key&gt;成员变量，KVC机制会搜索_is&lt;Key&gt;的成员变量。&lt;/Key&gt;&lt;/key&gt;&lt;/key&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;和上面一样，如果该类即没有set：方法，也没有_和_is成员变量，KVC机制再会继续搜索和is的成员变量。再给它们赋值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果上面列出的方法或者成员变量都不存在，系统将会执行该对象的setValue：forUndefinedKey：方法，默认是抛出异常。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果想禁用KVC，重写+ (BOOL)accessInstanceVariablesDirectly方法让其返回NO即可，这样的话如果KVC没有找到 set&lt;Key&gt;: 属性名时，会直接用 setValue：forUndefinedKey：方法。&lt;/Key&gt;&lt;/p&gt;

&lt;p&gt;当调用 valueForKey：@”name“ 的代码时，KVC对key的搜索方式不同于setValue：属性值 forKey：@”name“，&lt;strong&gt;其搜索方式如下&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先按get&lt;Key&gt;,&lt;key&gt;,is&lt;Key&gt;的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象&lt;/Key&gt;&lt;/key&gt;&lt;/Key&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果上面的getter没有找到，KVC则会查找countOf&lt;Key&gt;,objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes格式的方法。如果countOf&lt;Key&gt;方法和另外两个方法中的一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，是NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf&lt;Key&gt;,objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes这几个方法组合的形式调用。还有一个可选的get&lt;Key&gt;:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果上面的方法没有找到，那么会同时查找 countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;,memberOf&lt;Key&gt; 格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以 countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;,memberOf&lt;Key&gt; 组合的形式调用。&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/Key&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果还没有找到，再检查类方法 + (BOOL)accessInstanceVariablesDirectly,如果返回 YES (默认行为)，那么和先前的设值一样，会按 _&lt;key&gt;,_is&lt;Key&gt;,&lt;key&gt;,is&lt;Key&gt; 的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法 + (BOOL)accessInstanceVariablesDirectly 返回 NO 的话，那么会直接调用 valueForUndefinedKey: 方法，默认是抛出异常&lt;/Key&gt;&lt;/key&gt;&lt;/Key&gt;&lt;/key&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;2.讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;atomic的实现机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;atomic是property的修饰词之一，表示是原子性的，使用方式为@property(atomic)int age;此时编译器会自动生成 getter/setter 方法，最终会调用objc_getProperty和objc_setProperty方法来进行存取属性。&lt;/p&gt;

&lt;p&gt;若此时属性用atomic修饰的话，在这两个方法内部使用os_unfair_lock 来进行加锁，来保证读写的原子性。锁都在PropertyLocks 中保存着（在iOS平台会初始化8个，mac平台64个），在用之前，会把锁都初始化好，在需要用到时，用对象的地址加上成员变量的偏移量为key，去PropertyLocks中去取。因此存取时用的是同一个锁，所以atomic能保证属性的存取时是线程安全的。&lt;/p&gt;

&lt;p&gt;注：由于锁是有限的，不用对象，不同属性的读取用的也可能是同一个锁&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;atomic为什么不能保证绝对的线程安全？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;atomic在getter/setter方法中加锁，仅保证了存取时的线程安全，假设我们的属性是@property(atomic)NSMutableArray *array;可变的容器时,无法保证对容器的修改是线程安全的.&lt;/p&gt;

&lt;p&gt;在编译器自动生产的getter/setter方法，最终会调用objc_getProperty和objc_setProperty方法存取属性，在此方法内部保证了读写时的线程安全的，当我们重写getter/setter方法时，就只能依靠自己在getter/setter中保证线程安全&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. setvalue和setobject的区别&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setObject:ForKey&lt;/code&gt;：是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSMutableDictionary&lt;/code&gt;特有的。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setValue:ForKey&lt;/code&gt;：是&lt;code class=&quot;highlighter-rouge&quot;&gt;KVC&lt;/code&gt;的主要方法。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setobject&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;key&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;可以为nil以外的任何对象。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;setValue&lt;/code&gt;中的key只能为字符串，value可以为&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;也可以为空对象&lt;code class=&quot;highlighter-rouge&quot;&gt;[NSNull null]&lt;/code&gt;以及全部对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性能优化&quot;&gt;性能优化&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.对TableView进行性能优化有哪些方式？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;缓存高度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;异步渲染&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;减少离屏渲染&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.Xcode的Instruments都有哪些调试的工具？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Activity Monitor（活动监视器）：监控进程的CPU、内存、磁盘、网络使用情况。是程序在手机运行真正占用内存大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Allocations（内存分配）：跟踪过程的匿名虚拟内存和堆的对象提供类名和可选保留/释放历史&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Core Animation（图形性能）：显示程序显卡性能以及CPU使用情况&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Core Data：跟踪Core Data文件系统活动&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Energy Log：耗电量监控&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;File Activity：检测文件创建、移动、变化、删除等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Leaks（泄漏）：一般的措施内存使用情况，检查泄漏的内存，并提供了所有活动的分配和泄漏模块的类对象分配统计信息以及内存地址历史记录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Network：用链接工具分析你的程序如何使用TCP/IP和UDP/IP链接&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;System Usage：记录关于文件读写，sockets，I/O系统活动，输入输出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Time Profiler（时间探查）：方法执行耗时分析&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Zombies：测量一般的内存使用，专注于检测过度释放的野指针对象。也提供对象分配统计以及主动分配的内存地址历史&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3.讲一下你做过的性能优化的事情。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.如何检测卡顿，都有哪些方法？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FPS，通过CADisplayLink计算1s内刷新次数，也可以利用Instruments里的Core Animation。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;利用Runloop，实时计算 kCFRunLoopBeforeSources 和 kCFRunLoopAfterWaiting 两个状态区域之间的耗时是否超过某个阀值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;子线程检测，每次检测时设置标记位为YES，然后派发任务到主线程中将标记位设置为NO。接着子线程沉睡超时阙值时长，判断标志位是否成功设置成NO，如果没有说明主线程发生了卡顿。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;5.缩小包体积有哪些方案？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;图片压缩，无用图片删除&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一些大图可以动态下发&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除无用类，无用方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;减少三方库的依赖&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.事件响应链是如何传递的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;手势的点击会发生两个重要事情，事件传递和事件响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件传递&lt;/strong&gt;：从UIApplication开始，到window，再逐步往下层（子视图）找，直到找到最深层的子视图，其为first responder。用到的判断方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;pointInside:withEvent&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hitTest:withEvent&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事件响应&lt;/strong&gt;：从识别到的视图（first responder）开始验证能否响应事件，如果不能就交给其上层（父视图）视图，如果能响应将不再往下传递，如果直到找到UIApplication层还没有响应，那就忽略该次点击。用到的判断方法是&lt;code class=&quot;highlighter-rouge&quot;&gt;touchesBegan:withEvent&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;touchesMoved:withEvent&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;这两个过程大致的相反的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.什么是异步渲染？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;异步渲染就是在子线程进行绘制，然后拿到主线程显示。&lt;/p&gt;

&lt;p&gt;UIView的显示是通过CALayer实现的，CALayer的显示则是通过contents进行的。异步渲染的实现原理是当我们改变UIView的frame时，会调用layer的setNeedsDisplay，然后调用layer的display方法。我们不能在非主线程将内容绘制到layer的context上，但我们单独开一个子线程通过CGBitmapContextCreateImage()绘制内容，绘制完成之后切回主线程，将内容赋值到contents上。&lt;/p&gt;

&lt;p&gt;这个步骤可以参照YYText中YYTextAsyncLayer.m[6]文件中的实现方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.layoutsubviews是在什么时机调用的？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;init初始化不会触发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;addSubview时。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置frame且前后值变化，frame为zero且不添加到指定视图不会触发。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;旋转Screen会触发父视图的layoutSubviews。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;滚动UIScrollView引起View重新布局时会触发layoutSubviews。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;4.一张图片的展示经历了哪些步骤？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.什么是离屏渲染，什么情况会导致离屏渲染？&lt;/strong&gt;
如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域。如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。
以阴影为例，为什么它会导致离屏渲染。因为GPU的渲染是遵循“画家算法”，一层一层绘制的，但阴影很特殊，它需要全部内容绘制完成，再根据外轮廓进行绘制。这就导致了，阴影这一层要一直占据一块内存区域，这就导致了离屏渲染。&lt;/p&gt;

&lt;p&gt;类似导致离屏渲染的情况还有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cornerRadius+clipsToBounds&lt;/li&gt;
  &lt;li&gt;group opacity 组透明度&lt;/li&gt;
  &lt;li&gt;mask 遮罩&lt;/li&gt;
  &lt;li&gt;UIBlurEffect 毛玻璃效果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;6.CoreAnimation这个框架的作用什么，它跟UIKit的关系是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CoreAnimation虽然直译是核心动画，但它其实是一个图像渲染框架，动画实现只是它的一部分功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200917/16003308335042.png&quot; alt=&quot;Core Animation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看这张图我们可以知道，它是UIKit和AppKit的底层实现，位于Metal、Core Graphics和GPU之上之上。&lt;/p&gt;

&lt;p&gt;苹果官方文档：About Core Animation[9]&lt;/p&gt;

&lt;h2 id=&quot;swift&quot;&gt;Swift&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;Swift中struct和class有什么区别？
struct是值引用，更轻量，存放于栈区，class是类型引用，存放于堆区。struct无法继承，class可继承。&lt;/li&gt;
  &lt;li&gt;Swift中的方法调用有哪些形式？
直接派发、函数表派发、消息机制派发。派发方式受声明位置，引用类型，特定行为的影响。为什么Swift有这么多派发形式？为了效率。&lt;/li&gt;
  &lt;li&gt;Swift和OC有什么区别？
Swift和OC的区别有很多，这里简要总结这几条：&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;Swift&lt;/th&gt;
      &lt;th&gt;Objective-C&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;语言特性&lt;/td&gt;
      &lt;td&gt;静态语言，更加安全&lt;/td&gt;
      &lt;td&gt;动态语言不那么安全&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;语法&lt;/td&gt;
      &lt;td&gt;更精简&lt;/td&gt;
      &lt;td&gt;冗长&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;命名空间&lt;/td&gt;
      &lt;td&gt;有&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;方法调用&lt;/td&gt;
      &lt;td&gt;直接调用，函数表调用，消息转发&lt;/td&gt;
      &lt;td&gt;消息转发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;泛型/元组/高阶函数&lt;/td&gt;
      &lt;td&gt;有&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;语言效率&lt;/td&gt;
      &lt;td&gt;性能更高，速度更快&lt;/td&gt;
      &lt;td&gt;略低&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;文件特性&lt;/td&gt;
      &lt;td&gt;.swift 单文件&lt;/td&gt;
      &lt;td&gt;.h/.m包含头文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;编程特性&lt;/td&gt;
      &lt;td&gt;可以更好的实现函数式编程/响应式编程&lt;/td&gt;
      &lt;td&gt;面向对象编程&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;怎么理解面向协议编程？
面向对象是以对象的视角观察整体结构，万物皆为对象。
面向协议则是用协议的方式组织各个类的关系，Swift底层几乎所有类都构建在协议之上。
面向协议能够解决面向对象的菱形继承，横切关注点和动态派发的安全性等问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;计算机相关&quot;&gt;计算机相关&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.项目编译的流程是什么？手机上的应用程序自点击图标开始到首屏内容展示都经历了哪些步骤？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编译流程：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;预处理：处理宏定义，删除注释，展开头文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;词法分析：把代码切成一个个token，比如大小括号等于号还有字符串&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;语法分析：验证语法是否正确，合成抽象语法树AST&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;静态分析：查找代码错误&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;类型检查：动态和静态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;目标代码的生成与优化，包括删除多余指令，选择合适的寻址方式，如果开启了bitcode，会做进一步的优化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;汇编：由汇编器生成汇编语言&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;机器码：由汇编语言转成机器码，生成.o文件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;应用启动的流程：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;启动的前提是完成编译，运行程序即运行编译过后的目标程序，它分为main函数前和main函数后：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;main前&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;加载可执行文件（App的.o文件集合）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加载动态链接库（系统和应用的动态链接库），进行rebase指针调整和bind符号绑定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Objc运行时的初始处理，包括Objc相关类的注册，category注册，selector唯一性检查&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;初始化，包括执行+load()、attribute(constructor)修饰的函数的调用、创建C++静态全局变量&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;main后&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首页初始化所需要配置文件的读写操作&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;首页界面渲染&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.对于基本数据类型，一般是存储到栈中的，它有没有可能存在堆上，什么情况下会存储到堆上？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;栈和堆都是同属一块内存，只不过一个是高地址往低地址存储，一个从低地址往高地址存储，他们并没有严格的界限说一个值只能放在堆上或者栈上。所以基本数据类型也是可以存储到堆上的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.数据库中的事务是什么意思？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事务就是访问并操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行。如果其中一个步骤出错就要撤销整个操作，回滚到进入事务之前的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.使用过什么数据库（我回答的Sqlite，Realm），Realm在使用时有哪些注意事项，如何实现批量操作？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Realm需要注意&lt;/strong&gt;的主要就是不能直接跨线程访问同一对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;批量操作&lt;/strong&gt;可以在一个单独的事务中执行多个数据库的修改。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.LRU算法是否了解，如何实现一套LRU算法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;LRU（Least recently used 最近最少使用）算法是一个缓存淘汰算法，其作用就是当缓存很多时，该淘汰哪些内容，见名知意，它的核心思想是淘汰最近使用最少的内容。实现它的关键步骤是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;新数据插入到链表的头部&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每当缓存命中时，则将数据移动到链表头部&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;链表满时，将尾部数据清除&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200917/16003308538183.png&quot; alt=&quot;LRU算法图解&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.知道哪些设计模式，怎么理解设计模式的作用？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;工厂模式、观察者模式、中介者模式、单例模式。这个根据实际情况说吧。
&lt;a href=&quot;https://github.com/huang303513/Design-Pattern-For-iOS&quot;&gt;设计模式&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.如果有1000万个Int类型的数字，如何对他们排序？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里的隐藏含义是，内存不够用时如何排序，还有一个隐藏含义是硬盘足够大。这是可以采用分而治之的方法，将数据分成若干块，使每一小块满足当前内容大小，然后对每块内容单独排序，最后采用归并排序对所有块进行排序，就得到了一个有序序列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.设计一套数据库方案，实现类似微信的搜索关键词能快速检索出包含该字符串的聊天信息，并展示对应数量（聊天记录的数据量较大）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以对聊天记录的文本值加上索引。正常情况下数据库搜索都是全量检索的，加上索引之后只会检索满足条件的记录，大大降低检索量。&lt;/p&gt;

&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.MVVM和MVC有什么区别？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MVC：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;M&lt;/strong&gt; 是数据模型&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;，负责处理数据，以及数据改变时发出通知(&lt;code class=&quot;highlighter-rouge&quot;&gt;Notification、KVO&lt;/code&gt;)，&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;不能直接进行通信，这样会违背MVC设计模式；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;V&lt;/strong&gt; 是视图&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;，用来展示界面，和用户进行交互，为了解耦合一般不会直接持有 或者 操作数据层中的数据模型(可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;action-target&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;block&lt;/code&gt;等方式解耦)；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;C&lt;/strong&gt; 是控制器&lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;用来调节&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;之间的交互，可以直接与Model还有View进行通信，操作Model进行数据更新，刷新View。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;低耦合、高复用、容易维护。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;的代码过于臃肿，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;直接交互会导致&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;之间的耦合性比较大、网络逻辑会加重&lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;的臃肿。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MVVM：&lt;code class=&quot;highlighter-rouge&quot;&gt;Model - View - ViewModel&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;MVVM&lt;/strong&gt;衍生于&lt;strong&gt;MVC&lt;/strong&gt;，是MVC的一种演进，促进了UI代码和业务逻辑的分离，抽取&lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;中的展示逻辑放到&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;里边。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;M：&lt;/strong&gt; 数据模型&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;V：&lt;/strong&gt; 就是&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;联系到一起，视为是一个组件&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;。View和Controller都不能直接引用模型Model，可以引用视图模型ViewModel。ViewController 尽量不涉及业务逻辑，让 ViewModel 去做这些事情。ViewController 只是一个中间人，负责接收 View 的事件、调用 ViewModel 的方法、响应 ViewModel 的变化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VM：&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;负责封装业务逻辑、网络处理和数据缓存。使用ViewModel会轻微的增加代码量，但是总体上减少了代码的复杂性。&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;之间可以有依赖。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt;引用&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;，但反过来不行，因为如果VM跟V产生了耦合，不方便复用。即不要在&lt;code class=&quot;highlighter-rouge&quot;&gt;viewModel&lt;/code&gt;中引入&lt;code class=&quot;highlighter-rouge&quot;&gt;#import UIKit.h&lt;/code&gt;，任何视图本身的引用都不应该放在&lt;code class=&quot;highlighter-rouge&quot;&gt;viewModel&lt;/code&gt;中 (&lt;strong&gt;注意：基本要求，必须满足&lt;/strong&gt;)。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;可以引用&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt;，但反过来不行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;低耦合、可复用、数据流向清晰、而且兼容MVC，便于代码的移植、并且ViewModel可以拆出来独立开发、方便测试。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt; 类会增多、&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;会越来越庞大、调用复杂度增加、双向绑定数据会导致问题调试变得困难。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MVVM&lt;/strong&gt;其实是MVC的变种。&lt;code class=&quot;highlighter-rouge&quot;&gt;MVVM&lt;/code&gt;只是帮&lt;code class=&quot;highlighter-rouge&quot;&gt;MVC&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Controller&lt;/code&gt;瘦身，把一些逻辑代码和网络请求分离出去。不让Controller处理更多的东西，不会变得臃肿，&lt;code class=&quot;highlighter-rouge&quot;&gt;MVVM&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;MVC&lt;/code&gt;可以根据实际需求进行灵活选择。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;MVVM&lt;/strong&gt; 在使用当中，通常还会利用双向绑定技术，使得&lt;code class=&quot;highlighter-rouge&quot;&gt;Model&lt;/code&gt; 变化时，&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;会自动更新，而&lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt;变化时，&lt;code class=&quot;highlighter-rouge&quot;&gt;View&lt;/code&gt; 也会自动变化。OC中可以用&lt;strong&gt;RAC(ReactiveCocoa)&lt;/strong&gt;函数响应式框架来实现响应式编程。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 静态链接了解吗？静态库和动态库的区别是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;静态链接是指将多个目标文件合并为一个可执行文件，直观感觉就是将所有目标文件的段合并。需要注意的是可执行文件与目标文件的结构基本一致，不同的是是否“可执行”。&lt;/p&gt;

&lt;p&gt;静态库：链接时被完整复制到可执行文件中&lt;/p&gt;

&lt;p&gt;动态库：由系统动态加载到内存，内存中只会有一份该动态库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 了解Flutter吗？它有没有使用UIKit？它是如何渲染UI的？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UIKit是基于CoreAnimation渲染的，而Flutter并没有用到它，而是自己基于C++实现了一套渲染框架。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200917/16003309243619.png&quot; alt=&quot;FlutterUI渲染&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 二进制重排的核心依据是什么？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;修改链接顺序，减少启动时的缺页中断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 如何设计一套切换主题的方案？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;核心思路是观察者模式+协议（通知），当获取到主题切换时，通知各个实现了主题协议的类进行更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. AVPlayer和IJKPlayer有什么区别？用IJKPlayer如何实现一个缓存视频列表每条视频前1s的内容？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 类似微博的短视频列表，滑动停留播放，如何实现？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个主要就是监测contentOffset和屏幕中间位置，设置一些边界条件，处理滑动过程中的切换行为。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. 使用python做过哪些事？如何理解脚本语言？&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;多语言管理，csv多语言文件读取，然后写入到项目Localizable.strings中；抓取项目中的多语言字符串。&lt;/li&gt;
  &lt;li&gt;Icon剪裁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;9. TCP为什么要三次握手，四次挥手？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;三次握手：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端向服务端发起请求链接，首先发送&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN&lt;/code&gt;报文，&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN=1，seq=x&lt;/code&gt;,并且客户端进入&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN_SENT&lt;/code&gt;状态&lt;/li&gt;
  &lt;li&gt;服务端收到请求链接，服务端向客户端进行回复，并发送响应报文，&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN=1，seq=y,ACK=1,ack=x+1&lt;/code&gt;,并且服务端进入到&lt;code class=&quot;highlighter-rouge&quot;&gt;SYN_RCVD&lt;/code&gt;状态&lt;/li&gt;
  &lt;li&gt;客户端收到确认报文后，向服务端发送确认报文，&lt;code class=&quot;highlighter-rouge&quot;&gt;ACK=1，ack=y+1&lt;/code&gt;，此时客户端进入到&lt;code class=&quot;highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt;，服务端收到用户端发送过来的确认报文后，也进入到&lt;code class=&quot;highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt;状态，此时链接创建成功&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;四次挥手：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端向服务端发起关闭链接，并停止发送数据&lt;/li&gt;
  &lt;li&gt;服务端收到关闭链接的请求时，向客户端发送回应，我知道了，然后停止接收数据&lt;/li&gt;
  &lt;li&gt;当服务端发送数据结束之后，向客户端发起关闭链接，并停止发送数据&lt;/li&gt;
  &lt;li&gt;客户端收到关闭链接的请求时，向服务端发送回应，我知道了，然后停止接收数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么需要三次握手：&lt;/p&gt;

&lt;p&gt;为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，假设这是一个早已失效的报文段。但&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;收到此失效的连接请求报文段后，就误认为是&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;再次发出的一个新的连接请求。于是就向&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;并没有发出建立连接的请求，因此不会理睬&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;的确认，也不会向&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;发送数据。但&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;却以为新的运输连接已经建立，并一直等待&lt;code class=&quot;highlighter-rouge&quot;&gt;client&lt;/code&gt;发来数据。这样，&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;的很多资源就白白浪费掉了。&lt;/p&gt;

&lt;p&gt;为什么需要四次挥手：&lt;/p&gt;

&lt;p&gt;因为TCP是全双工通信的，在接收到客户端的关闭请求时，还可能在向客户端发送着数据，因此不能再回应关闭链接的请求时，同时发送关闭链接的请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. App签名原理&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在Mac开发机器上生成一对公钥和私钥，这里称为公钥L，私钥L(L：Local)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;苹果自己有固定的一对公钥和私钥，私钥在苹果后台，公钥在每个iOS设备上。这里称为公钥A，私钥A(A：Apple)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;把开发机器上的公钥L传到苹果后台，用苹果后台的私钥A去签名公钥L。得到一个包含公钥L以及其签名数据证书。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在苹果后台申请AppID，配置好设备ID列表和APP可使用的权限，再加上第③步的证书，组成的数据用私钥A签名，把数据和签名一起组成一个Provisioning Profile描述文件，下载到本地Mac开发机器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在开发时，编译完一个APP后，用本地的私钥L对这个APP进行签名，同时把第④步得到的Provisioning Profile描述文件打包进APP里，文件名为embedded.mobileprovision，把 APP安装到手机上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在安装时，iOS系统取得证书，通过系统内置的公钥A，去验证embedded.mobileprovision的数字签名是否正确，里面的证书签名也会再验一遍。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;确保了embedded.mobileprovision里的数据都是苹果授权的以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200918/16004181558605.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;数据结构与算法&quot;&gt;数据结构与算法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1.什么是Hash表，什么是Hash碰撞，解决Hash碰撞有什么方法？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。我们常用的Dictionary就是一种Hash表。&lt;/p&gt;

&lt;p&gt;那什么是Hash碰撞呢，我们知道Hash表的查找是通过键值进行定位的，当两个不同的输入对应一个输出时，即为Hash碰撞，也被称为Hash冲突。&lt;/p&gt;

&lt;p&gt;如果使用字典的例子你可能联想不到冲突的情况，我们假设另一种情况：假设hash表的大小为9（即有9个槽），现在要把一串数据存到表里：5,28,19,15,20,33,12,17,10。我们使用的hash函数是对9取余。这样的话会出现hash(5)=5，hash(28)=1，hash(19)=1。28和19都对应一个地址，这就出现了Hash冲突。&lt;/p&gt;

&lt;p&gt;解决Hash冲突的方式有开放定址法和链地址法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.给出二叉树【10，6，14，4，8，12，16】进行前序、中序、后续遍历？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前序遍历：根节点 &amp;gt; 左子节点 &amp;gt; 右子节点。&lt;/p&gt;

&lt;p&gt;10，6，4，8，14，12，16&lt;/p&gt;

&lt;p&gt;中序遍历：左子节点 &amp;gt; 根节点 &amp;gt; 右子节点。&lt;/p&gt;

&lt;p&gt;4，6，8，10，12，14，16&lt;/p&gt;

&lt;p&gt;后序遍历：左子节点 &amp;gt; 右子节点 &amp;gt; 根节点。&lt;/p&gt;

&lt;p&gt;4，8，6，12，16，14，10&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.简述下快速排序的过程，时间复杂度是多少？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;快排的思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行。&lt;/p&gt;

&lt;p&gt;一个简单的Swift实现方式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;func quicksort&amp;lt;T: Comparable&amp;gt;(_ a: [T]) -&amp;gt; [T] {
  guard a.count &amp;gt; 1 else { return a }

  let pivot = a[a.count/2]
  let less = a.filter { $0 &amp;lt; pivot }
  let equal = a.filter { $0 == pivot }
  let greater = a.filter { $0 &amp;gt; pivot }

  return quicksort(less) + equal + quicksort(greater)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;快速排序是有好几种的，他们的区别在于如何实现filter和分区基准值的选取。&lt;/p&gt;

&lt;p&gt;快排的时间复杂度是O(nlogn)，空间复杂度是O(logn)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.有一个整数数组，如何只遍历一遍就实现让该数组奇数都在前面，偶数都在后面？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。leetcode 7&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.有红. 黄. 蓝三种颜色的气球。在牛客王国，1个红气球+1个黄气球+1个蓝气球可以兑换一张彩票。
2个红气球+1个黄气球可以兑换1个蓝气球。
2个黄气球+1个蓝气球可以兑换1个红气球。
2个蓝气球+1个红气球可以兑换1个黄气球。
现在牛牛有a个红气球，b个黄气球， c个蓝气球，牛牛想知道自己最多可以兑换多少张彩票。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>CoreAnimation详解</title>
        <description>&lt;h2 id=&quot;1-图层树&quot;&gt;1. 图层树&lt;/h2&gt;
&lt;p&gt;CALayer 是存在于UIView中的一种平行的层级关系
&lt;img src=&quot;http://image.smartjames.cn/20200811234017.jpg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2寄宿图&quot;&gt;2.寄宿图&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;contens 属性可以给layer赋值CGImage
contentsGravity属性类似contentModel：kCAGravityResizeAspect
contentsScale属性用来设置渲染倍数 
contentsRect用来显示contents中指定区域，适用于雪碧图的展示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 裁剪并显示雪碧图，不用从内存中读多张图片，4张图片在一张雪碧图中
- (void)addSpriteImage:(UIImage *)img withContentRect:(CGRect)rect toLayer:(CALayer *)layer
{
    layer.contents = (__bridge id)(img.CGImage);
    layer.contentsGravity = kCAGravityResizeAspect;
    layer.contentsRect = rect;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-图层几何学&quot;&gt;3. 图层几何学&lt;/h2&gt;
&lt;p&gt;UIView的center和 CALayer的position是 一个含义，代表中间点相对于父视图的位置。&lt;/p&gt;

&lt;p&gt;anchorPoint是用单位坐标表示的center和position的值作用与本身的那个位置。&lt;/p&gt;

&lt;p&gt;anchorPoint 可以用来实现时钟的指针转动
&lt;img src=&quot;http://image.smartjames.cn/20200812165714.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;
用layer的 -hitTest: 方法判断当前点击的是那个图层。一般情况下，我们理解layer是不能响应点击时间的，但是layer有这种方法判断点击位置&lt;/p&gt;

&lt;p&gt;CALayerDelegate提供如下函数，当frame变化时会调用，用以重新处理layer的位置，但是无法做到像UIView的自适应屏幕。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)layoutSublayersOfLayer:(CALayer *)layer;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4视觉效果&quot;&gt;4.视觉效果&lt;/h2&gt;

&lt;p&gt;阴影      &lt;br /&gt;
shadowOffset表示阴影的相对位移，默认值{0,-3}， 表示阴影上移3个点，因为Core Animation是Mac OS上出现的，Mac和iOS坐标系是翻转的，所以在Mac上显示的就是向下位移3个点。&lt;/p&gt;

&lt;p&gt;shadowRadius是控制阴影的模糊度&lt;/p&gt;

&lt;p&gt;shadowPath通过一个CGPath来绘制阴影，因为当视图有多个图层，shadowOffset计算阴影会非常消耗资源。可以通过shadowPath提前绘制一个大概的阴影代替会快很多，涉及到离屏渲染。&lt;/p&gt;

&lt;p&gt;蒙版
mask是图层的属性，类型也是图层，可以用来将蒙版以外的内容裁剪掉。而且支持动态的mask
&lt;img src=&quot;http://image.smartjames.cn/20200812175605.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拉伸过滤
minificationFilter和magnificationFilter属性，提供3中拉伸函数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kCAFilterLinear&lt;/li&gt;
  &lt;li&gt;kCAFilterNearest&lt;/li&gt;
  &lt;li&gt;kCAFilterTrilinear&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组透明
UIViewGroupOpacity，当一个控件a内部有另一个控件b, 设置a的alpha, 那么b的透明度也是0.5，但是会叠加控件a的部分颜色，通过在infoplsit中设置UIViewGroupOpacity为yes,或者设置layer的shouldRasterize=yes。
但是在最新的系统上，已经不需要单独处理这种问题。
&lt;img src=&quot;http://image.smartjames.cn/20200812183557.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5变换&quot;&gt;5.变换&lt;/h2&gt;

&lt;h3 id=&quot;仿射变换&quot;&gt;仿射变换：&lt;/h3&gt;
&lt;p&gt;属于Core Graphics框架，是2D绘图API, 和UIView一样，只有2维空间&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)     
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)      
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CALayer有三维空间，所以同理CATransform3D属于Core Animation框架可以支持3D变换
API增加了Z轴旋转角度，XYZ轴缩放比例，和Z轴的移动距离&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz)
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200812222012.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。
但是旋转得到的结果是等距投影，与真实世界里透视投影不一样。在等距投影中，远处的物体和近处的物体保持同样的缩放比例。引出透视投影的概念。&lt;/p&gt;

&lt;h3 id=&quot;透视投影&quot;&gt;透视投影：&lt;/h3&gt;
&lt;p&gt;在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边更短。
通过矩阵中一个元素控制：m34。m34的默认值是0，我们可以通过设置m34为-1.0 / d来应用透视效果；d是相机与屏幕之间的距离。
&lt;img src=&quot;http://image.smartjames.cn/20200812234846.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CATransform3D transform = CATransform3DIdentity;
    transform.m34 = - 1.0 / 500.0;
    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);
    self.layerView.layer.transform = transform;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;sublayerTransform属性，使子图层都有相同的trasnform设置。&lt;/p&gt;

&lt;h3 id=&quot;背面&quot;&gt;背面&lt;/h3&gt;
&lt;p&gt;旋转180°后，形成一个镜像，可以用doubleSided属性控制背面是否需要绘制。&lt;/p&gt;

&lt;h3 id=&quot;扁平化图层&quot;&gt;扁平化图层&lt;/h3&gt;
&lt;p&gt;当父视图沿着Y轴旋转45°时，子视图沿着Y轴旋转-45°时，预期结果如下，能够抵消旋转的角度
&lt;img src=&quot;http://image.smartjames.cn/20200812235931.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是真实结果如下所示，子视图并没有垂直Z轴，因为CoreAnimation的3D场景其实是扁平化的，3D场景是图层想象出来的，绘制在图层表面的，且各自独立在不同的3D空间。
&lt;img src=&quot;http://image.smartjames.cn/20200812235939.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;
所以用普通的CALayer很难创建非常复杂的3D场景，除非用CATransformLayer。&lt;/p&gt;

&lt;h3 id=&quot;固体对象&quot;&gt;固体对象&lt;/h3&gt;
&lt;p&gt;通过将不同layer旋转不同角度，拼凑成一个表面看是实心体。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;
    
    // 都旋转一个角度,看到侧面
    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);
    
    self.view.layer.sublayerTransform = perspective;
    //add cube face 1
    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);
    [self addFace:0 withTransform:transform];
    //add cube face 2
    transform = CATransform3DMakeTranslation(100, 0, 0);
    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
    [self addFace:1 withTransform:transform];
    //add cube face 3
    transform = CATransform3DMakeTranslation(0, -100, 0);
    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
    [self addFace:2 withTransform:transform];
    //add cube face 4
    transform = CATransform3DMakeTranslation(0, 100, 0);
    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
    [self addFace:3 withTransform:transform];
    //add cube face 5
    transform = CATransform3DMakeTranslation(-100, 0, 0);
    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
    [self addFace:4 withTransform:transform];
    //add cube face 6
    transform = CATransform3DMakeTranslation(0, 0, -100);
    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
    [self addFace:5 withTransform:transform];
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813003034.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6专用图层&quot;&gt;6.专用图层&lt;/h2&gt;

&lt;h3 id=&quot;cashapelayer&quot;&gt;CAShapeLayer&lt;/h3&gt;
&lt;p&gt;一个通过矢量图形而不是bitmap来绘制的图层子类。&lt;/p&gt;

&lt;p&gt;定义颜色和线宽用CGPath就能渲染，看起来Core Graphics也能实现，但是CAShapeLayer优点如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;渲染快。使用了硬件加速，绘制比CG快很多&lt;/li&gt;
  &lt;li&gt;高效使用内存。不会像普通CALayer一样创建一个寄宿图，所以无论多大，都不会占用太多内存&lt;/li&gt;
  &lt;li&gt;不会被图层边界裁掉。可以在边界之外绘制&lt;/li&gt;
  &lt;li&gt;不会像素化。因为是矢量图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现3个圆角，1个直角的矩形。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGRect rect = CGRectMake(50, 50, 100, 100);
    CGSize radii = CGSizeMake(20, 20);
    UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomLeft | UIRectCornerTopLeft;
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
    
CAShapeLayer *layer = [CAShapeLayer layer];
........ // 设置宽度颜色等
layer.path = path.CGPath;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;catextlayer&quot;&gt;CATextLayer&lt;/h3&gt;
&lt;p&gt;它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。同样，CATextLayer也要比UILabel渲染得快得多。很少有人知道在iOS 6及之前的版本，UILabel其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core text，并且渲染得非常快。&lt;/p&gt;

&lt;h3 id=&quot;catransformlayer&quot;&gt;CATransformLayer&lt;/h3&gt;
&lt;p&gt;前面想做一个立体图形的旋转状态，需要对立体图形的每一个图层做一次旋转。
现在使用CATransformLayer不需要，只要创建立体图形时把图层加入到CATransformLayer中，旋转CATransformLayer一次即可实现立体图形旋转。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (CALayer *)cubeWithTransform:(CATransform3D)transform
{
  //create cube layer
  CATransformLayer *cube = [CATransformLayer layer];

  //add cube face 1
  CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);
  [cube addSublayer:[self faceWithTransform:ct]];

// .......

  //add cube face 6
  ct = CATransform3DMakeTranslation(0, 0, -50);
  ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);
  [cube addSublayer:[self faceWithTransform:ct]];

  //center the cube layer within the container
  CGSize containerSize = self.containerView.bounds.size;
  cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);

  //apply the transform and return
  cube.transform = transform;
  return cube;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813010733.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cagradientlayer&quot;&gt;CAGradientLayer&lt;/h3&gt;
&lt;p&gt;用来生成2种或更多颜色平滑渐变的图层。&lt;/p&gt;

&lt;p&gt;startPoint和endPoint决定渐变方向，用单位坐标系定义，左上角是{0,0}, 右下角是{1,1}
location定义不同颜色的位置，个数要和颜色个数相同，可选。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
	[super viewDidLoad];

	//create gradient layer and add it to our container view
	CAGradientLayer *gradientLayer = [CAGradientLayer layer];
	gradientLayer.frame = self.containerView.bounds;
	[self.containerView.layer addSublayer:gradientLayer];

	//set gradient colors
	gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];

	//set locations
	gradientLayer.locations = @[@0.0, @0.25, @0.5];

	//set gradient start and end points
	gradientLayer.startPoint = CGPointMake(0, 0);
	gradientLayer.endPoint = CGPointMake(1, 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813011439.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;careplicatorlayer&quot;&gt;CAReplicatorLayer&lt;/h3&gt;
&lt;p&gt;为了高效生成许多相似的重复图层。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad
{
    [super viewDidLoad];
    //create a replicator layer and add it to our view
    CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
    replicator.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:replicator];

    //configure the replicator
    replicator.instanceCount = 10;

    //apply a transform for each instance
    CATransform3D transform = CATransform3DIdentity;
    transform = CATransform3DTranslate(transform, 0, 200, 0);
    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
    transform = CATransform3DTranslate(transform, 0, -200, 0);
    replicator.instanceTransform = transform;

    //apply a color shift for each instance
    replicator.instanceBlueOffset = -0.1;
    replicator.instanceGreenOffset = -0.1;

    //create a sublayer and place it inside the replicator
    CALayer *layer = [CALayer layer];
    layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
    layer.backgroundColor = [UIColor whiteColor].CGColor;
    [replicator addSublayer:layer];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813012855.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;instanceCount 代表有复制多少次
instanceTransform属性，代表后续每个图层都要做这个变换。
instanceBlueOffset和instanceGreenOffset代表每次减少蓝色绿色通道多少值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;镜像&lt;/strong&gt;
用CAReplicatorLayer实现镜像效果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;
    layer.instanceCount = 2;

    //move reflection instance below original and flip vertically
    CATransform3D transform = CATransform3DIdentity;
    CGFloat verticalOffset = self.bounds.size.height + 2;
    transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
    transform = CATransform3DScale(transform, 1, -1, 0);
    layer.instanceTransform = transform;

    //reduce alpha of reflection layer
    layer.instanceAlphaOffset = -0.6;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2个重复对象，移动高度的2倍，缩小一点，颜色透明一点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813013306.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cascrolllayer&quot;&gt;CAScrollLayer&lt;/h3&gt;
&lt;p&gt;实现类似UIScrollView的图层，但是内容可以滑出边界。&lt;/p&gt;

&lt;h3 id=&quot;catiledlayer&quot;&gt;CATiledLayer&lt;/h3&gt;
&lt;p&gt;iOS中绘制图片最终是转化为OpenGL纹理，最大纹理尺寸是2048×2048或4096×4096， 如果图片超过这个尺寸，会遇到性能问题。&lt;/p&gt;

&lt;p&gt;因为Core Animation强制用CPU处理图片而不是GPU。&lt;/p&gt;

&lt;p&gt;CATiledLayer会将大图片分解成小图片然后按需载入，类似ScrollView.
    &lt;strong&gt;使用场景&lt;/strong&gt;是iOS老版本的地图应用，会一块一块的显示新的之前未曾渲染过的地图，就是用到了这个技术。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //determine tile coordinate
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);

    //load tile image
    NSString *imageName = [NSString stringWithFormat: @&quot;Snowman_%02i_%02i&quot;, x, y];
    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;jpg&quot;];
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];

    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:bounds];
    UIGraphicsPopContext();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;滑动图层到边缘时自动调用在drawLayer方法，获取对应要显示的图片并渲染。
CATiledLayer支持多线程绘制，这一点不同于UIKit和Core Animation方法。即-drawLayer:inContext: 能在多线程中并发调用&lt;/p&gt;

&lt;h3 id=&quot;caemitterlayer&quot;&gt;CAEmitterLayer&lt;/h3&gt;
&lt;p&gt;是一个高性能的粒子引擎，被用来创建实时粒子动画如：烟雾，火，雨，烟花等。&lt;/p&gt;

&lt;p&gt;CAEmitterLayer是CAEmitterCell的容器，后者定义了粒子效果，CAEmitterLayer将不同的粒子效果cell作为模板实例化粒子流。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   CAEmitterLayer *emitter = [CAEmitterLayer layer];
    emitter.frame = self.view.bounds;
    [self.view.layer addSublayer:emitter];

    //configure emitter
    emitter.renderMode = kCAEmitterLayerAdditive;
    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);

    //create a particle template
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
    cell.alphaSpeed = -0.4;
    cell.velocity = 50;
    cell.velocityRange = 50;
    cell.emissionRange = M_PI * 2.0;

    //add particle template to emitter
    emitter.emitterCells = @[cell];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813020502.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CAEMitterCell的属性基本上可以分为三种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。&lt;/li&gt;
  &lt;li&gt;粒子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着粒子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形。&lt;/li&gt;
  &lt;li&gt;指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说粒子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐消失的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;caeagllayer&quot;&gt;CAEAGLLayer&lt;/h3&gt;
&lt;p&gt;当想使用GLKit实现OpenGL渲染时，使用CLKView类来处理大部分的设置和绘制工作，但是OpenGL 绘图缓冲的底层可配置项仍然需要使用CAEAGLLayer完成，用来显示任意的Open GL图形。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;ViewController.h&quot;
#import &amp;lt;QuartzCore/QuartzCore.h&amp;gt;
#import &amp;lt;GLKit/GLKit.h&amp;gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *glView;
@property (nonatomic, strong) EAGLContext *glContext;
@property (nonatomic, strong) CAEAGLLayer *glLayer;
@property (nonatomic, assign) GLuint framebuffer;
@property (nonatomic, assign) GLuint colorRenderbuffer;
@property (nonatomic, assign) GLint framebufferWidth;
@property (nonatomic, assign) GLint framebufferHeight;
@property (nonatomic, strong) GLKBaseEffect *effect;

@end

@implementation ViewController

- (void)setUpBuffers
{
    //set up frame buffer
    glGenFramebuffers(1, &amp;amp;_framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);

    //set up color render buffer
    glGenRenderbuffers(1, &amp;amp;_colorRenderbuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.glLayer];
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;amp;_framebufferWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;amp;_framebufferHeight);

    //check success
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        NSLog(@&quot;Failed to make complete framebuffer object: %i&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));
    }
}

- (void)tearDownBuffers
{
    if (_framebuffer) {
        //delete framebuffer
        glDeleteFramebuffers(1, &amp;amp;_framebuffer);
        _framebuffer = 0;
    }

    if (_colorRenderbuffer) {
        //delete color render buffer
        glDeleteRenderbuffers(1, &amp;amp;_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
}

- (void)drawFrame {
    //bind framebuffer &amp;amp; set viewport
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    glViewport(0, 0, _framebufferWidth, _framebufferHeight);

    //bind shader program
    [self.effect prepareToDraw];

    //clear the screen
    glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0, 0.0, 0.0, 1.0);

    //set up vertices
    GLfloat vertices[] = {
        -0.5f, -0.5f, -1.0f, 0.0f, 0.5f, -1.0f, 0.5f, -0.5f, -1.0f,
    };

    //set up colors
    GLfloat colors[] = {
        0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,
    };

    //draw triangle
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vertices);
    glVertexAttribPointer(GLKVertexAttribColor,4, GL_FLOAT, GL_FALSE, 0, colors);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    //present render buffer
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    //set up context
    self.glContext = [[EAGLContext alloc] initWithAPI: kEAGLRenderingAPIOpenGLES2];
    [EAGLContext setCurrentContext:self.glContext];

    //set up layer
    self.glLayer = [CAEAGLLayer layer];
    self.glLayer.frame = self.glView.bounds;
    [self.glView.layer addSublayer:self.glLayer];
    self.glLayer.drawableProperties = @{kEAGLDrawablePropertyRetainedBacking:@NO, kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8};

    //set up base effect
    self.effect = [[GLKBaseEffect alloc] init];

    //set up buffers
    [self setUpBuffers];

    //draw frame
    [self drawFrame];
}

- (void)viewDidUnload
{
    [self tearDownBuffers];
    [super viewDidUnload];
}

- (void)dealloc
{
    [self tearDownBuffers];
    [EAGLContext setCurrentContext:nil];
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813021236.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;avplayerlayer&quot;&gt;AVPlayerLayer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由AVFoundation框架提供用于播放视频的图层。 因为本身是CALayer的子类，所以也支持layer该有的效果，例如边框，圆角，蒙版，阴影等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;7隐式动画&quot;&gt;7.隐式动画&lt;/h2&gt;

&lt;h3 id=&quot;事务&quot;&gt;事务&lt;/h3&gt;
&lt;p&gt;通过CATransaction类来管理，通过begin和commit的入栈和出栈来管理栈中的动画事务，栈中的动画默认执行时长0.25秒  &lt;br /&gt;
不显示的调用begin，在runloop一个周期内，也会收集所有属性的变化，做一些0.25秒的动画。  &lt;br /&gt;
CATransaction 有completionBlock方法，动画执行完后会自动调用。&lt;/p&gt;

&lt;p&gt;UIView会默认禁用关联图层的动画效果，否则对于UIview的属性修改都会形成动画效果，这不是我们想要的。要实现UIView的动画，使用UIView的animateWithDuration：方法；&lt;/p&gt;

&lt;h3 id=&quot;catransition&quot;&gt;CATransition&lt;/h3&gt;
&lt;p&gt;控制移动的动画类，使用方法如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CATransition *transition = [CATransition animation];
transition.type = kCATransitionPush;
transition.subtype = kCATransitionFromLeft;
self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CALayer的属性值变化，其实在设置的当时已经变化，只是视图的更新会延后，CALayer在动画过程中，需要知道当前显示在屏幕上的属性值的记录，所以提供-presentationLayer方法来访问当前呈现的图层。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342476.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大多数情况下，不需要直接访问呈现图层，但在以下俩种情况下呈现图层会很有用，一个是同步动画，一个是处理用户交互。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某个时刻图层显示在什么位置就会对正确摆放图层很有用。&lt;/li&gt;
  &lt;li&gt;想让动画的图层响应用户输入，可以使用++-hitTest:++ 方法判断指定图层是否被触摸，此时响应的是呈现图层，而不是动画结束后的模型图层。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8显式动画&quot;&gt;8.显式动画&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;显式动画相对于隐式动画，是用户自己主动创建的一种动画类型，与隐式动画做的关于属性动画不同。 ### 属性动画
作用于图层的某个单一属性，并指定了它的一个或一连串目标值，分为基础动画和关键帧动画，即CABasicAnimation和CAKeyframeAnimation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;基础动画&quot;&gt;基础动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;最简单的形式就是从一个值改变到另一个值，这也是CABasicAnimation最主要的功能。提供了fromValue, toValue, byValue三个属性。fromValue代表了动画开始之前属性的值，toValue代表了动画结束之后的值，byValue代表了动画执行过程中改变的相对值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.toValue = (__bridge id)color.CGColor;
    [self.colorLayer addAnimation:animation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面这种动画，是使layer变换颜色，但是动画结束后又立刻变回原始值，因为这里使用的显式动画改变的是呈现层，不是模型层（隐式动画通过赋值达到改变模型层）。解决方案是动画完成前赋值给模型层。&lt;/p&gt;

&lt;h3 id=&quot;关键帧动画&quot;&gt;关键帧动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation揭示了大多数隐式动画背后依赖的机制，这的确很有趣，但是显式地给图层添加CABasicAnimation相较于隐式动画而言，只能说费力不讨好。 CAKeyframeAnimation是另一种UIKit没有暴露出来但功能强大的类。不光能设置单一值，还能设置一串值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.duration = 2.0;
    animation.values = @[
                         (__bridge id)[UIColor blueColor].CGColor,
                         (__bridge id)[UIColor redColor].CGColor,
                         (__bridge id)[UIColor greenColor].CGColor,
                         (__bridge id)[UIColor blueColor].CGColor ];
    [self.colorLayer addAnimation:animation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面给关键帧的values赋值了一个颜色组，每个颜色默认动画0.25秒。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;position&quot;;
    animation.duration = 4.0;
    animation.path = bezierPath.CGPath;
    [shipLayer addAnimation:animation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关键帧不光能接受一组值，还能接受一个路径，使用Core Graphics函数定义运动序列来绘制动画。移动中通过设置rotationMode = kCAAnimationRotateAuto达到图层垂直于路径。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342490.jpeg&quot; style=&quot;zoom:40%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;虚拟属性&quot;&gt;虚拟属性&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;前面的属性动画都针对真实属性，例如backgroundColor, position等。如果想对一个属性的路径，或不是真实属性做动画，就是虚拟属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform&quot;;
animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;正常的属性赋值是上面这样，使用虚拟属性可以向下面一样使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform.rotation&quot;;
animation.byValue = @(M_PI * 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;用transform.rotation而不是transform做动画的好处如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;我们可以不通过关键帧一步旋转多于180度的动画。&lt;/li&gt;
  &lt;li&gt;可以用相对值而不是绝对值旋转（设置byValue而不是toValue）。&lt;/li&gt;
  &lt;li&gt;可以不用创建CATransform3D，而是使用一个简单的数值来指定角度。&lt;/li&gt;
  &lt;li&gt;不会和transform.position或者transform.scale冲突（同样是使用关键路径来做独立的动画属性）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;过渡变幻&quot;&gt;过渡/变幻&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用CATransition类，有4种变换类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kCATransitionFade&lt;/li&gt;
  &lt;li&gt;kCATransitionMoveIn&lt;/li&gt;
  &lt;li&gt;kCATransitionPush&lt;/li&gt;
  &lt;li&gt;kCATransitionReveal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和4个方向&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kCATransitionFromRight&lt;/li&gt;
  &lt;li&gt;kCATransitionFromLeft&lt;/li&gt;
  &lt;li&gt;kCATransitionFromTop&lt;/li&gt;
  &lt;li&gt;kCATransitionFromBottom&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342502.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;自定义动画&quot;&gt;自定义动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;过渡是一种对那些不太好做平滑动画属性的强大工具，但是CATransition的提供的动画类型太少了。 UIView +transitionFromView:toView:duration:options:completion: 提供的过渡选项却很多 - UIViewAnimationOptionTransitionFlipFromLeft  - UIViewAnimationOptionTransitionFlipFromRight - UIViewAnimationOptionTransitionCurlUp  - UIViewAnimationOptionTransitionCurlDown - UIViewAnimationOptionTransitionCrossDissolve  - UIViewAnimationOptionTransitionFlipFromTop  - UIViewAnimationOptionTransitionFlipFromBottom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;9图层时间&quot;&gt;9.图层时间&lt;/h2&gt;

&lt;h3 id=&quot;camediatiming-协议&quot;&gt;CAMediaTiming 协议&lt;/h3&gt;
&lt;p&gt;CAMediaTiming协议定义了在一段动画内用来控制逝去时间的属性的集合，CALayer和CAAnimation都实现了此协议。&lt;/p&gt;

&lt;p&gt;常用属性&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;duration      动画持续时间&lt;/li&gt;
  &lt;li&gt;repeatCount   重复次数&lt;/li&gt;
  &lt;li&gt;speed         倍速，0暂停，负数回放动画&lt;/li&gt;
  &lt;li&gt;beginTime     动画开始之前的的延迟时间&lt;/li&gt;
  &lt;li&gt;timeOffset    动画快进到某一点&lt;/li&gt;
  &lt;li&gt;fillMode      动画结束是否保持之前的状态，定义了几个类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kCAFillModeForwards
kCAFillModeBackwards
kCAFillModeBoth
kCAFillModeRemoved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;autoreverses  是否进行反向动画，实现门的开关&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342517.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;10时间函数&quot;&gt;10.时间函数&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为了让动画显得更自然，而不是很机械，需要使用时间函数控制动画速率
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;camediatimingfunction&quot;&gt;CAMediaTimingFunction&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAAnimation的timingFunciont属性接收一个CAMediaTimingFunction对象。 包含以下类型 - kCAMediaTimingFunctionLinear  - kCAMediaTimingFunctionEaseIn  - kCAMediaTimingFunctionEaseOut  - kCAMediaTimingFunctionEaseInEaseOut - kCAMediaTimingFunctionDefault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;uiview的时间函数&quot;&gt;UIView的时间函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIView的动画也支持时间函数，参考CAAnimation的函数 - UIViewAnimationOptionCurveEaseInOut  - UIViewAnimationOptionCurveEaseIn  - UIViewAnimationOptionCurveEaseOut  - UIViewAnimationOptionCurveLinear
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自定义时间函数&quot;&gt;自定义时间函数&lt;/h3&gt;
&lt;p&gt;除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::
三次贝塞尔时间函数，自定义函数的入参就是图中的几个控制点
参数就是图中的几个控制点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342534.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;12性能调优&quot;&gt;12.性能调优&lt;/h2&gt;

&lt;h3 id=&quot;影响gpu-降低图层绘制&quot;&gt;影响GPU， 降低图层绘制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见本章后续“CPU相关操作”）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;影响cpu延迟动画开始时间&quot;&gt;影响CPU，延迟动画开始时间&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视图惰性加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比CPU正常操作慢得多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Core Graphics绘制 - 如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性能优化实例&quot;&gt;性能优化实例&lt;/h3&gt;
&lt;p&gt;UITabelViewCell 使用了阴影和圆角等触发离屏渲染，影响性能。这是可以打开shouldRasterize， 这是光栅化，缓存阴影和圆角到位图，下次重绘时直接取用缓存。虽然光栅会也会触发离屏渲染，但是能够缓解cell的滑动不断渲染，也能一定程度上提高性能。&lt;/p&gt;

&lt;h2 id=&quot;13-高效绘图&quot;&gt;13. 高效绘图&lt;/h2&gt;

&lt;p&gt;软件绘图指不由GPU协助的绘图，iOS中一般通过Core Graphics完成，但是和Core Animation和 OpenGL相比，Core Graphics要慢不少。
软件绘图还会消耗不少内存，一个Context上下文相当于图层宽×高×4字节，分辨率为2048*1526的iPad来说，就是12MB内存，且每次重绘都需要抹掉内存重新分配，代价很大，所以要尽量避免绘图。&lt;/p&gt;

&lt;h3 id=&quot;使用cashapelayer-提高效率&quot;&gt;使用CAShapeLayer 提高效率&lt;/h3&gt;
&lt;p&gt;例如实现手指滑动绘制线条，简单做法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    //get the current point
    CGPoint point = [[touches anyObject] locationInView:self];

    //add a new line segment to our path
    [self.path addLineToPoint:point];

    //redraw the view
    [self setNeedsDisplay];
}

- (void)drawRect:(CGRect)rect
{
    //draw path
    [[UIColor clearColor] setFill];
    [[UIColor redColor] setStroke];
    [self.path stroke];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用了Core Graphics，画的越多，程序越慢，每次都会重绘整个路径，效率很低。
使用CAShapeLayer替代Core Graphics，性能大幅提高。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (Class)layerClass
{
    //this makes our view create a CAShapeLayer
    //instead of a CALayer for its backing layer
    return [CAShapeLayer class];
}
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    //get the current point
    CGPoint point = [[touches anyObject] locationInView:self];

    //add a new line segment to our path
    [self.path addLineToPoint:point];

    //update the layer with a copy of the path
    ((CAShapeLayer *)self.layer).path = self.path.CGPath;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;脏矩形&quot;&gt;脏矩形&lt;/h3&gt;
&lt;p&gt;为了减少不必要的绘制，MacOS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。&lt;/p&gt;

&lt;p&gt;当一个视图被改动过了，TA可能需要重绘。但是很多情况下，只是这个视图的一部分被改变了，所以重绘整个寄宿图就太浪费了。所以提供了-setNeedsDisplayInRect:来把脏区域作为参数传入，能够提高部分效率。&lt;/p&gt;

&lt;p&gt;相比依赖于Core Graphics为你重绘，裁剪出自己的绘制区域可能会让你避免不必要的操作。那就是说，如果你的裁剪逻辑相当复杂，那还是让Core Graphics来代劳吧，记住：当你能高效完成的时候才这样做。&lt;/p&gt;

&lt;p&gt;CGRectIntersectsRect()能判断指定的rect在不在脏区域内，从而判断是否需要重新绘制这一块。&lt;/p&gt;

&lt;h3 id=&quot;异步绘制&quot;&gt;异步绘制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CATiledLayer 分片显示的layer，在多线程中为每个小块同时调用drawLayer:inContext:方法，避免阻塞交互。&lt;/li&gt;
  &lt;li&gt;drawsAsynchronously 它自己的-drawLayer:inContext:方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。==根据苹果的说法。这个特性在需要频繁重绘的视图上效果最好（比如我们的绘图应用，或者诸如UITableViewCell之类的），对那些只绘制一次或很少重绘的图层内容来说没什么太大的帮助。==&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;14图像io&quot;&gt;14.图像IO&lt;/h2&gt;
&lt;p&gt;图像耗费时间主要包括2个部分，加载到内存和解压。&lt;/p&gt;

&lt;h3 id=&quot;解决加载问题&quot;&gt;解决加载问题&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;文件读取&lt;/strong&gt;: 使用异步加载的方式，GCD或NSOperationQueue，在子线程中读取图片，在主线程中显示图片。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;延迟解压&lt;/strong&gt;: 当加载图片之后，iOS通常会延迟解压图片的时间。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压（通常是消耗时间的问题所在）。&lt;/p&gt;

&lt;p&gt;使用+imageNamed:方法能避免延时加载，会在加载图片后立刻解压。但对于生成的图片，相册照片或下载的图片无效。
此时可以使用ImageIO框架实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSInteger index = indexPath.row;
NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];
NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache: @YES}; 
CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);
UIImage *image = [UIImage imageWithCGImage:imageRef]; 
CGImageRelease(imageRef);
CFRelease(source);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就可以使用kCGImageSourceShouldCache来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。&lt;/p&gt;

&lt;h3 id=&quot;分辨率替换&quot;&gt;分辨率替换&lt;/h3&gt;
&lt;p&gt;在滑动的时候使用分辨率图片，滑动停止时替换为高分辨率图片。&lt;/p&gt;

&lt;h3 id=&quot;图片缓存&quot;&gt;图片缓存&lt;/h3&gt;
&lt;p&gt;imageNamed: 在内存中自动缓存了解压后的图片，但也有以下几个问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[UIImage imageNamed:]方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以[UIImage imageNamed:]就没法用了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[UIImage imageNamed:]缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[UIImage imageNamed:]缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nscache&quot;&gt;NSCache&lt;/h3&gt;
&lt;p&gt;NSCache和NSDictionary类似，你可以通过-setObject:forKey:和-object:forKey:方法分别来插入，检索。和字典不同的是，NSCache在系统低内存的时候自动丢弃存储的对象。
-setCountLimit: 设置缓存大小
-setObject:forKey:cost:来对每个存储的对象指定消耗的值来提供一些参考，数值越大说明很昂贵，降低丢弃的优先级。
-setTotalCostLimit: 指定全体缓存的大小&lt;/p&gt;

&lt;h3 id=&quot;png和jpeg区别&quot;&gt;PNG和JPEG区别&lt;/h3&gt;
&lt;p&gt;JPEG不包含透明度通道，压缩算法复杂，文件小，解压时会耗费时间多
PNG包含透明度通道，算法简单，文件大，解压时耗费时间少&lt;/p&gt;

&lt;p&gt;JPEG适合噪点大的图片， PNG适合扁平颜色，锋利的线条和渐变色图片。&lt;/p&gt;

&lt;h2 id=&quot;15图层性能&quot;&gt;15.图层性能&lt;/h2&gt;

&lt;h3 id=&quot;光栅化&quot;&gt;光栅化&lt;/h3&gt;

&lt;p&gt;在第四章『视觉效果』中我们提到了&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldRasterize&lt;/code&gt;属性，它可以解决重叠透明图层的混合失灵问题。同样在第12章『速度的曲调』中，它也是作为绘制复杂图层树结构的优化方法。&lt;/p&gt;

&lt;p&gt;启用&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldRasterize&lt;/code&gt;属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。&lt;/p&gt;

&lt;p&gt;当我们使用得当时，光栅化可以提供很大的性能优势（如你在第12章所见），但是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而且会让性能变的更糟。&lt;/p&gt;

&lt;p&gt;为了检测你是否正确地使用了光栅化方式，用Instrument查看一下Color Hits Green和Misses Red项目，是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。&lt;/p&gt;

&lt;h3 id=&quot;混合和过度绘制&quot;&gt;混合和过度绘制&lt;/h3&gt;

&lt;p&gt;GPU每一帧可以绘制的像素有最大显示fill rate, 所以必须有选择的绘制区域。GPU会放弃绘制哪些被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素(混合)消耗的资源也是相当可观的。所以为了加速处理进程，非必要时刻不要用透明图层。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给视图&lt;code class=&quot;highlighter-rouge&quot;&gt;backgroundColor&lt;/code&gt; 设置一个固定的不透明颜色。&lt;/li&gt;
  &lt;li&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;opaque&lt;/code&gt;属性为YES&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响），且计算得到了加速。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/CoreAnimation/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/CoreAnimation/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>深入理解HTTPS</title>
        <description>&lt;h2 id=&quot;what&quot;&gt;What&lt;/h2&gt;
&lt;p&gt;HTTPS在传统的HTTP和TCP之间加了一层用于&lt;code class=&quot;highlighter-rouge&quot;&gt;加密解密的SSL/TLS层&lt;/code&gt;（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层。使用HTTPS必须要有一套自己的数字证书（包含公钥和私钥）。&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;Why&lt;/h2&gt;
&lt;h3 id=&quot;http的问题&quot;&gt;HTTP的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不加密，通信是明文，可能被窃听&lt;/li&gt;
  &lt;li&gt;无法证明报文的完整性，可能被篡改&lt;/li&gt;
  &lt;li&gt;没验证通信方的身份，可能遭遇中间人伪装&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;https解决的问题&quot;&gt;HTTPS解决的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;信息加密传输：第三方无法窃听；&lt;/li&gt;
  &lt;li&gt;校验机制：一旦被篡改，通信双方会立刻发现；&lt;/li&gt;
  &lt;li&gt;身份证书：防止身份被冒充。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how&quot;&gt;How&lt;/h2&gt;
&lt;h3 id=&quot;如何加密&quot;&gt;如何加密&lt;/h3&gt;
&lt;h4 id=&quot;哈希加密&quot;&gt;哈希加密&lt;/h4&gt;
&lt;p&gt;哈希算法加密是通过哈希算法对数据加密，加密后的结果不可逆，即加密后不能再解密。
特点: 不可逆、算法公开、相同数据加密结果一致。
作用: 信息摘要，信息“指纹”，用来做数据识别的。如：用户密码加密、文件校验、数字签名、鉴权协议。&lt;/p&gt;

&lt;h4 id=&quot;对称加密&quot;&gt;对称加密&lt;/h4&gt;
&lt;p&gt;加密和解密同用一个密钥。&lt;strong&gt;没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了&lt;/strong&gt;。对称加密有很多种算法，常用的有AES, DES。由于它效率很高，所以被广泛使用在很多加密协议的核心当中。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    encrypt(明文，秘钥) = 密文
    decrypt(密文，秘钥) = 明文
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;优点: 相对于非对称加密，加解密效率高得多，加密速度块。
缺点: 对于秘钥的管理和分发上比较困难，秘钥管理负担重。&lt;/p&gt;

&lt;h4 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h4&gt;
&lt;p&gt;指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。&lt;strong&gt;私钥只能由一方安全保管，不能外泄，而公钥则可任意发布给需要的人&lt;/strong&gt;。
非对称RSA有2种用法：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;加解密
 公钥加密，私钥解密是普通的方式&lt;/li&gt;
  &lt;li&gt;数字签名
 私钥签名(加密)，公钥验证(解密)是数字签名，防止中间人冒充&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    encrypt(明文，公钥) = 密文
    decrypt(密文，私钥) = 明文
    
    sign(明文，私钥) = 密文
    verify(密文，公钥) = 明文
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;优点: 安全性高，私钥自己保存，不需要传输。
缺点: 加解密消耗高，速度慢。&lt;/p&gt;

&lt;p&gt;HTTPS采用了对称加密+非对称加密的方案。具体做法如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633632456.png&quot; style=&quot;zoom:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是依然解决不了中间人的攻击，如下图：&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633723857.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因此需要保证数据完整性引入数字签名&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;如何保证数据完整性-数字签名&quot;&gt;如何保证数据完整性-数字签名&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;数字签名是通过HASH算法和RSA加密来实现的。 我们将明文数据加上&lt;strong&gt;通过RSA加密的数据HASH值&lt;/strong&gt;一起传输给对方，对方可以解密拿出HASH值来进行验证。这个通过RSA加密HASH值数据，我们称之为数字签名。&lt;/p&gt;

&lt;p&gt;数字签名有两种功效：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。&lt;/li&gt;
  &lt;li&gt;数字签名能确定消息的完整性,证明数据是否未被篡改过。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数字签名生如何成：&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633815147.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将一段文本先用HASH算法生成消息摘要，然后用发送者的私钥RSA加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;校验数字签名流程：&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634134529.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH算法对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上面可行的前提是需要事先拿到可信的公钥，因此引入数字证书&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;如何校验身份-数字证书&quot;&gt;如何校验身份-数字证书&lt;/h3&gt;
&lt;p&gt;数字证书就是Server将公钥和公司信息提交给证书颁发机构（Certificate Authority，简称CA），CA将公钥和其他信息数字签名后生成证书， Client也会内置所有受信CA的证书。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634229207.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此HTTPS的流程如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;客户端请求服务器获取&lt;code class=&quot;highlighter-rouge&quot;&gt;证书公钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端(SSL/TLS)解析证书，判断真实性&lt;/li&gt;
  &lt;li&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;公钥&lt;/code&gt;加密&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端将&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;发送给服务器&lt;/li&gt;
  &lt;li&gt;服务端用&lt;code class=&quot;highlighter-rouge&quot;&gt;私钥&lt;/code&gt;解密得到&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;将信息和秘钥混合在一起&lt;/code&gt;进行对称加密&lt;/li&gt;
  &lt;li&gt;将加密的内容发送给客户端&lt;/li&gt;
  &lt;li&gt;客户端用&lt;code class=&quot;highlighter-rouge&quot;&gt;秘钥&lt;/code&gt;解密信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634413967.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;附：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTPS默认使用443端口，而HTTP默认使用80端口。&lt;/li&gt;
  &lt;li&gt;TLS就是从SSL发展而来的，只是SSL发展到3.0版本后改成了TLS&lt;/li&gt;
  &lt;li&gt;第一次请求中TLS握手的代价很大&lt;/li&gt;
  &lt;li&gt;后续的请求会共用第一次请求的协商结果&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 13 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HTTPS/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HTTPS/</guid>
        
        
      </item>
    
      <item>
        <title>优秀程序员的九种素质</title>
        <description>&lt;h3 id=&quot;一&quot;&gt;一&lt;/h3&gt;

&lt;p&gt;上周看到一篇文章，大意是阿里云源代码泄露，涉及多少家企业云云，看起来耸人听闻，点进去发现是有企业在使用阿里云做代码托管的时候，private internal 和 public 傻傻分不清，创建仓库用了 internal，结果只要是登录用户都可以看到并 clone 这些代码。事实上，这三个设置不仅是惯例，internel 的注释也写的清清楚楚，但是挡不住程序员不看。你永远不知道一个人的水准会低到什么地步，也许这些人从来没用过 GitHub 和 GitLab 呢？&lt;/p&gt;

&lt;p&gt;阿里云其实可以采用安全最小化原则，也就是常说的多一事不如少一事。最小化可用原则，对于操作系统来说，就是装最小化的包，没用的服务不启动，操作命令最小化，权限最小化等等。对于阿里云上的托管用户来说，internal 应该是个可有可无的功能，去掉是不是更好呢，也许值得平台方思考。&lt;/p&gt;

&lt;p&gt;永远不要高估用户的聪明程度。&lt;/p&gt;

&lt;h3 id=&quot;二&quot;&gt;二&lt;/h3&gt;

&lt;p&gt;本周我们上线了一款基础课专栏《软件工程之美》，最新的文章中阐述了软件过程和软件危机：&lt;/p&gt;

&lt;p&gt;软件是怎么被创造出来的？&lt;/p&gt;

&lt;p&gt;首先，它们的诞生都是有人想要造一个东西。这其中的很多故事你都耳熟能详：张小龙创造微信、乔布斯创造 iOS、暴雪想做一款不一样的射击游戏……他们首先有着这样的意图，然后，他们立项做这样的产品。&lt;/p&gt;

&lt;p&gt;每一款软件项目背后，都有很多人在参与。你无法想象微信这样复杂的 App 靠张小龙自己可以开发出来；你也不会相信 iOS 是乔布斯一个人设计出来的；像守望先锋这种游戏的背后，有成百上千的游戏策划、美术设计、程序开发人员。&lt;/p&gt;

&lt;p&gt;从立项到第一个版本的发布，每个成功的软件都需要有计划、有步骤地进行，什么时候发布第一个版本、第一个版本有什么样的功能、什么时候发布第二个版本、第二个版本有哪些地方要改进，这些都是研发过程中需要考虑的问题。&lt;/p&gt;

&lt;p&gt;比如，守望先锋是在 2013 年立项，他们计划做一个基于职业的 MMO 游戏，他们先花了几个月的时间做了第一个 Demo 演示，只有四个英雄和一个张地图。&lt;/p&gt;

&lt;p&gt;然后，他们要在 2014 年的“暴雪嘉年华”发布这个游戏的试玩版，包含 12 个英雄和 4 张地图。&lt;/p&gt;

&lt;p&gt;最终这个游戏在 2016 年 5 月正式发布了。这样从立项一步步到最终发布，历时三年，中间经过了诸多环节。&lt;/p&gt;

&lt;p&gt;类似的例子还有微信，2010 年 11 月 20 日立项，2011 年 1 月 21 日第一版上线，当时的功能还非常简陋，只能发送文本消息和照片。之后才是一个个版本的迭代，直到你现在看到的微信。&lt;/p&gt;

&lt;p&gt;像这种有人参与、有计划、有步骤地造一件产品，我们通常称为「工程」。&lt;/p&gt;

&lt;p&gt;那什么是软件危机呢？有兴趣可以订阅专栏阅读。软件工程是你通向程序之巅的必经之路。&lt;/p&gt;

&lt;h3 id=&quot;三&quot;&gt;三&lt;/h3&gt;

&lt;p&gt;周末读村上的书，他说自己能够持续写作和跑步，就是因为具备两个特质，一个是集中力，一个是耐力。村上写长篇的时候每天早晨集中写作四小时，他一个人坐在书桌前，没有任何打扰，将意识集中倾斜在书稿中，其他什么都不考虑。另外，没有耐力也不行。你集中写了一星期然后伸伸懒腰说，我累了，然后就休息一个月，这样是写不成长篇的。你必须每天集中写作，坚持半年，一年，甚至更长才行。&lt;/p&gt;

&lt;p&gt;一个优秀的程序员需要什么特质呢？由此我想到之前读过的一篇文章，是 Redis 之父萨尔瓦托·桑菲利普（Salvatore Sanfilippo）写的 9 种高能程序员的特质，重新意译一下，推荐给读者：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、高效完成子任务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从处理编程子任务上，可以看出一个程序员的短板和长处，比如实现一个函数或者一个算法。事实上，擅于使用基本的编程技能来高效完成任务的程序员，并没有人们想象的那么多。有时候，团队里有些不称职的程序员，他们甚至不知道该怎么写一个简单的排序算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、合理使用自己的经验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;桑菲利普认为，经验就是一系列解决方案，它们已经被证实可以用于处理一些重复性的任务。经验老道的程序员知道该如何处理各种子任务，这样不但省掉了很多设计工作，而且避免了很多设计错误，而设计错误是简洁性最大的敌人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、准确预测工期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;花在编码上的时间不仅要看数量，也要看质量。造成注意力不集中的因素既有内部的，也有外部的。集中注意力和避免被打扰，对于提高编程效率来说是至关重要的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、设计权衡：用 5% 换取 90%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目的「非根本性」目标在很大程度上导致了设计的复杂性，或者导致无法达成其他更重要的目标，因为根本性功能和非根本性功能在设计上存在竞争关系。如果意识不到这点，复杂性就会随之而来。对于设计者来说，如果项目要最大化产出，就要把精力集中在重要的事情上，并在合理的时间内完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、简洁性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简洁性是成败之间最为明显的分界点，理解复杂性的产生过程有助于理解什么是简洁性。不愿意做出设计权衡和设计错误的累积是导致复杂性的两个主要因素。我在第一点里讲的 Internal 其实是提高了复杂度导致用户选择错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、拒绝完美主义（为了偏袒设计而放弃生产力）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;完美主义可以分为两种：一种是追求程序极致性能的工程文化，另一种是个人特质。不管是哪一种完美主义，它们都会对程序员实现快速交付造成阻碍。完美主义和对外部评判的恐惧会导致设计上的偏袒，程序员根据主观的心理因素和无关紧要的衡量参数做出设计决策，却忽略了健壮性、简洁性和及时交付。&lt;/p&gt;

&lt;p&gt;我曾经服务过的一家公司就犯了这种错误。当然，错误不止于此。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、理解知识理论的价值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在处理复杂任务时，具备一些理论方面的知识会对设计产生重要影响，比如数据结构方面的知识、了解计算能力的局限性和一些重要的算法。虽然程序员没有必要成为无所不知的超级专家，但是至少要知道一些问题的潜在解决方案，避免设计出复杂、缓慢、低内存效能的解决方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、理解机器原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序的很多问题都是源于对计算机工作原理的误解，即使是使用高级语言开发的程序也不外乎如此。这种情况可能导致一个项目需要重新设计和实现，因为项目所使用的工具和算法出现了根本性的错误。&lt;/p&gt;

&lt;p&gt;7 和 8 说的道理差不多，这也是极客时间会连续推出数学、算法、数据结构、网络协议、软件工程等课程的原因，后面还有架构设计、操作系统、编译原理等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、调试技能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;查找和解决 bug 经常会占用程序员大量的时间。查找引起 bug 的问题根源，在合理的步骤内修复 bug，以简单的方式编写包含较少 bug 的代码，对于程序员来说，做到这几点就可以显著提升效率。&lt;/p&gt;

&lt;p&gt;能否运用调试技能快速解决问题是衡量一个程序员水平的重要标准。&lt;/p&gt;

&lt;p&gt;你具备这些特质嘛？我觉得村上说的没错，程序员同时还需要集中力和耐力。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/</guid>
        
        <category>闲谈</category>
        
        
      </item>
    
      <item>
        <title>WebRTC架构及原理</title>
        <description>&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002625734050.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主体包含3个模块，音频引擎，视频引擎，传输层。最核心的在于传输层。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;音频引擎包含回声消除，降噪音频编解码等。音频采集和渲染层 可override自己实现&lt;/li&gt;
  &lt;li&gt;视频引擎包含VP8，VP9，H264编解码，图形增强的算法。视频采集层 可override自己实现，不包含图像渲染层&lt;/li&gt;
  &lt;li&gt;传输层包含P2P,STUN,TURN,ICE，RTP,RTSP等传输控制协议。网络IO层可override 自己实现&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;信令服务器&quot;&gt;信令服务器&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002625864892.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;nat穿越&quot;&gt;NAT穿越：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;设备大多在网关背后，想要简历P2P连接就要穿过网关，连接到内网的设备，网关一般包含以下4种防火墙类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;完全锥形：网关只做简单的映射，最容易穿越&lt;/li&gt;
  &lt;li&gt;地址限制锥形：对于主动访问外网的IP做记录，容易穿越&lt;/li&gt;
  &lt;li&gt;端口限制锥形：对主动访问外网的IP和Port做记录，比上一个更严格&lt;/li&gt;
  &lt;li&gt;对称型：内网与外网通信会建立一个IP和Port,不同的外网地址建立不同的IP和port,基本无法穿越。&lt;strong&gt;是否可用中继服务器的方式打洞&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;穿越原理&quot;&gt;穿越原理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C1, C2向STUN发消息&lt;/li&gt;
  &lt;li&gt;交换公网IP和Port&lt;/li&gt;
  &lt;li&gt;C1-&amp;gt;C2, C2-&amp;gt;C1。如果是对称型需要端口猜测&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;stun&quot;&gt;STUN:&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;目的就是获取设备的公网IP和Port然后互相交换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;turn&quot;&gt;TURN:&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;目的是解决对称NAT无法穿越的问题，用来转发数据。
获取到双方地址后尝试P2P链接，如果链接失败，则使用数据转发&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;ice&quot;&gt;ICE:&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;包含了STUN, TURN的一整个解决方案框架，不断选择最优的链接通路，获取不同的candidate，尝试最优的链路。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;收集Candidata&lt;/li&gt;
  &lt;li&gt;对Candidate Pair排序，筛选出最合适的候选者对，否则直接检查浪费时间
    &lt;ul&gt;
      &lt;li&gt;一方收集到所有候选者后，通过信令传给对方&lt;/li&gt;
      &lt;li&gt;另一方收到候选者后也做收集工作&lt;/li&gt;
      &lt;li&gt;当双方拿到全部列表后，将候选者形成匹配对儿&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对Candidate Pair连通性检查
    &lt;ul&gt;
      &lt;li&gt;对每个后选对进行发送，接收检查&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002626005389.png&quot; style=&quot;zoom:80%&quot; /&gt;
***&lt;/p&gt;

&lt;h4 id=&quot;candidata&quot;&gt;Candidata&lt;/h4&gt;
&lt;p&gt;是一个地址，例如： …UDP…192.168.1.2  1816 type host等协议，地址，类型
类型包含3个：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;主机候选者， 本机网卡上所有地址和类型&lt;/li&gt;
  &lt;li&gt;反射候选者，NAT穿越后的地址和类型， SUTN/TURN&lt;/li&gt;
  &lt;li&gt;中继候选者， TURN服务开通后的地址和类型， TURN&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;sdp&quot;&gt;SDP&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;Session Description Protocol ， 是设备之间互通配置信息的协议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002626096788.png&quot; alt=&quot;&quot; /&gt;
上图中是SDP基本内容， 其中有2个candidate, 一个是本机UDP,另一个是NAT穿越后的地址UDP&lt;/p&gt;

&lt;p&gt;SDP规范包括2部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;会话层： 会话时间，名称等全局基本信息，多个媒体信息&lt;/li&gt;
  &lt;li&gt;媒体层
    &lt;ul&gt;
      &lt;li&gt;媒体格式:音频、视频、数据&lt;/li&gt;
      &lt;li&gt;传输协议：TCP/UDP&lt;/li&gt;
      &lt;li&gt;传输IP和Port&lt;/li&gt;
      &lt;li&gt;媒体负载类型:VP8 VP9 h264. h265&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;m 媒体名称和地址, c 传输层信息, b 带宽信息 ,a 各种属性定义和对m的描述&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WebRTC中的SDP包含5个部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;会话元&lt;/li&gt;
  &lt;li&gt;网络描述&lt;/li&gt;
  &lt;li&gt;流描述&lt;/li&gt;
  &lt;li&gt;安全描述&lt;/li&gt;
  &lt;li&gt;服务质量&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;连接流程图&quot;&gt;连接流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002626241435.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/WebRTC%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/WebRTC%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
        
        <category>webRTC</category>
        
        
      </item>
    
      <item>
        <title>GCC 拥塞控制算法详解</title>
        <description>&lt;h2 id=&quot;gcc-拥塞控制算法&quot;&gt;GCC 拥塞控制算法&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;谷歌使用GCC (Google Congestion Control ) 在 WebRTC中的拥塞控制算法，包含2个部分，一个是基于丢包的用拥塞控制，一个是基于延迟的拥塞控制。
最终基于丢包的码率估计值和基于延迟的码率估计值做比较，使用最小的码率估计值作为最终发送码率。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;早期实现中2部分分别在发送端和接收端实现，接收端实现延迟梯度算法计算出估计带宽，反馈给发送端，发送端再根据2个算法结果确定最终发送码率。最近的WebRTC中的GCC都在发送端来实现，所以需要接收端在RTCP中反馈包达到时间用来计算延迟。&lt;/p&gt;

&lt;h3 id=&quot;基于丢包的带宽估计&quot;&gt;基于丢包的带宽估计&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;思想是基于丢包多少来判断网络拥塞程度，丢包少提高发送码率，丢包多降低码率。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接收端通过在RTCP协议中的fraction lost字段反馈给发送端丢包率， WebRTC通过以下公式估算发送码率，式中 As(tk) 即为 tk 时刻的带宽估计值，fl(tk)即为 tk 时刻的丢包率：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002700924519.png&quot; style=&quot;zoom=100%&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fl &amp;gt; 10%: 有拥塞，根据丢包率降低带宽
2%&amp;lt; fl &amp;lt; 10%: 正常，保持当前码率不变，避免因波动丢包等误判导致降低码率
fl &amp;lt; 2% : 网络良好， As + 5% 提高带宽来探测真实可用带宽
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;基于延迟梯度的带宽估计&quot;&gt;基于延迟梯度的带宽估计&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;接收端在RTCP中增加transport-cc-feedback字段反馈所有媒体包到达的时间，发送端根据接受延迟和发送间隔计算出延迟梯度，从而估计带宽。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;步骤有3个：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;到达时间滤波器&lt;/li&gt;
  &lt;li&gt;过载检测器&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;速率控制器&lt;/p&gt;

    &lt;p&gt;到达滤波器根据包的到达时延和发送间隔，计算延迟变化，用卡尔曼滤波器平滑处理消除网络噪音。
  延迟变化作为过载检测器的输入，判断出当前网络状态underuse/overuse/normal。 
  速率控制器根据网络状态和带宽公式计算出带宽。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;到达时间滤波器&quot;&gt;到达时间滤波器&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002707293607.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用两个包到达时间间隔减去发送时间间隔，得到一个延迟的变化，公式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002708393823.png&quot; alt=&quot;图片12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;理想情况下，每个包的到达时间间隔和发送间隔是一样的，所以延迟梯度为0。如果某一个包因为拥塞导致排队，那么延迟梯度就不为0。为了计算精确，计算策略如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;由于测量粒度很小，为了避免网络噪音的误差，使用卡尔曼滤波来平滑延迟梯度的结果&lt;/li&gt;
  &lt;li&gt;实现中是按照数据组来计算整体延迟梯度，不是按单个包计算。发送时间间隔小于5ms位一个组。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;过载检测器&quot;&gt;过载检测器&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;将延迟梯度和某个阈值比较，高于阈值则为拥塞，低于阈值则为良好，阈值是动态调整的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002702640507.png&quot; style=&quot;zoom=100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;m(t&lt;sub&gt;i&lt;/sub&gt;)表示计算出的延迟梯度&lt;/p&gt;

&lt;p&gt;γ(t&lt;sub&gt;i&lt;/sub&gt;)表示判断阈值&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002703739032.png&quot; alt=&quot;图片32&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002704016723.png&quot; alt=&quot;图片24&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面为阈值自适应算法，当梯度减小时，阈值会以更慢的速率减小。梯度增加时，阈值会以更慢的速率增加。阈值的减小速度要小于增加速度，因为最终目的还是要探测更多可用的网络带宽。&lt;/p&gt;

&lt;h4 id=&quot;速率控制器&quot;&gt;速率控制器&lt;/h4&gt;

&lt;p&gt;根据过载探测器输出的信号，驱动速率控制状态机，估算出当前网络速率。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当收到overuse，进入decrease状态&lt;/li&gt;
  &lt;li&gt;当收到normal，进入increase状态&lt;/li&gt;
  &lt;li&gt;当收到underuse， 进入hold状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002704269607.png&quot; style=&quot;zoom=100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个状态机输出的是带宽估计值。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当前处于降低带宽值状态，发现带宽低载或者正常，就不再下降，如果依然过载，继续降&lt;/li&gt;
  &lt;li&gt;当前处于平衡状态，发现带宽正常，则尝试增加带宽估计值，寻求达到低载状态，争夺多一点的带宽资源&lt;/li&gt;
  &lt;li&gt;当前处于增加带宽值状态，发现带宽正常，继续增加，发现过载，降低带宽估计值，发现低载，目的达到了，保持当前状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002704602190.png&quot; style=&quot;zoom=100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中η=1.05，α=0.85。 当increase时，以上一次估计码率乘1.05作为当前码率。 当decrease时以当前估算的接受端码率 乘0.85作为当前码率，hold状态不变。&lt;/p&gt;

&lt;p&gt;最终基于丢包的码率估计值和基于延迟的码率估计值做比较，使用最小的码率估计值作为最终发送码率。&lt;/p&gt;

</description>
        <pubDate>Wed, 05 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/GCC-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/GCC-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>webRTC</category>
        
        
      </item>
    
      <item>
        <title>BBR 拥塞控制算法详解</title>
        <description>&lt;h2 id=&quot;bbr-拥塞控制算法&quot;&gt;BBR 拥塞控制算法&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BBR: Bottleneck Bandwidth and RTT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;BBR 发明的目的是解决2个问题。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在有一定丢包率的网络链路上充分利用带宽&lt;/li&gt;
  &lt;li&gt;降低网络链路上的buffer占用率，降低延迟。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BBR 原理 使用极大带宽和极小延迟的乘积作为发送窗口大小。&lt;/p&gt;

&lt;h3 id=&quot;其他拥塞算法原理&quot;&gt;其他拥塞算法原理&lt;/h3&gt;
&lt;p&gt;所有拥塞算法目标都是最大化利用网络上瓶颈链路的带宽，通常办法是不断增加数据量，直到发生丢包或者延迟增大等这些信号表明当前带宽已经使用100%。
GCC等其他算法都是基于某些信号认为网络发生拥塞，例如丢包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络链路上能容纳的数据量=链路带宽×往返时延&lt;/strong&gt;
但是常用的标准TCP拥塞控制算法的&lt;strong&gt;问题&lt;/strong&gt;在于：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;网络上丢包不都是拥塞导致的，可能是传输错误导致的丢包，如果因为传输错误的丢包影响算法对带宽的评估，是失败的。&lt;/li&gt;
  &lt;li&gt;网络中的缓冲区buffer会被计算在内被占用，计算出的带宽=真实带宽+buffer大小， 问题称为buffrbloat （缓冲区膨胀）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;缓冲区膨胀问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;增加网络延迟&lt;/strong&gt;， buffer东西越多，排队时间越长&lt;/li&gt;
  &lt;li&gt;共享网络瓶颈的连接较多时，可能导致缓冲区被填满而丢包，被误认为发生拥塞。  &lt;strong&gt;这个地方有点不理解&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bbr和常规算法区别&quot;&gt;BBR和常规算法区别&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;既然区分不了拥塞丢包和错误丢包，就不考虑丢包这个信号&lt;/li&gt;
  &lt;li&gt;不断加快数据发送量，容易产生缓冲区膨胀，就单独估计带宽和延迟，而不是简单加快发送数据量。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;bbr算法步骤&quot;&gt;BBR算法步骤&lt;/h3&gt;

&lt;p&gt;BBR分为3个阶段&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;慢启动：增加数据量，计算最大发送窗口&lt;/li&gt;
  &lt;li&gt;排空阶段：清空数据量，基本不发数据，计算最低延迟&lt;/li&gt;
  &lt;li&gt;稳定阶段：交替探测带宽和延迟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;下图是发送速率(发送窗口)和时延与网络中的数据量关系&lt;/em&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002691822869.png&quot; style=&quot;zoom:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着数据量增加，发送速率达到最高点100%即达到真实带宽，再继续增加数据量会占用buffer而不会增加发送率，RTT在发送率到达100%之前都是最小值，超过后开始产生延迟，且越来越高，直到buffer溢出发生丢包。&lt;/p&gt;

&lt;p&gt;BBR会在窗口1和窗口2之间停下，会超过真实带宽单但没到丢包。
基于丢包的标准TCP会在窗口2停下，直到丢包才停止。&lt;/p&gt;

&lt;p&gt;所以BBR需要计算的就是蓝色和绿色的转折点，分别代表最低延迟和最大发送窗口。&lt;/p&gt;

&lt;h4 id=&quot;计算最大发送窗口带宽探测&quot;&gt;计算最大发送窗口(带宽探测)&lt;/h4&gt;

&lt;p&gt;刚开始时采用慢启动，每个包都会收到ACK，当发现通过i计算ACK得到的带宽 没有因为增加发送率而增加时，就知道此时已经占用了buffer，开始结束第一阶段，得到的值是3倍bandwight。&lt;/p&gt;

&lt;h4 id=&quot;计算最低延迟排空阶段&quot;&gt;计算最低延迟（排空阶段）&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;因为要计算最低延迟，需要将inflight数据清空，发送极少数据才能保证RTT是极小值. 指数降低发送速率，buffer被慢慢排空，把上一个阶段占用的2倍bandwight的buffer消耗掉，直到延迟不再降低，则为最小延迟(因为buffer的存在说明有数据在排队，会增加延迟)。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;稳定阶段&quot;&gt;稳定阶段&lt;/h4&gt;
&lt;p&gt;以8个往返为周期，第一个往返时间里，BBR增加为1.25倍的发包率，在第二个时间里，降低为0.85的发包率。后面6个往返里使用估计的带宽发包。
这里主要是&lt;strong&gt;带宽探测&lt;/strong&gt;任务，&lt;/p&gt;

&lt;p&gt;BBR每过10s ，如果最小延迟没有变化，就进入&lt;strong&gt;探测阶段&lt;/strong&gt;，持续时间200ms， 发送窗口固定4个包，用来探测最小延迟作为新的延迟估计。&lt;strong&gt;大约2%的时间BBR用极低的发包率来测量延迟&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;性能评估&quot;&gt;性能评估&lt;/h3&gt;

&lt;h4 id=&quot;bbr对于带宽变化的响应&quot;&gt;BBR对于带宽变化的响应&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;大部分时间内带宽的变化比延迟变化更频繁，BBR绝大多数时间都处于带宽探测阶段 *蓝色是延迟，绿色是inflight数量* 当带宽增长一倍时，BBR会每个周期向上探测1.25倍，大概3个周期后就能达到增长后的带宽。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002692643086.png&quot; style=&quot;zoom:90%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当带宽降低一半时，多出来的包占用了buffer，导致延迟显著增加，但是延迟采用的是不发包测得的极小值，对于刚刚实际延迟增加没有影响。
带宽估计 是使用一段滑动窗口内的极大值，滑动窗口是多个往返周期，所以需要等当前任务滑出窗口后，发送窗口减半，估计带宽降低一半，发送包速率键盘，buffer被排空，延迟才会缓慢下降。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002692913442.png&quot; style=&quot;zoom:90%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;带宽增加一倍，BBR用时1.5s收敛; 带宽降低一半，BBR用时4s收敛;&lt;/p&gt;

&lt;h4 id=&quot;bbr与标准tcp效果比对&quot;&gt;BBR与标准TCP效果比对&lt;/h4&gt;
&lt;p&gt;BBR 要解决的第一个问题，丢包错误导致误判拥塞问题。
只要有0.01%丢包率，标准TCP带宽只剩下30%。 0.1%丢包率TCP带宽只有10%。1%丢包率几乎停滞。
而BBR在5%以下几乎没有带宽损失， 15%时仍然有75%带宽
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002693162811.png&quot; style=&quot;zoom:90%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;BBR 要解决的第二个问题，降低延迟，减少缓冲区膨胀。
TCP倾向于填满缓冲区，延迟就越高，当用户网络接入速度很慢时，延迟可能超过造成连接失败。
BBR不会占用多于的缓冲区，会有单独的延迟探测阶段可以避免这个问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002693358027.png&quot; style=&quot;zoom:90%&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 02 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/BBR-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/BBR-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>webRTC</category>
        
        
      </item>
    
      <item>
        <title>TCP相关控制算法详解</title>
        <description>&lt;h2 id=&quot;tcp相关控制算法&quot;&gt;TCP相关控制算法&lt;/h2&gt;
&lt;h4 id=&quot;以段为单位发送数据&quot;&gt;以段为单位发送数据&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在TCP建立连接三次握手的时候，协议中带有自己接口最适合的MSS (Maximum Segment Size)大小，发送方以后就按照这个大写切分数据段。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;滑动窗口来提高传输速度&quot;&gt;滑动窗口来提高传输速度&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;原先发送发每发送一条数据，都要等待接收方的反馈才会发送下一条，这样效率太低。
现在定义一个窗口大小，每次发送窗口大小内数据不等待反馈，全部发送完毕等待一次反馈，相比原来节约很多时。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002713341011.png&quot; alt=&quot;截屏2020-07-27 下午11.11.45&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;滑动窗口与重发机制&quot;&gt;滑动窗口与重发机制&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在使用窗口控制中，出现段丢失或者应答丢失会不会出发重传？ - **==数据应答丢失==** ![截屏2020-07-27 下午11.14.25](http://image.smartjames.cn/mweb/20200916/16002713675070.png)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;==数据段丢失==&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002713787395.png&quot; alt=&quot;截屏2020-07-27 下午11.14.45&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;流控制-flow-control&quot;&gt;流控制 flow control&lt;/h4&gt;
&lt;p&gt;主要利用滑动窗口和上面相关设计实现，滑动窗口主要由接收方反馈缓存情况来维护，维护接收方的承受能力&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;接收端主机向发送端通知自己可以接收数据的大小，于是发送端会发生不超过这个限度的数据，
这个限度就是窗口大小，由接收端确定的。值越大说明网络的吞吐量越高。
如果接收端数据缓冲区一旦溢出，窗口大小也会减小并发给发送端。

若接收端无法及时清理缓冲区，导致缓冲区没有多于空间，发送方会等待接收方通知新的有效窗口值，
如果过了超时时间没有收到新通知，会发送一个窗口探测包，获取窗口大小。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002714362536.png&quot; alt=&quot;截屏2020-09-16 下午11.50.12&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;拥塞控制-congestion-control&quot;&gt;拥塞控制 congestion control&lt;/h4&gt;
&lt;p&gt;主要利用拥塞窗口实现，拥塞窗口主要由发送方的拥塞控制算法检测出的网络拥塞程度来决定的，维护网络带宽的承受能力&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;慢启动的时候，初始大小设为1个MSS，发送后收到一个ACK，拥塞窗口增加1。
在发送数据包时将拥塞窗口和滑动窗口做比较，用较小值继续作为阈值继续发送。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002714935699.png&quot; alt=&quot;截屏2020-07-27 下午11.28.36&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于拥塞窗口会以指数型激增，导致网络拥塞，所以引入阈值，当拥塞窗口到达阈值，后面会降低增长速度 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002715071116.png&quot; alt=&quot;截屏2020-07-27 下午11.28.42&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TCP刚开始没有设置慢启动阈值，所以会指数型上升直到遇到超时（采用重发机制,不同于下面的高速重发机制）(==①慢启动阶段==)。
超出带宽上限。此时设置拥塞窗口为当时窗口一半的大小，cwnd缓慢增加( ==②拥塞避免阶段==)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;超时重发： 数据段发送后，在一个时间周期内没有收到ACK，则自动重发
快速重发： 在一个滑动窗口内，收到3次重复ACK,则启动重发，不需要等待超时
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由重复确认应答进行高速重发控制时，慢启动阈值设置为当时窗口一半，拥塞窗口大小设置为慢启动阈值+3个数据段。&lt;/p&gt;

&lt;p&gt;快速重发后没有使用慢启动算法，而是拥塞避免，所以又叫快恢复阶段&lt;/p&gt;

&lt;h5 id=&quot;延迟确认应答&quot;&gt;延迟确认应答&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;因为有滑动窗口的概念，应答少一些也无妨，所以延迟确认得以实现，例如每次双数的数据段到达才回复ACK，或者最多0.5s内没收到下一个数据段就回复ACK。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是提高网络利用率降低计算机处理负荷的一种较优机制.&lt;/p&gt;

&lt;h5 id=&quot;捎带应答&quot;&gt;捎带应答&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在使用延迟应答的同时，拿到程序对于本次接收消息的回复内容，放在ACK中发送给发送方.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;常见是拥塞控制算法&quot;&gt;常见是拥塞控制算法&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Reno：Linux内核使用的
BBR： Google 2016年提出的
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;reno&quot;&gt;Reno&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;分为4个阶段，慢启动，拥塞避免，快重传，快恢复
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002715755176.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与TCP 内部拥塞控制相似。&lt;/p&gt;

&lt;h4 id=&quot;缩略词&quot;&gt;缩略词&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RTT: round-trip delay time 来回通信时延 
TD:  Triple duplicate acknowledgements 三次重复确认应答
TO:  TimeOut  丢包超时
MSS: Maximum Segment Size 最大包尺寸
ssthresh: slow start threshold 慢启动阈值
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Tue, 28 Jul 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/07/TCP%E7%9B%B8%E5%85%B3%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/07/TCP%E7%9B%B8%E5%85%B3%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>webRTC</category>
        
        
      </item>
    
      <item>
        <title>SIG蓝牙协议5.2版本更新内容</title>
        <description>&lt;h4 id=&quot;主要是3块新特性&quot;&gt;主要是3块新特性&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Enhanced Attribute Protocol&lt;/li&gt;
  &lt;li&gt;LE Power Control&lt;/li&gt;
  &lt;li&gt;LE Isochronous Channels&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUD: Protocol Data Unit 协议数据单元 被某一层处理为指定数据格式的数据。

SDU: Service Data Unit 服务数据单元 在某一层中还未处理的数据，比如输入的数据，叫SDU,封装成PDU通过层与层之间的管道传输给下一层。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本层的PDU是下一层的SDU,本层的SDU是上一层的PDU&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;一enhanced-att&quot;&gt;一、Enhanced ATT&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632642584.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ATT: 定义了不同服务的属性参数和可使用的命令，用来作为主从设备间的信息交换个协商。&lt;/p&gt;

&lt;p&gt;MTU(Maximum Transmission Unit) 是不同协议的最大数据处理能力，决定不同层协议处理最大PUD/SDU的尺寸。ATT中定义了服务的MTU,在L2CAP根据上下层不同的MTU来分割/组合数据，来适配整体数据通路的PDU/SDU。&lt;/p&gt;

&lt;p&gt;LE5.1之前：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ATT与L2CAP之间的MTU是固定的，建立连接后不能改。&lt;/li&gt;
  &lt;li&gt;数据处理是串行的，不同业务MTU必须在上一个PDU/SDU完成后才能执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LE5.2:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;MTU在ATT和L2CAP之间不再一一对应，可以互相独立配置，即ATT和L2CAP之间的MTU和PDU大小动态配置。&lt;/li&gt;
  &lt;li&gt;不同业务PDU可以交叉处理，减小数据延迟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EATT相比ATT的影响：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;新的PDU只能再EATT上使用&lt;/li&gt;
  &lt;li&gt;某些ATT PDU只能用在ATT上&lt;/li&gt;
  &lt;li&gt;一些PDU的定义或流程被细化或优化&lt;/li&gt;
  &lt;li&gt;EATT只能加密连接使用，ATT可以通过未加密、加密连接&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;二le-power-control&quot;&gt;二、LE Power Control&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在蓝牙接收错误率BER超过0.1%时，连接被认为是质量不好连接 增加了发射功率的动态管理，通过信号响度RSSI的监控，通知发射方增加或减少发射功率。使接收器的信号强度落在不太强也不太弱的区域，刚好满足应用又省电。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;三le-isochronous-channels&quot;&gt;三、LE Isochronous Channels&lt;/h4&gt;
&lt;p&gt;定义了一个有时间依赖的数据传输通道和传输策略。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;增加对于一对多接收方同步获取数据的机制&lt;/li&gt;
  &lt;li&gt;允许发送方在指定时间外丢弃数据，保证接收方数据满足时效要求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该通道支持链接模式和广播模式.
俩种模式下 ISO异同点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个BIG CIG最多包含31个BIS CIS&lt;/li&gt;
  &lt;li&gt;CIS中从设备对主设备有信息反馈，BIS没有&lt;/li&gt;
  &lt;li&gt;BIS重传是通过接收方信息反馈决定， CIS是强制的&lt;/li&gt;
  &lt;li&gt;CIG中CIS同步通过CIG的时间以及CIS时间参数实现，BIG中的BIS通过周期广播的PDU实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;能实现多重串流音频（Multi-Stream Audio）和音频分享（Audio Sharing）&lt;/p&gt;

&lt;h5 id=&quot;链接模式&quot;&gt;链接模式&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;称作CIS (LE Connected Isochronous Stream)逻辑传输通道，可将延迟数据丢弃。 不同的CIS组成CIG ( Connected Isochronous Groups ),同一个CIG内的CIS有相同的时间戳，保证同一个group内数据同步。例如一对TWS耳机
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632747277.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;广播模式&quot;&gt;广播模式&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;称作BIS (Broadcast Isochronous Stream)。 多个BIS 可组成BIG (Broadcast Isochronous Groups).通过一个周期广播的PUD实现。 该PDU包含针对每个BIS的时间戳，一旦同步，广播接收者变成同步接收者。例如，广场舞大妈蓝牙耳机听同一音源歌曲。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633057507.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/SIG%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE5.2%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/SIG%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE5.2%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9/</guid>
        
        <category>BLE</category>
        
        
      </item>
    
      <item>
        <title>蓝牙协议栈</title>
        <description>&lt;h3 id=&quot;协议栈内容&quot;&gt;协议栈内容&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632222709.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;phy层&quot;&gt;PHY层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Physical layer 用来指定BLE所用的无线频段，调试解调方式和方法等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ll层&quot;&gt;LL层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;link layer 是协议栈的核心，选择使用哪个射频通道进行通信，怎么识别inflight数据包，在哪个时间点发送数据包，哪个时间点接收数据包，怎么保证数据完整性，ACK接收，如何重传，链路管理控制等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;hci层&quot;&gt;HCI层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host controller interface  HCI是可选的，主要用于2颗芯片实现BLE协议栈的场合，规范两者之间的通信协议和通信命令等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;gap层&quot;&gt;GAP层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Generic access profile 对LL层payload 如何进行解析的一种方式，最简单。GAP对payload进行一些规范和定义，因此功能有限，主要用来广播，扫描和发起连接等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;l2cap层&quot;&gt;L2CAP层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Logic link control and adaption protocol 对LL进行简单封装，LL只关心传输的数据本身，L2CAP区分是加密通道还是普通通道，同时对连接间隔进行管理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;smp&quot;&gt;SMP&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Security manager protocol 管理BLE连接的加密和安全
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;att&quot;&gt;ATT&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attribute protocol ATT层用来定义用户命令以及命令操作的数据，比如读、写、通知等。Attribute定义数据和数据可以使用的命令。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;gatt&quot;&gt;GATT&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Generic attribute profile 用来规范attribute 中的数据内容，运用group来对attribute进行分类管理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;设备连接&quot;&gt;设备连接&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;连接指设备A和B 一对一‘同步’成功 连接成功包含以下几点： - 设备A和B对接下来要使用的物理信道达成一致 - 设备A和B双方建立一个共同的时间锚点，把时间原点变成同一个点 - 设备A和B时钟同步成功，明确双方什么时候发数据，什么时候接收数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632477431.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图表示连接成功后，A将以CI为周期向B发送数据包，B将以CI (connection interval)为周期打开射频接收窗口来接收A的数据包。在B接收A数据包后150us后，切换为发送状态，把数据发送给A，A切换为接收状态接收B的数据。&lt;/p&gt;

&lt;p&gt;以发送0x53为例，看看不同协议层做了些什么&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对开发者来说，很简单，他只需要调用send(0x53)&lt;/li&gt;
  &lt;li&gt;GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样- GATT层把数据打包成130053（小端模式！）&lt;/li&gt;
  &lt;li&gt;ATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053&lt;/li&gt;
  &lt;li&gt;L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053&lt;/li&gt;
  &lt;li&gt;LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：
    &lt;ul&gt;
      &lt;li&gt;AAAB5D65501E08040004001B130053D550F6&lt;/li&gt;
      &lt;li&gt;AA – 前导帧(preamble)&lt;/li&gt;
      &lt;li&gt;0x50655DAB – 访问地址(access address)&lt;/li&gt;
      &lt;li&gt;1E – LL帧头字段(LL header)&lt;/li&gt;
      &lt;li&gt;08 – 有效数据包长度(payload length)&lt;/li&gt;
      &lt;li&gt;04000400 – ATT数据长度，以及L2CAP通道编号&lt;/li&gt;
      &lt;li&gt;1B – notify command&lt;/li&gt;
      &lt;li&gt;0x0013 – 电量数据handle&lt;/li&gt;
      &lt;li&gt;0x53 – 真正要发送的电量数据&lt;/li&gt;
      &lt;li&gt;0xF650D5 – CRC24值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88/</guid>
        
        <category>BLE</category>
        
        
      </item>
    
  </channel>
</rss>
