<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 07 Jan 2021 11:11:47 +0800</pubDate>
    <lastBuildDate>Thu, 07 Jan 2021 11:11:47 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>WebRTC基于GCC的拥塞控制(下)-实现分析</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;从源代码实现角度对WebRTC的GCC算法进行分析。主要内容包括： RTCP RR的数据源、报文构造和接收，接收端基于数据包到达延迟的码率估计，发送端码率的计算以及生效于目标模块。&lt;/p&gt;

&lt;p&gt;拥塞控制是实时流媒体应用的重要服务质量保证。通过本文和文章[1][2]，从数学基础、算法步骤到实现细节，对WebRTC的拥塞控制GCC算法有一个全面深入的理解，为进一步学习WebRTC奠定良好基础。&lt;/p&gt;

&lt;h3 id=&quot;1-gcc算法框架再学习&quot;&gt;1 GCC算法框架再学习&lt;/h3&gt;

&lt;p&gt;本节内容基本上是文章[1]第1节的复习，目的是再次复习GCC算法的主要框架，梳理其算法流程中的数据流和控制流，以此作为后续章节的行文提纲。GCC算法的数据流和控制流如图1所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20210105/16098246662333.png&quot; alt=&quot;2844879-91005d8cd84ba66e&quot; /&gt;&lt;/p&gt;

&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图1 GCC算法数据量和控制流&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;对发送端来讲，GCC算法主要负责两件事：1)接收来自接收端的数据包信息反馈，包括来自RTCP RR报文的丢包率和来自RTCP REMB报文的接收端估计码率，综合本地的码率配置信息，计算得到目标码率A。2)把目标码率A生效于目标模块，包括PacedSender模块，RTPSender模块和ViEEncoder模块等。&lt;/p&gt;

&lt;p&gt;对于接收端来讲，GCC算法主要负责两件事：1）统计RTP数据包的接收信息，包括丢包数、接收RTP数据包的最高序列号等，构造RTCP RR报文，发送回发送端。2）针对每一个到达的RTP数据包，执行基于到达时间延迟的码率估计算法，得到接收端估计码率，构造RTCP REMB报文，发送回发送端。&lt;/p&gt;

&lt;p&gt;由此可见，GCC算法由发送端和接收端配合共同实现，接收端负责码率反馈数据的生成，发送端负责根据码率反馈数据计算目标码率，并生效于目标模块。本文接下来基于本节所述的GCC算法的四项子任务，分别详细分析之。&lt;/p&gt;

&lt;h3 id=&quot;2-rtcp-rr报文构造及收发&quot;&gt;2 RTCP RR报文构造及收发&lt;/h3&gt;
&lt;p&gt;关于WebRTC上的RTP/RTCP协议的具体实现细节，可参考文章[3]。本节主要从RR报文的数据流角度，对其数据源、报文构造和收发进行分析。其数据源和报文构造如图2所示，报文接收和作用于码率控制模块如图3所示。&lt;/p&gt;

&lt;p&gt;在数据接收端，RTP数据包从Network线程到达Worker线程，经过Call对象，VideoReceiveStream对象到达RtpStreamReceiver对象。在该对象中，主要执行三项任务：1)接收端码率估计；2) 转发RTP数据包到VCM模块；3)接收端数据统计。其中1)是下一节的重点，2)是RTP数据包进一步组帧和解码的地方；3)是统计RTP数据包接收信息，作为RTCP RR报文和其他数据统计模块的数据来源，是我们本节重点分析的部分。&lt;/p&gt;

&lt;p&gt;在RtpStreamReceiver对象中，RTP数据包经过解析得到头部信息，作为输入参数调用ReceiveStatistianImpl::IncomingPacket()。该函数中分别调用UpdateCounters()和NotifyRtpCallback()，前者用来更新对象内部的统计信息，如接收数据包计数等，后者用来更新RTP回调对象的统计信息，该信息用来作为getStats调用的数据源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20210105/16098246932212.png&quot; alt=&quot;2844879-ed098a4958b2ee2c&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图2 RTCP RR报文数据源及报文构造&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;RTCP发送模块在ModuleProcess线程中工作，RTCP报文周期性发送。当线程判断需要发送RTCP报文时，调用SendRTCP()进行发送。接下来调用PrepareReport()准备各类型RTCP报文的数据。对于我们关心的RR报文，会调用AddReportBlock()获取数据源并构造ReportBlock对象:该函数首先通过ReceiveStatistianImpl::GetStatistics()拿到类型为RtcpStatistics的数据源，然后以此填充ReportBlock对象。GetStatistics()会调用CalculateRtcpStatistics()计算ReportBlock的每一项数据，包括丢包数、接收数据包最高序列号等。ReportBlock对象会在接下来的报文构造环节通过BuildRR()进行序列化。RTCP报文进行序列化之后，交给Network线程进行网络层发送。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20210105/16098247057859.png&quot; alt=&quot;2844879-ae80527d779c3402&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图3 RTCP RR报文接收及反馈&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;在发送端(即RTCP报文接收端)，RTCP报文经过Network线程到达Worker线程，最后到达ModuleRtpRtcpImpl模块调用IncomingRtcpPacket()进行报文解析工作。解析完成以后，调用TriggerCallbacksFromRTCPPackets()反馈到回调模块。在码率估计方面，会反馈到BitrateController模块。ReportBlock消息最终会到达BitrateControllerImpl对象，进行下一步的目标码率确定。&lt;/p&gt;

&lt;p&gt;至此，关于RTCP RR报文在拥塞控制中的执行流程分析完毕。&lt;/p&gt;

&lt;h3 id=&quot;3-接收端基于延迟的码率估计&quot;&gt;3 接收端基于延迟的码率估计&lt;/h3&gt;
&lt;p&gt;接收端基于数据包到达延迟的码率估计是整个GCC算法最复杂的部分，本节在分析WebRTC代码的基础上，阐述该部分的实现细节。&lt;/p&gt;

&lt;p&gt;接收端基于延迟码率估计的基本思想是：RTP数据包的到达时间延迟m(i)反映网络拥塞状况。当延迟很小时，说明网络拥塞不严重，可以适当增大目标码率；当延迟变大时，说明网络拥塞变严重，需要减小目标码率；当延迟维持在一个低水平时，目标码率维持不变。其主要由三个模块组成：到达时间滤波器，过载检查器和速率控制器。&lt;/p&gt;

&lt;p&gt;在实现上，WebRTC定义该模块为远端码率估计模块RemoteBitrateEstimator，整个模块的工作流程如图4所示。需要注意的是，该模块需要RTP报文扩展头部abs-send-time的支持，用以记录RTP数据包在发送端的绝对发送时间，详细请参考文献[4]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20210105/16098247269312.png&quot; alt=&quot;2844879-71027dc71720dd9c&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图4 GCC算法基于延迟的码率估计&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;接收端收到RTP数据包后，经过一系列调用到RtpStreamReceiver对象，由该对象调用远端码率估计模块的总控对象RemoteBitrateEstimatorAbsSendTime，由该对象的总控函数IncomingPacketInfo()负责整个码率估计流程，如图4所示，算法从左到右依次调用子对象的功能函数。&lt;/p&gt;

&lt;p&gt;总控函数首先调用InterArrival::ComputeDeltas()函数，用以计算相邻数据包组的到达时间相对延迟，该部分对应文章[1]的3.1节内容。在计算到达时间相对延迟时，用到了RTP报文头部扩展abs-send-time。另外，实现细节上要注意数据包组的划分，以及对乱序和突发时间的处理。&lt;/p&gt;

&lt;p&gt;接下来算法调用OveruseEstimator::Update()函数，用以估计数据包的网络延迟，该部分对应文章[1]的3.2节内容。对网络延迟的估计用到了Kalman滤波，算法的具体细节请参考文章[2]。Kalman滤波的结果为网络延迟m(i)，作为下一阶段网络状态检测的输入参数。&lt;/p&gt;

&lt;p&gt;算法接着调用OveruseDetector::Detect()，用来检测当前网络的拥塞状况，该部分对应文章[1]的3.2节内容。网络状态检测用当前网络延迟m(i)和阈值gamma_1进行比较，判断出overuse，underuse和normal三种网络状态之一。在算法细节上，要注意overuse的判定相对复杂一些：当m(i) &amp;gt; gamma_1时，计算处于当前状态的持续时间t(ou)，如果t(ou) &amp;gt; gamma_2，并且m(i) &amp;gt; m(i-1)，则发出网络过载信号Overuse。如果m(i)小于m(i-1)，即使高于阀值gamma_1也不需要发出过载信号。在判定网络拥塞状态之后，还要调用UpdateThreshold()更新阈值gamma_1。&lt;/p&gt;

&lt;p&gt;算法接着调用AimdRateControl::Update()和UpdateBandwidthEstimate()函数，用以估计当前网络状态下的目标码率Ar，该部分对应文章[1]的3.3节。算法基于当前网络状态和码率变化趋势有限状态机，采用AIMD(Additive Increase Multiplicative Decrease)方法计算目标码率，具体计算公式请参考文章[1]。需要注意的是，当算法处于开始阶段时，会采用Multiplicative Increase方法快速增加码率，以加快码率估计速度。&lt;/p&gt;

&lt;p&gt;此时，我们已经拿到接收端估计的目标码率Ar。接下来以Ar为参数调用VieRemb对象的OnReceiveBitrateChange()函数，发送REMB报文到发送端。REMB报文会推送到RTCP模块，并设置REMB报文发送时间为立即发送。关于REMB报文接下来的发送和接收流程，和第1节描述的RTCP报文一般处理流程是一样的，即经过序列化发送到网络，然后发送端收到以后，反序列化出描述结构，最后通过回调函数到达发送端码率控制模块BitrateControllerImpl。&lt;/p&gt;

&lt;p&gt;至此，接收端基于延迟的码率估计过程描述完毕。&lt;/p&gt;

&lt;h3 id=&quot;4-发送端码率计算及生效&quot;&gt;4 发送端码率计算及生效&lt;/h3&gt;

&lt;p&gt;在发送端，目标码率计算和生效是异步进行的，即Worker线程从RTCP接收模块经回调函数拿到丢包率和REMB码率之后，计算得到目标码率A；然后ModuleProcess线程异步把目标码率A生效到目标模块如PacedSender和ViEEncoder等。下面分别描述码率计算和生效过程。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210105/16098247455890.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图5 发送端码率计算过程&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;码率计算过程如图5所示：Worker线程从RTCPReceiver模块经过回调函数拿到RTCP RR报文和REMB报文的数据，到达BitrateController模块。RR报文中的丢包率会进入Update()函数中计算码率，码率计算公式如文章[1]第2节所述。然后算法流程进入CapBitrateToThreshold()函数，和配置的最大最小码率和远端估计码率进行比较后，确定最终目标码率。而REMB报文的接收端估计码率Ar则直接进入CapBitrateToThreshold()函数参与目标码率的确定。目标码率由文章[1]的3.4节所示公式进行确定。需要注意的是，RR报文和REMB报文一般不在同一个RTCP报文里。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210105/16098247656332.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图6 发送端码率生效过程&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;发送端码率生效过程如图6所示：ModuleProcess线程调用拥塞控制总控对象CongestionController周期性从码率控制模块BitrateControllerImpl中获取当前最新目标码率A，然后判断目标码率是否有变化。若是，则把最新目标码率设置到相关模块中，主要包括PacedSender模块，RTPSender模块和ViEEncoder模块。&lt;/p&gt;

&lt;p&gt;对于PacedSender模块，设置码率主要是为了平滑RTP数据包的发送速率，尽量避免数据包Burst造成码率波动。对于RTPSender模块，设置码率是为了给NACK模块预留码率，如果预留码率过小，则在某些情况下对于NACK报文请求选择不响应。对于ViEEncoder模块，设置码率有两个用途：1)控制发送端丢帧策略，根据设定码率和漏桶算法决定是否丢弃当前帧。2)控制编码器内部码率控制，设定码率作为参数传输到编码器内部，参与内部码率控制过程。&lt;/p&gt;

&lt;p&gt;至此，发送端码率计算和生效过程分析完毕。&lt;/p&gt;

&lt;h3 id=&quot;5-总结&quot;&gt;5 总结&lt;/h3&gt;
&lt;p&gt;本文结合文章[1]，深入WebRTC代码内部，详细分析了WebRTC的GCC算法的实现细节。通过本文，对WebRTC的代码结构和拥塞控制实现细节有了更深层次的理解，为进一步学习WebRTC奠定良好基础。&lt;/p&gt;

&lt;p&gt;参考文献&lt;br /&gt;
[1] &lt;a href=&quot;https://byronjia.github.io/2021/01/WebRTC%E5%9F%BA%E4%BA%8EGCC%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/&quot;&gt;WebRTC基于GCC的拥塞控制(上) – 算法分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[2] &lt;a href=&quot;http://www.jianshu.com/p/bb34995c549a&quot;&gt;WebRTC视频接收缓冲区基于KalmanFilter的延迟模型.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[3] &lt;a href=&quot;http://www.jianshu.com/p/c84be6f3ddf3&quot;&gt;WebRTC中RTP/RTCP协议实现分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[4] &lt;a href=&quot;https://webrtc.org/experiments/rtp-hdrext/abs-send-time/&quot;&gt;abs-send-time.&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 06 Jan 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/01/WebRTC%E5%9F%BA%E4%BA%8EGCC%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/01/WebRTC%E5%9F%BA%E4%BA%8EGCC%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90/</guid>
        
        <category>webRTC</category>
        
        
      </item>
    
      <item>
        <title>WebRTC基于GCC的拥塞控制(上)-算法分析</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;实时流媒体应用的最大特点是实时性，而延迟是实时性的最大敌人。从媒体收发端来讲，媒体数据的处理速度是造成延迟的重要原因；而从传输角度来讲，网络拥塞则是造成延迟的最主要原因。网络拥塞可能造成数据包丢失，也可能造成数据传输时间变长，延迟增大。&lt;/p&gt;

&lt;p&gt;拥塞控制是实时流媒体应用质量保证(QoS)的重要手段之一，它在缓解网络拥堵、减小网络延迟、平滑数据传输等质量保证方面发挥重要作用。WebRTC通控制发送端数据发送码率来达到控制网络拥塞的目的，其采用谷歌提出的拥塞控制算法(Google Congestion Control，简称GCC[1])来控制发送端码率。&lt;/p&gt;

&lt;p&gt;本文是关于WebRTC拥塞控制算法GCC的上半部分，主要集中于对算法的理论分析，力图对WebRTC的QoS有一个全面直观的认识。在下半部分，将深入WebRTC源代码内部，仔细分析GCC的实现细节。&lt;/p&gt;

&lt;h3 id=&quot;1-gcc算法综述&quot;&gt;1 GCC算法综述&lt;/h3&gt;

&lt;p&gt;Google关于GCC的RFC文档在文献[1]，该RFC目前处于草案状态，还没有成为IETF的正式RFC。此外，Google陆续发布了一系列论文[2][3][4]来论述该算法的实现细节，以及其在Google Hangouts、WebRTC等产品中的应用。本文主要根据这些文档资料，从理论上学习GCC算法。&lt;/p&gt;

&lt;p&gt;GCC算法分两部分：发送端基于丢包率的码率控制和接收端基于延迟的码率控制。如图1所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099857784941.png&quot; alt=&quot;2844879-2664f62d1240ba6b&quot; /&gt;
                        &lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图1 GCC算法整体结构&lt;/font&gt;&lt;/center&gt;&lt;/p&gt;

&lt;p&gt;基于丢包率的码率控制运行在发送端，依靠RTCP RR报文进行工作。WebRTC在发送端收到来自接收端的RTCP RR报文，根据其Report Block中携带的丢包率信息，动态调整发送端码率As。基于延迟的码率控制运行在接收端，WebRTC根据数据包到达的时间延迟，通过到达时间滤波器，估算出网络延迟m(t)，然后经过过载检测器判断当前网络的拥塞状况，最后在码率控制器根据规则计算出远端估计最大码率Ar。得到Ar之后，通过RTCP REMB报文返回发送端。发送端综合As、Ar和预配置的上下限，计算出最终的目标码率A，该码率会作用到Encoder、RTP和PacedSender等模块，控制发送端的码率。&lt;/p&gt;

&lt;h3 id=&quot;2-发送端基于丢包率的码率控制&quot;&gt;2 发送端基于丢包率的码率控制&lt;/h3&gt;

&lt;p&gt;GCC算法在发送端基于丢包率控制发送码率，其基本思想是：丢包率反映网络拥塞状况。如果丢包率很小或者为0，说明网络状况良好，在不超过预设最大码率的情况下，可以增大发送端码率；反之如果丢包率变大，说明网络状况变差，此时应减少发送端码率。在其它情况下，发送端码率保持不变。&lt;/p&gt;

&lt;p&gt;GCC使用的丢包率根据接收端RTP接收统计信息计算得到，通过RTCP RR报文中返回给发送端。RTCP RR报文统计接收端RTP接收信息，如Packet Loss，Jitter，DLSR等等，如图2所示：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099858302432.png&quot; alt=&quot;2844879-82d8b6af7a89de7d&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图2 RTCP RR报文结构[5]&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;发送端收到RTCP RR报文并解析得到丢包率后，根据图3公式计算发送端码率：当丢包率大于0.1时，说明网络发生拥塞，此时降低发送端码率；当丢包率小于0.02时，说明网络状况良好，此时增大发送端码率；其他情况下，发送端码率保持不变。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099858556863.png&quot; alt=&quot;2844879-05bf5ae56c467e0c&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图3 GCC基于丢包率的码率计算公式[4]&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;最终码率会作用于Encoder、RTP和PacedSender模块，用以在编码器内部调整码率和平滑发送端发送速率。&lt;/p&gt;

&lt;h3 id=&quot;3-接收端基于延迟的码率控制&quot;&gt;3 接收端基于延迟的码率控制&lt;/h3&gt;

&lt;p&gt;GCC算法在接收端基于数据包到达延迟估计发送码率Ar，然后通过RTCP REMB报文反馈到发送端，发送端把Ar作为最终目标码率的上限值。其基本思想是： RTP数据包的到达时间延迟m(i)反映网络拥塞状况。当延迟很小时，说明网络拥塞不严重，可以适当增大目标码率；当延迟变大时，说明网络拥塞变严重，需要减小目标码率；当延迟维持在一个低水平时，目标码率维持不变。&lt;/p&gt;

&lt;p&gt;基于延时的拥塞控制由三个主要模块组成：到达时间滤波器，过载检查器和速率控制器；除此之外还有过载阈值自适应模块和REMB报文生成模块，如图1所示。下面分别论述其工作过程。&lt;/p&gt;

&lt;h4 id=&quot;31-到达时间滤波器arrival-time-filter&quot;&gt;3.1 到达时间滤波器(Arrival-time Filter)&lt;/h4&gt;

&lt;p&gt;该模块用以计算相邻相邻两个数据包组的网络排队延迟m(i)。数据包组定义为一段时间内连续发送的数据包的集合。一系列数据包短时间里连续发送，这段时间称为突发时间，建议突发时间为5ms。不建议在突发时间内的包间隔时间做度量，而是把它们做为一组来测量。通过相邻两个数据包组的发送时间和到达时间，计算得到组间延迟d (i)。组间延迟示意图及计算公式如图4所示：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099859105437.png&quot; alt=&quot;2844879-74f483fc3481fb95&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图4 组间延迟示意图&lt;/font&gt;&lt;/center&gt;
&lt;p&gt;T(i)是第i个数据包组中第一个数据包的发送时间，t(i)是第i个数据包组中最后一个数据包的到达时间。帧间延迟通过如下公式计算得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d(i) = t(i) – t(i-1) – (T(i) – T(i-1)) (3.1.1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;公式1.3.1是d(i)的观测方程。另一方面，d(i)也可由如下状态方程得到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d(i) = dL(i)/C(i) + w(i) (3.1.2)
d(i) = dL(i)/C(i) + m(i) + v(i) (3.1.3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中dL(i)表示相邻两帧的长度差，C(i)表示网络信道容量，m(i)表示网络排队延迟，v(i)表示零均值噪声。m(i)即是我们要求得的网络排队延迟。通过Kalman Filter可以求得该值。具体计算过程请参考文献[1][4][6]。&lt;/p&gt;

&lt;h4 id=&quot;32-过载检测器over-use-detector&quot;&gt;3.2 过载检测器(Over-use Detector)&lt;/h4&gt;

&lt;p&gt;该模块以到达时间滤波器计算得到的网络排队延迟m(i)为输入，结合当前阈值gamma_1，判断当前网络是否过载。判断算法如图5所示[2]。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099859853773.png&quot; alt=&quot;2844879-8d67071eec9fc027&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图5 过载检测器伪代码&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;算法基于当前网络排队延迟m(i)和当前阈值gamma_1判断当前网络拥塞状况[2]：当m(i) &amp;gt; gamma_1时，算法计算处于当前状态的持续时间t(ou) = t(ou) + delta(t)，如果t(ou)大于设定阈值gamma_2(实际计算中设置为10ms)，并且m(i) &amp;gt; m(i-1)，则发出网络过载信号Overuse，同时重置t(ou)。如果m(i)小于m(i-1)，即使高于阀值gamma_1也不需要发出过载信号。当m(i) &amp;lt; -gamma_1时，算法认为当前网络处于空闲状态，发出网络低载信号Underuse。当 – gamma_1 &amp;lt;= m(i) &amp;lt;= gamma_1是，算法认为当前网络使用率适中，发出保持信号Hold。算法随着时间轴的计算过程可从图6中看到。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099860161846.png&quot; alt=&quot;2844879-fde99d49aefe833a&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图6 时间轴上的过载检测过程&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;需要注意的是，阀值gamma_1对算法的影响很大，并且阈值gamma_1是自适应性的。如果其是静态值，会带来一系列问题，详见文献[4]。所以gamma_1需要动态调整来达到良好的表现。这就是图1中的Adaptive threshould模块。阈值gamma_1动态更新的公式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gamma_1(i) = gamma_1(i-1) + (t(i)-t(i-1)) * K(i) * (|m(i)|-gamma_1(i-1)) (3.2.4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当|m(i)|&amp;gt;gamma_1(i-1)时增加gamma_1(i)，反之减小gamma_1(i)，而当|m(i)|– gamma_1(i) &amp;gt;15，建议gamma_1(i)不更新。&lt;br /&gt;
K(i)为更新系数，当|m(i)|&amp;lt;gamma_1(i-1)时K(i) = K_d，否则K(i) = K_u。  &lt;br /&gt;
同时建议gamma_1(i)控制在[6,600]区间，太小的值会导致探测器过于敏感，建议增加系数要大于减少系数K_u &amp;gt; K_d。文献[1]给出的建议值如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gamma_1(0) = 12.5 ms
gamma_2 = 10 ms
K_u = 0.01
K_d = 0.00018
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;33-速率控制器remote-rate-controller&quot;&gt;3.3 速率控制器(Remote Rate Controller)&lt;/h4&gt;
&lt;p&gt;该模块以过载检测器给出的当前网络状态s为输入，首先根据图7所示的有限状态机判断当前码率的变化趋势，然后根据图8所示的公式计算目标码率Ar。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099860792729.png&quot; alt=&quot;2844879-889691f6c7d2a9c6&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图7 目标码率Ar变化趋势有限状态机&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;当前网络过载时，目标码率处于Decrease状态；当前网络低载时，目标码率处于Hold状态；当网络正常时，处于Decrease状态时迁移到Hold状态，处于Hold/Increase状态时都迁移到Increase状态。当判断出码率变化趋势后，根据图8所示公式进行计算目标码率。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099860940947.png&quot; alt=&quot;2844879-49211330b7637e93&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图8 目标码率Ar计算公式&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;当码率变化趋势为Increase时，当前码率为上次码率乘上系数1.05；当码率变化趋势为Decrease，当前码率为过去500ms内的最大接收码率乘上系数0.85。当码率变化趋势为Hold时，当前码率保持不变。目标码率Ar计算得到之后，下一步把Ar封装到REMB报文中发送回发送端。在REMB报文中，Ar被表示为Ar = M * 2^Exp，其中M封装在BR Mantissa域，占18位；Exp封装在BR Exp域，占6位。REMB报文是Payload为206的RTCP报文[7]，格式如图9所示。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20210107/16099861164188.png&quot; alt=&quot;2844879-1e9383db4f497809&quot; /&gt;&lt;/p&gt;
&lt;center&gt;&lt;font color=&quot;#808080&quot; size=&quot;2&quot;&gt;图9 REMB报文格式&lt;/font&gt;&lt;/center&gt;

&lt;p&gt;REMB报文每秒发送一次，当Ar(i) &amp;lt; 0.97 * Ar(i-1)时则立即发送。&lt;/p&gt;

&lt;h4 id=&quot;34-发送端目标码率的确定&quot;&gt;3.4 发送端目标码率的确定&lt;/h4&gt;

&lt;p&gt;发送端最终目标码率的确定结合了基于丢包率计算得到的码率As和基于延迟计算得到的码率Ar。此外，在实际实现中还会配置目标码率的上限值和下限值。综合以上因素，最终目标码率确定如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;target_bitrate = max( min( min(As, Ar), Amax), Amin) (3.4.1)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;目标码率确定之后，分别设置到Encoder模块和PacedSender模块。&lt;/p&gt;

&lt;h3 id=&quot;4-总结&quot;&gt;4 总结&lt;/h3&gt;

&lt;p&gt;本文在广泛调研WebRTC GCC算法的相关RFC和论文的基础上，全面深入学习GCC算法的理论分析，以此为契机力图对WebRTC的QoS有一个全面直观的认识。为将来深入WebRTC源代码内部分析GCC的实现细节奠定基础。&lt;/p&gt;

&lt;p&gt;参考文献&lt;/p&gt;

&lt;p&gt;[1] A Google Congestion Control Algorithm for Real-Time Communication.&lt;/p&gt;

&lt;p&gt;draft-alvestrand-rmcat-congestion-03&lt;/p&gt;

&lt;p&gt;[2] Understanding the Dynamic Behaviour of the Google Congestion Control for RTCWeb.&lt;/p&gt;

&lt;p&gt;[3] Experimental Investigation of the Google Congestion Control for Real-Time Flows.&lt;/p&gt;

&lt;p&gt;[4] Analysis and Design of the Google Congestion Control for Web Real-time Communication (WebRTC). MMSys’16, May 10-13, 2016, Klagenfurt, Austria&lt;/p&gt;

&lt;p&gt;[5] RFC3550: RTP - A Transport Protocol for Real-Time Applications&lt;/p&gt;

&lt;p&gt;[6] &lt;a href=&quot;http://www.jianshu.com/p/bb34995c549a&quot;&gt;WebRTC视频接收缓冲区基于KalmanFilter的延迟模型.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[7] RTCP message for Receiver Estimated Maximum Bitrate. draft-alvestrand-rmcat-remb-03&lt;/p&gt;
</description>
        <pubDate>Tue, 05 Jan 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/01/WebRTC%E5%9F%BA%E4%BA%8EGCC%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/01/WebRTC%E5%9F%BA%E4%BA%8EGCC%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</guid>
        
        <category>webRTC</category>
        
        
      </item>
    
      <item>
        <title>NSNotification详解</title>
        <description>&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;参考GNUStep源码，了解其中实现原理，对于&lt;code class=&quot;highlighter-rouge&quot;&gt;addObserver:selector:name:object:&lt;/code&gt;会创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Observation&lt;/code&gt;对象，是搜索和执行响应的核心对象， 包含observer和sel，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef	struct	Obs {
  id		observer;	/* Object to receive message.	*/
  SEL		selector;	/* Method selector.		*/
  struct Obs	*next;		/* Next item in linked list.	*/
  int		retained;	/* Retain count for structure.	*/
  struct NCTbl	*link;		/* Pointer back to chunk table	*/
} Observation;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotification&lt;/code&gt;维护了一个MapTable表，用于分类存储&lt;code class=&quot;highlighter-rouge&quot;&gt;Observation&lt;/code&gt;，分为&lt;code class=&quot;highlighter-rouge&quot;&gt;nameless&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;named&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，代表无post名的通知，有名的通知，和快速缓存。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define	CHUNKSIZE	128
#define	CACHESIZE	16
typedef struct NCTbl {
  Observation		*wildcard;	/* Get ALL messages.		*/
  GSIMapTable		nameless;	/* Get messages for any name.	*/
  GSIMapTable		named;		/* Getting named messages only.	*/
  unsigned		lockCount;	/* Count recursive operations.	*/
  NSRecursiveLock	*_lock;		/* Lock out other threads.	*/
  Observation		*freeList;
  Observation		**chunks;
  unsigned		numChunks;
  GSIMapTable		cache[CACHESIZE];
  unsigned short	chunkIndex;
  unsigned short	cacheIndex;
} NCTable;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但是&lt;code class=&quot;highlighter-rouge&quot;&gt;nameless&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;named&lt;/code&gt;都是MapTable,但是存储的结构不同，即若有名字，则存储的是同名的table,其中分为不同的object对于不同的observation。若没有名字，则用object来区分不同的observation。
所以我们知道，即使不传name,传入指定的obj,也可以实现通知的功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在nameless表中：
GSIMapTable的结构如下
object : Observation
object : Observation
object : Observation

----------------------------
在named表中：
GSIMapTable结构如下:
name : maptable
name : maptable
name : maptable

maptable的结构如下
object : Observation
object : Observation
object : Observation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;addObserver的逻辑如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;根据传入的selector和observer创建Observation，并存入maptable中，如果已存在，则是从cache中取。&lt;/li&gt;
  &lt;li&gt;如果name存在，object存在，则向named的maptable表中插入元素，key为name,value为GSIMapTable，GSIMapTable中存key为object,value为Observation。&lt;/li&gt;
  &lt;li&gt;如果name不存在，object存在，则向nameless的maptable表中插入元素，key为object,value为Observation。&lt;/li&gt;
  &lt;li&gt;如果name和object都为空，则Observation-&amp;gt;next=wildcard，将老的wildcard赋值为next指针,然后Observation对象置为wildcard，wildcard = Observation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;postNotification的机制如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;查找所有wildcard的Observation,加入数组&lt;/li&gt;
  &lt;li&gt;查找相同object和空name的Observation,加入数组&lt;/li&gt;
  &lt;li&gt;查找相同name和相同object的Observation,加入数组&lt;/li&gt;
  &lt;li&gt;查找相同name,非空object时,所有nil object的Observation加入数组&lt;/li&gt;
  &lt;li&gt;遍历数组,执行performSelector,情况数组&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;通知是同步or异步&quot;&gt;通知是同步or异步&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;postNotificationName&lt;/code&gt;底层实现是&lt;code class=&quot;highlighter-rouge&quot;&gt;performSeletor&lt;/code&gt; 方法，所以一定是按顺序执行，是同步的。&lt;/p&gt;

&lt;h3 id=&quot;如何修改发送时机&quot;&gt;如何修改发送时机&lt;/h3&gt;
&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotificationQueue&lt;/code&gt;, 顾名思义可以将NSNotification放入queue中，在适当时机再执行发送，虽然都是在主线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSUInteger, NSPostingStyle) {
    NSPostWhenIdle = 1,      // 当runloop处于空闲状态时post
    NSPostASAP = 2,    // 当当前runloop完成之后立即post
    NSPostNow = 3    // 立即post
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSNotification *noti = [NSNotification notificationWithName:@&quot;111&quot; object:nil];
[[NSNotificationQueue defaultQueue] enqueueNotification:noti postingStyle:NSPostASAP];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;和runloop的关系&quot;&gt;和runloop的关系&lt;/h3&gt;
&lt;p&gt;与runloop的关系仅限当postingStyle不是&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPostNow&lt;/code&gt;，即需要在runloop一定的状态下再去发送，默认子线程是不启动runloop的，所以如果要在子线程使用&lt;code class=&quot;highlighter-rouge&quot;&gt;NSPostNow&lt;/code&gt;以外的类型发送通知，需要启动runloop。&lt;/p&gt;

&lt;h3 id=&quot;通知的线程切换&quot;&gt;通知的线程切换&lt;/h3&gt;
&lt;p&gt;在上面也已经聊过，&lt;code class=&quot;highlighter-rouge&quot;&gt;NSNotification&lt;/code&gt;执行是通过performSeletor方法，所以默认就是在当前线程，但是实际上我们会一个需求，在子线程发送通知，在主线程接收到通知并执行，虽然我们可以子线程接收通知后，切换到主线程执行相应的UI操作，但是如果多个接收者，都需要这种操作，就很不友好。下面来看一下，苹果官方给出的解决方案。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@interface NotificationVC ()&amp;lt;NSMachPortDelegate&amp;gt;

@property (nonatomic, strong)NSLock *notiLock;
@property (nonatomic, strong)NSThread *notiThead; // 期望线程
@property (nonatomic, strong)NSMutableArray *notiQueue;
@property (nonatomic, strong)NSMachPort *notiMach;

@end

@implementation NotificationVC
- (void)viewDidLoad {
    [super viewDidLoad];
    self.view.backgroundColor = [UIColor systemBackgroundColor];
    
    self.notiLock = [[NSLock alloc]init];
    self.notiQueue = [NSMutableArray array];
    self.notiMach = [[NSMachPort alloc] init];
    self.notiMach.delegate = self;
    self.notiThead = [NSThread currentThread];
    [[NSRunLoop currentRunLoop] addPort:self.notiMach forMode:NSRunLoopCommonModes];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(processNotification:) name:@&quot;post&quot; object:nil];

    dispatch_async(dispatch_get_global_queue(0, 0), ^{
        NSLog(@&quot;%@&quot;, [NSThread currentThread]);
        [[NSNotificationCenter defaultCenter] postNotificationName:@&quot;post&quot; object:nil];
    });
}


- (void)processNotification:(NSNotification *)noti
{
    if ([NSThread currentThread] != self.notiThead) {
        NSLog(@&quot;不在主线程  %@&quot;,[NSThread currentThread]);
        [self.notiLock lock];
        [self.notiQueue addObject:noti];
        [self.notiLock unlock];
        [self.notiMach sendBeforeDate:[NSDate date] components:nil from:nil reserved:0];
    }else{
        NSLog(@&quot;已经在主线程 %@&quot;,[NSThread currentThread]);
    }
}


#pragma mark - NSMachPortDelegate
- (void)handleMachMessage:(void *)msg
{
    NSLog(@&quot;%s   %@&quot;,__func__,[NSThread currentThread]);
    
    [self.notiLock lock];
    while ([self.notiQueue count]) {
        NSNotification *noti = self.notiQueue[0];
        [self.notiQueue removeObjectAtIndex:0];
        [self.notiLock unlock];
        [self processNotification:noti];
        [self.notiLock lock];
    }
    
    [self.notiLock unlock];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以上方案有很大局限性，每个observer都要讲方法设为processNotification：，而且每个观察者都要实现这套逻辑。完美方案是实现NSNotificationCenter子类或者写单独的队列类来管理。&lt;/p&gt;

&lt;p&gt;简单方案如下，在需要切换到主线程的观察者地方，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;addObserverForName:object:queue:usingBlock:&lt;/code&gt;方式，将响应的回调拉回到主线程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSNotificationCenter defaultCenter] addObserverForName:@&quot;post&quot; object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) {
    NSLog(@&quot;%@&quot;, [NSThread currentThread]);
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 29 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/NSNotification%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/NSNotification%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS KVO详解</title>
        <description>&lt;h3 id=&quot;提出疑问&quot;&gt;提出疑问&lt;/h3&gt;
&lt;p&gt;首先抛出问题，KVO的原理有很多文章写过，大致原理是一个Test类，添加了观察者后，会动态生成NSKVONotifying_Test类，重写了set方法。但为什么当我们对这个对象调用class方法的时候依然返回的是Test类，为什么不是NSKVONotifying_Test？ 我们能理解设计者是故意屏蔽内部实现，但是究竟是怎么做到的呢？&lt;/p&gt;

&lt;p&gt;同样问题，superclass方法，获取的应该是Test和NSObject，为什么是2个都是NSObject？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Test *t = [Test new];
NSLog(@&quot;before  class=%@,  object_getClass=%@,  super class=%@&quot;,t.class,object_getClass(t),t.superclass);
[t addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];    
NSLog(@&quot;after  class=%@,  object_getClass=%@,  super class=%@&quot;,t.class,object_getClass(t),t.superclass);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;before  class=Test,  object_getClass=Test,  super class=NSObject
after  class=Test,  object_getClass=NSKVONotifying_Test,  super class=NSObject
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如上这样生成一个类，打印添加观察者前后调用class得到的结果，发现没变，可是控制台中或者理论上这个对象指向的都应该是NSKVONotifying_Test，但是object_getClass拿到的却是我们想要的，下面从class和object_getClass方法说起。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201228/16091487018484.png&quot; alt=&quot;截屏2020-12-28 下午5.42.01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;class方法和object_getclass方法&quot;&gt;class方法和object_getClass方法&lt;/h3&gt;
&lt;p&gt;class和superclass方法的实现如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}

- (Class)superclass {
    return [self class]-&amp;gt;superclass;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;object_getClass方法实现如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Class object_getClass(id obj)
{
    if (obj) return obj-&amp;gt;getIsa();
    else return Nil;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;正常情况下，一个实例对象调用class方法和调用object_getClass的结果肯定一致，因为class的实现就是通过object_getClass。
所以这里NSKVONotifying_Test这个类肯定也重写了class方法，那么如何去证明呢？&lt;/p&gt;

&lt;h3 id=&quot;证明&quot;&gt;证明&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Test *t = [Test new];

IMP p1 = class_getMethodImplementation(t.class, @selector(class));
IMP p3 = class_getMethodImplementation(t.class, @selector(name));
IMP p5 = class_getMethodImplementation(t.class, @selector(setName:));
IMP p7 = class_getMethodImplementation(t.class, @selector(superclass));
NSLog(@&quot;befor class=%p,   getName=%p,   setName=%p,   superclass=%p&quot;, p1,p3, p5,p7);

[t addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];
        
IMP p2 = class_getMethodImplementation(object_getClass(t), @selector(class));
IMP p4 = class_getMethodImplementation(object_getClass(t), @selector(name));
IMP p6 = class_getMethodImplementation(object_getClass(t), @selector(setName:));
IMP p8 = class_getMethodImplementation(object_getClass(t), @selector(superclass));
NSLog(@&quot;after class=%p,   getName=%p,   setName=%p,  superclass=%p&quot;, p2,p4, p6, p8);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里证明思路是，如果NSKVONotifying_Test重写了class方法，那么IMP指针指向的实现地址肯定会改变，如果添加观察者前后地址改变了，则证明重写了该方法。&lt;/p&gt;

&lt;p&gt;结果如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;befor class=0x7fff2018ec9b,   getName=0x10a970910,   setName=0x10a970940,   superclass=0x7fff2018ecde
after class=0x7fff207b4662,   getName=0x10a970910,   setName=0x7fff207b5b57,  superclass=0x7fff2018ecde
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这能证明，class和setName方法被重写，get方法和superclass方法没重写。class的实现可能如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (Class)class {
    return objc_getClass(&quot;Test&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就能解释为什么添加观察者之后的对象调用class拿到的依然是Test类，系统为了屏蔽内部实现，故重写了OC层面的class方法，但是依然给了我们一个runtime层面object_getClass的入口。&lt;/p&gt;

&lt;p&gt;并且因为superclass的实现是调用[self class]方法，调用的是重写后的，拿到的class是Test,所以可以理解了superclass也就不需要重写了。&lt;/p&gt;

</description>
        <pubDate>Mon, 28 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS-KVO%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS-KVO%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Linux文件权限详解</title>
        <description>&lt;h3 id=&quot;查看文件权限&quot;&gt;查看文件权限：&lt;/h3&gt;
&lt;p&gt;ls -l  在目录下列出文件列表和权限信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--   1 byron  staff    89  8 11 10:47 OWNERS
-rwxr-xr-x   1 byron  staff  4034  8 11 10:47 ensure_gn_version.py
drwxr-xr-x   3 byron  staff    96  8 11 10:47 linux64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;权限信息通用格式：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rwxr-xr-x　number　user　group　filesize　updatetime　filename
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通用格式分为7个部分，分别是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;文件属性，共10个字符,第1个表示类型，&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;表示文件， &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt;表示文件夹。后9个字符分3组，分别表示对于当前用户，当前用户所在组，其他用户的 读/写/执行权限。 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt;可读， &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;可写， &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;可执行 ，&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;无权限&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;表示文件的数量&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;表示当前用户名&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;group&lt;/code&gt;表示当前用户所在组的名字&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filesize&lt;/code&gt;表示该文件大小，单位byte&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;updatetime&lt;/code&gt;表示文件最后修改时间&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filename&lt;/code&gt; 文件名&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面例子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;-rw-r--r--&lt;/code&gt; 表示OWNERS是一个文件，对当前用户有读写权限，没有执行权限， 当前用户所在组其他用户只有读权限，没有写和执行权限。
&lt;code class=&quot;highlighter-rouge&quot;&gt;drwxr-xr-x&lt;/code&gt;表示linux64是一个文件夹，对当前用户有读写执行权限，用户组和其他用户有读和执行权限，没有写权限，且文件夹中有3个文件。&lt;/p&gt;

&lt;h3 id=&quot;修改文件权限&quot;&gt;修改文件权限&lt;/h3&gt;
&lt;p&gt;修改权限的命令格式：
&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod &amp;lt;权限范围&amp;gt;&amp;lt;权限操作&amp;gt;&amp;lt;具体权限&amp;gt; &amp;lt;文件或目录&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;权限范围&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;u ： user,当前用户&lt;/li&gt;
  &lt;li&gt;g ：Group,当前用户所在组&lt;/li&gt;
  &lt;li&gt;o ：Other,其他用户&lt;/li&gt;
  &lt;li&gt;a ：All,全部用户&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;权限操作&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; ：增加权限,
&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; ：取消权限,
&lt;code class=&quot;highlighter-rouge&quot;&gt;=&lt;/code&gt; ：设置拥有权限,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;具体权限&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;r ：可读&lt;/li&gt;
  &lt;li&gt;w ：可写&lt;/li&gt;
  &lt;li&gt;x ：可执行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--  1 byron  staff  0 12 27 12:04 text.txt  // 文件原始权限
chmod u+x text.txt      // 执行修改权限
-rwxr--r--  1 byron  staff  0 12 27 12:04 text.txt  // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--  1 byron  staff  0 12 27 12:04 text.txt // 文件原始权限
chmod a=rwx text.txt    // 执行修改权限
-rwxrwxrwx  1 byron  staff  0 12 27 12:04 text.txt // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-rw-rw-  1 byron  staff  0 12 27 12:04 text.txt // 文件原始权限
chmod u+x-w text.txt    // 执行修改权限
-r-xrw-rw-  1 byron  staff  0 12 27 12:04 text.txt // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;还有一种修改权限的命令格式：
&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod &amp;lt;数字&amp;gt; &amp;lt;文件名&amp;gt;&lt;/code&gt;
3位数字分别表示user, group,other的权限&lt;/p&gt;

&lt;p&gt;r = 4, w = 2, x = 1&lt;/p&gt;

&lt;p&gt;则 rwx为 4+2+1=7, rw-为 4+2=6, r-x为4+1=5,-wx为2+1=3等等&lt;/p&gt;

&lt;p&gt;所以我们常见的755代表&lt;code class=&quot;highlighter-rouge&quot;&gt;rwxr-xr-x&lt;/code&gt;,777代表&lt;code class=&quot;highlighter-rouge&quot;&gt;rwxrwxrwx&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所以前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod a=rwx filename&lt;/code&gt; 可以简化为&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod 777 filename&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-rw-r--r--  1 byron  staff  0 12 27 12:04 text.txt // 文件原始权限
chmod 777 text.txt    // 执行修改权限
-rwxrwxrwx  1 byron  staff  0 12 27 12:04 text.txt // 修改后的权限
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 24 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/Linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E8%AF%A6%E8%A7%A3/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS App签名原理</title>
        <description>&lt;p&gt;iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。&lt;/p&gt;

&lt;h3 id=&quot;app签名10&quot;&gt;App签名1.0&lt;/h3&gt;
&lt;p&gt;要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079168080845.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。
但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;开发 App 时可以直接把开发中的应用安装进手机进行调试。&lt;/li&gt;
  &lt;li&gt;In-House 企业内部分发，可以直接安装企业证书签名后的 APP。&lt;/li&gt;
  &lt;li&gt;AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。
苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app签名20&quot;&gt;App签名2.0&lt;/h3&gt;
&lt;p&gt;我们先来看第一个，开发时安装APP，它有两个个需求：
安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。
苹果必须对这里的安装有控制权，包括
a. 经过苹果允许才可以这样安装。
b. 不能被滥用导致非开发app也能被安装。
为了实现这些需求，iOS 签名的复杂度也就开始增加了。
苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079168652311.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在你的 Mac 开发机器生成一对公私钥，这里称为&lt;code class=&quot;highlighter-rouge&quot;&gt;公钥L&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;私钥L&lt;/code&gt;。L:Local&lt;/li&gt;
  &lt;li&gt;苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为&lt;code class=&quot;highlighter-rouge&quot;&gt;公钥A&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;私钥A&lt;/code&gt;。A:Apple&lt;/li&gt;
  &lt;li&gt;把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。&lt;/li&gt;
  &lt;li&gt;在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。&lt;/li&gt;
  &lt;li&gt;在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。&lt;/li&gt;
  &lt;li&gt;验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app签名30&quot;&gt;App签名3.0&lt;/h3&gt;
&lt;p&gt;上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。
怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079169420158.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。&lt;/p&gt;

&lt;h3 id=&quot;app签名终版&quot;&gt;App签名终版&lt;/h3&gt;
&lt;p&gt;这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。
实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。
所以整个流程稍微变一下，就变成这样了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201214/16079170366343.png&quot; style=&quot;zoom:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local&lt;/li&gt;
  &lt;li&gt;苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple&lt;/li&gt;
  &lt;li&gt;把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。&lt;/li&gt;
  &lt;li&gt;在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。&lt;/li&gt;
  &lt;li&gt;在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。&lt;/li&gt;
  &lt;li&gt;在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。&lt;/li&gt;
  &lt;li&gt;确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。&lt;/li&gt;
  &lt;li&gt;开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;实际操作&quot;&gt;实际操作&lt;/h3&gt;
&lt;p&gt;上面的步骤对应到我们平常具体的操作和概念是这样的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一对公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。&lt;/li&gt;
  &lt;li&gt;第 2 步苹果处理，不用管。&lt;/li&gt;
  &lt;li&gt;第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。&lt;/li&gt;
  &lt;li&gt;第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。&lt;/li&gt;
  &lt;li&gt;第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。&lt;/li&gt;
  &lt;li&gt;第 6 – 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里再总结一下这些概念：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;证书&lt;/code&gt;：内容是公钥或私钥，由其他机构对其签名组成的数据包。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Entitlements&lt;/code&gt;：包含了 App 权限开关列表。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CertificateSigningRequest&lt;/code&gt;：本地公钥。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p12&lt;/code&gt;：本地私钥，可以导入到其他电脑。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Provisioning Profile&lt;/code&gt;：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。&lt;/p&gt;

</description>
        <pubDate>Mon, 14 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS-App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS-App%E7%AD%BE%E5%90%8D%E5%8E%9F%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>音视频基础知识</title>
        <description>&lt;h3 id=&quot;码率&quot;&gt;码率：&lt;/h3&gt;
&lt;p&gt;也叫比特率， Bits per second 每秒传输的数据量。 可以理解成吞吐量或带宽。 目的是用最低的比特率达到最少的失真&lt;/p&gt;

&lt;p&gt;###帧率：
Frames per second 每秒显示帧数。&lt;/p&gt;

&lt;h3 id=&quot;常见编码标准&quot;&gt;常见编码标准:&lt;/h3&gt;
&lt;p&gt;MPEG-4， 其中第10部分提出新的视频编码方案，即与另一个组织共同开发的H.264。第三部分提出AAC音频编码方案，旨在替代MP3。  第14部分提出MP4封装格式包括音频编码方案和视频编码方案。&lt;/p&gt;

&lt;h3 id=&quot;h264&quot;&gt;H.264:&lt;/h3&gt;
&lt;p&gt;定义了三种帧，I帧 P帧 B帧
1）I 帧：I帧即帧内编码帧、关键帧，可以理解为一帧画面的完整保留，解码时只需要本帧数据就可以完成，不需要参考其他画面，数据量比较大；
2）P 帧：P帧即前向预测编码帧，记录当前帧跟上一关键帧（或P帧）的差别，解码时依赖之前缓存的画面，叠加上本帧定义的差别，才能生成最终画面，数据量较 I 帧小很多；
3）B 帧：B帧即双向预测编码帧，记录当前帧跟前后帧的差别，解码时依赖前面的I帧（或P帧）和后面的P帧，数据量比I帧和P帧小很多。
直播场景中一般不适用B帧，因为受到一个B帧后还要等待之后的P帧才能解码，会有滞后性。&lt;/p&gt;

&lt;p&gt;编码计算复杂度是H.263的3倍， 解码复杂度是H.263的2倍。但是相同视频 质量，可以比H.263节省50%码率&lt;/p&gt;

&lt;h3 id=&quot;h265&quot;&gt;H.265:&lt;/h3&gt;
&lt;p&gt;High Efficiency Video Coding 简称HEVC。  与H.264类似，包含帧内预测，帧间预测，转化，量化，滤波，熵编码等。
在H.264基础上使用先进技术用以改善码流，编码质量，延时和算法复杂度之间的关系。
在码率减少51-74%情况下，265的视频质量与264近似甚至更好。
iOS11开始原生支持HEVC   H.265&lt;/p&gt;

&lt;h3 id=&quot;gop&quot;&gt;GOP:&lt;/h3&gt;
&lt;p&gt;Group of Pictures 一组连续的画面，由一张I帧和多张B/P帧组成，是视频编解码存取的基本单位。GOP组的长度格式也决定了码流的大小,形容一个I帧到下一个I帧之间间隔多少帧，增大GOP能有效减少编码后视频体积，但也会降低视频质量。&lt;/p&gt;

&lt;h3 id=&quot;idr帧&quot;&gt;IDR帧：&lt;/h3&gt;
&lt;p&gt;一个序列的首个I帧叫做IDR帧，IDR帧都是I帧.
引入目的是为了解码的重同步,如果前序列出现重大错误，这里可以获得重新同步机会。
当解码到IDR帧时，会立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始新序列。&lt;/p&gt;

&lt;h3 id=&quot;nal&quot;&gt;NAL:&lt;/h3&gt;
&lt;p&gt;Network abstract layer 网络抽象层&lt;/p&gt;

&lt;h3 id=&quot;sps&quot;&gt;SPS:&lt;/h3&gt;
&lt;p&gt;Sequence Parameter Set ，序列参数集，保存了一组编码视频序列的全局参数，一般SPS 和PPS在整个码流的起始位置，特殊情况下也可能在中间出现，例如中间需要重新解码，或者参数信息发生编发例如屏幕宽高比变化。&lt;/p&gt;

&lt;h3 id=&quot;pps&quot;&gt;PPS:&lt;/h3&gt;
&lt;p&gt;Picture Parameter Set  图形参数集，类似于SPS， 在马六周年单独保存在一个NAL Unit中，保存在视频文件的文件头中。&lt;/p&gt;

&lt;h3 id=&quot;dts&quot;&gt;DTS&lt;/h3&gt;
&lt;p&gt;Decoding Time Stamp 解码时间戳，表示送入解码器的顺序&lt;/p&gt;

&lt;h3 id=&quot;pts&quot;&gt;PTS&lt;/h3&gt;
&lt;p&gt;Presentation Time Stamp 显示时间戳，表示解码后的帧显示时间
在没有B帧情况下，DTS和PTS输出顺序一致。 因为B帧需要依赖后续的帧，所以B帧解码要在后续P帧之后，但是显示又在后续P帧之前&lt;/p&gt;

&lt;h3 id=&quot;音视频同步&quot;&gt;音视频同步：&lt;/h3&gt;
&lt;p&gt;音频没有类似视频中的B帧，所以音频帧的DTS 和PTS顺序是一致的。
通常需要选择一个参考时钟，参考时间的时间是线性递增的，编码音视频流时一句参考时钟上的时间给每个数据打上时间戳，播放时读取数据帧上的时间戳，同时参考PTS安排播放。&lt;/p&gt;

&lt;h3 id=&quot;视频传输协议优化&quot;&gt;视频传输协议优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;服务端节点之间尽量使用RTMP，降低整体传输延迟&lt;/li&gt;
  &lt;li&gt;如果终端使用RTMP播放，应该在尽量靠近收流节点进行转码，这样传输的视频流从一开始就是最优大小&lt;/li&gt;
  &lt;li&gt;如有必要，使用定制的UDP协议替换TCP协议，省去弱网环境下的丢包重传。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;视频传输网络优化&quot;&gt;视频传输网络优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在服务端节点中缓存GOP，配合播放器端的首开优化&lt;/li&gt;
  &lt;li&gt;服务端实时记录每个视频流在每个环节的帧率和码率，检测波动&lt;/li&gt;
  &lt;li&gt;客户端通过查询服务端准实时获取当前最优节点(5秒一次)， 准实时下线当前故障节点和线路&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;推流播放优化&quot;&gt;推流、播放优化：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;考察发送端系统的网络buffer大小&lt;/li&gt;
  &lt;li&gt;播放端的缓存对首开延迟也有较大影响，甚至可以在0缓存的情况下，将第一帧数据直接解码显示。但是如果弱网状态下，需要考虑网络波动造成的卡顿，还是需要增加一定的缓存。&lt;/li&gt;
  &lt;li&gt;可以使用动态缓存策略，参考第一帧的下载耗时决定后续播放过程中的缓存大小。&lt;/li&gt;
  &lt;li&gt;动态码率，在增加缓存依然无法满足当前码率的情况下，采用动态码率，减少延迟，当网络有所改善后，再动态增加码率。&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS Crash 分析</title>
        <description>&lt;h3 id=&quot;关于crash&quot;&gt;关于Crash&lt;/h3&gt;
&lt;p&gt;当app发生crash时，系统会生成crash report 存储在设备上，其中会描述app在何种情况下被系统终止，一般会包括完整的线程调用堆栈。包括以下2种report:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Crash report:包含堆栈信息，被符号化之前是运行内容中的实际函数地址，需要将report与 .dSYM或 .app共同分析出内存中的实际地址映射的函数方法，从而便于定位问题。&lt;/li&gt;
  &lt;li&gt;Low Memory report:没有堆栈信息，由于低内存引发crash，下面会详细介绍&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;符号化&quot;&gt;符号化&lt;/h3&gt;
&lt;p&gt;crash符号化常用的3个文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;symbolicatecrash：是系统提供的符号化执行程序，依赖于.dSYM、.crash 和.app  3个文件&lt;/li&gt;
  &lt;li&gt;.dSYM : 编译器在把你的源代码转换成机器码的同时，也会生成一份对应的Debug符号表,保存十六进制函数地址映射信息，通过他能得知log中的堆栈地址与具体方法的地址的映射关系&lt;/li&gt;
  &lt;li&gt;.crash : 是系统保存的崩溃日志文件，包括所有线程状态，和方法调用堆栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也可使用atos命令符号化， 只需要.crash和 .dSYM和app其中一个即可。
以下是符号化之前和符号化之后的堆栈信息，第3行符号化之后即可看到自己实现的函数名
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201211/16076544840576.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201211/16076544907887.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为什么系统函数的堆栈能打印出来？
因为系统函数的符号表在xcode中已经内置，且不同系统版本不一样，所以每次我们在升级xcode后，就会包含xcode支持的最新iOS系统的符号表。&lt;/p&gt;

&lt;h3 id=&quot;异常信息&quot;&gt;异常信息&lt;/h3&gt;
&lt;p&gt;carsh report 中的字段能提供异常信息，便于从宏观角度分析crash的原因。&lt;/p&gt;

&lt;p&gt;下面是由于&lt;code class=&quot;highlighter-rouge&quot;&gt;uncaught Objective-C exception&lt;/code&gt;而导致的进程被停止的crash report的摘录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception Type: EXC_CRASH (SIGABRT)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Exception Note: EXC_CORPSE_NOTIFY
Triggered by Thread: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是由于反向引用了一个NULL指针而造成进程被终止的crash report的摘录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception Type: EXC_BAD_ACCESS (SIGSEGV)
Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000000
Termination Signal: Segmentation fault: 11
Termination Reason: Namespace SIGNAL, Code 0xb
Terminating Process: exc handler [0]
Triggered by Thread: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中
&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Type&lt;/code&gt;: 异常类型，下面会详细定义不同类型的含义。
&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Codes&lt;/code&gt; ：和异常是有关的处理器指定信息，这些信息会被编码成一个或者多个64位二进制数字。一般来说，这个字段不应该存在，因为crash report生成时会把exception code转化成可读的信息并在其它字段进行体现。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Subtype&lt;/code&gt;：可读的exception code的名称。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Message&lt;/code&gt;：从exception code中解析出来的附加的可读信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Note&lt;/code&gt;：不特指某一种异常的额外信息。如果这个字段包含”SIMULATED”(不是Crash)，则进程并没有发生crash，而是在系统层面被kill掉了，比如看门狗机制。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Termination Reason&lt;/code&gt;：当进程被终止时的原因及信息。关键的信息模块，不论是进程内还是进程外，当遇到一个致命错误（fatal error，例如bad code signature，缺失依赖库，不恰当的访问私有敏感信息等）。MacOS Sierra,iOS 10, watch OS3和tvOS 10 已经采用新的架构去记录这些错误信息，所以这些系统之下的crash report会在Termination Reason这个字段里描述error message信息。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Triggered by Thread&lt;/code&gt;：指出异常是在哪个线程发生的&lt;/p&gt;

&lt;h3 id=&quot;看门狗&quot;&gt;看门狗&lt;/h3&gt;
&lt;p&gt;为了防止应用占用过多系统资源，看门狗机制能检测应用性能，若超出阈值，看门狗会强制终结这个应用的进程。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;触发时机&lt;/th&gt;
      &lt;th&gt;看门狗出动的时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;启动&lt;/td&gt;
      &lt;td&gt;20秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;恢复运行&lt;/td&gt;
      &lt;td&gt;10秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;挂起进程&lt;/td&gt;
      &lt;td&gt;10秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;退出应用&lt;/td&gt;
      &lt;td&gt;6秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;后台运行&lt;/td&gt;
      &lt;td&gt;10分钟&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;常见异常类型&quot;&gt;常见异常类型&lt;/h3&gt;
&lt;h4 id=&quot;bad-memory-access-exc_bad_access--sigsegv--sigbus&quot;&gt;Bad Memory Access [EXC_BAD_ACCESS // SIGSEGV // SIGBUS]&lt;/h4&gt;
&lt;p&gt;进程试图访问无效的内存空间，或尝试访问的方法不允许(例如去写只读的内存空间)&lt;/p&gt;

&lt;h4 id=&quot;abnormal-exit-exc_crash--sigabrt&quot;&gt;Abnormal Exit [EXC_CRASH // SIGABRT]&lt;/h4&gt;
&lt;p&gt;进程异常退出，常见原因是&lt;code class=&quot;highlighter-rouge&quot;&gt;uncaught Objective-C/C++ exception&lt;/code&gt; 并且调用了abort()。&lt;/p&gt;

&lt;h4 id=&quot;trace-trap-exc_breakpoint--sigtrap&quot;&gt;Trace Trap [EXC_BREAKPOINT // SIGTRAP]&lt;/h4&gt;
&lt;p&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Abnormal Exit&lt;/code&gt;类似，这种异常是由于在特殊的节点加入debugger调试节点的原因。&lt;/p&gt;

&lt;h4 id=&quot;illegal-instruction-exc_bad_instruction--sigill&quot;&gt;Illegal Instruction [EXC_BAD_INSTRUCTION // SIGILL]&lt;/h4&gt;
&lt;p&gt;尝试执行一个非法或者未定义的指令时会触发该异常。&lt;/p&gt;

&lt;h4 id=&quot;quit-sigquit&quot;&gt;Quit [SIGQUIT]&lt;/h4&gt;
&lt;p&gt;这个异常是由于其他进程拥有高优先级且可以管理本进程所导致（被高优先级进程kill掉）。&lt;/p&gt;

&lt;h4 id=&quot;killedsigkill&quot;&gt;Killed[SIGKILL]&lt;/h4&gt;
&lt;p&gt;进程收到系统指令被干掉，可以自行查看Termination Reason来定位线程被干掉的原因。&lt;/p&gt;

&lt;h4 id=&quot;guarded-resource-violation-exc_guard&quot;&gt;Guarded Resource Violation [EXC_GUARD]&lt;/h4&gt;
&lt;p&gt;进程访问了一个被保护的资源。&lt;/p&gt;

&lt;h4 id=&quot;resource-limit-exc_resource&quot;&gt;Resource Limit [EXC_RESOURCE]&lt;/h4&gt;
&lt;p&gt;进程的资源超过限定阈值，表示进程占用太多资源，&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Subtype&lt;/code&gt;会提示原因，例如&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEMORY&lt;/code&gt;:暗示了进程占用已经超过系统限制。如果之后出现由于系统占用过多进程被Kill，可能和这有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;WAKEUP&lt;/code&gt;:暗示线程每秒被进程唤醒太多次了，进而导致CPU被频繁唤醒并且造成电量损耗。
通常，这种事发生在线程间通信（通过&lt;code class=&quot;highlighter-rouge&quot;&gt;peformSelector:onThread:&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_async&lt;/code&gt;），而且会远比预想的发生的更频繁。因为发生这种异常的通信被触发的如此频繁，所以很多后台线程会出现彼此高度雷同的堆栈信息——恰恰暗示了它们是从哪儿来的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;other-exception-types&quot;&gt;Other Exception Types&lt;/h4&gt;
&lt;p&gt;有些report可能出现无名的&lt;code class=&quot;highlighter-rouge&quot;&gt;Exception Type&lt;/code&gt;，取而代之出现的是16进制的地址(0x12387617823)，下面列举一些&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xbaaaaaad&lt;/code&gt;: 则说明此条logs是系统堆栈快照，并非crash report。可以通过同时按（手机）侧边按钮和音量键来记录堆栈快照。通常情况下，这些logs是用户无意中生成的，并非表示错误。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xbad22222&lt;/code&gt;: 表示一个VoIP应用因为频繁暂停被iOS系统终止掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x8badf00d&lt;/code&gt;:（读起来像badfood）则说明一个应用因为触发了看门狗机制被iOS系统终止掉，有可能是应用花了太长时间启动，终止，或者是响应系统事件。一种常见原因是在主线程上做网络同步逻辑。不论Thread0上（也就是主线程）想做什么（重要的事），都应该转移到后台线程，或者换一种方式触发，这样它才不会阻塞主线程。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xc00010ff&lt;/code&gt;: 则说明app因为环境过热（的事件）被iOS系统干掉了。这个也许是和发生crash的特定设备有关，或者是和它所在的环境有关。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0xdead10cc&lt;/code&gt;: (读起来像deadlock)则说明一个应用被系统终止掉，原因是在应用挂起时拿到了文件锁或者sqlite数据库所长期不释放直到被冻结。如果你的app在挂起时拿到了文件锁或者sqlite数据库锁，它必须请求额外的后台执行时间(request additional background execution time )并在被挂起前完成解锁操作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0x2bad45ec&lt;/code&gt;: 则说明app因为违规操作（安全违规）被iOS系统终止。终止描述会写：“进程被查到在安全模式进行非安全操作”，暗示app尝试在禁止屏幕绘制的时候绘制屏幕，例如当屏幕锁定时。用户可能会忽略这种异常，尤其当屏幕是关闭的或者当这种终止发生时正好锁屏。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;低内存low-memory-reports&quot;&gt;低内存Low Memory Reports&lt;/h3&gt;
&lt;p&gt;当系统检测到内存不足时，虚拟内存系统会协同各应用来做内存释放，各个应用都会接受到内存警告，要求释放内存空间。如果内存依然不够，则你的应用会被终止，并生成report 存储在设备中，没有堆栈信息，可能的原因有一下几个：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[per-process-limit]&lt;/code&gt;:进程占用超过了它的最大内存值。每一个进程在常驻内存上的限制是早已经由系统为每个应用分配好了的。超过这个限制会导致进程被系统干掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[vm-pageshortage]/[vm-thrashing]/[vm]&lt;/code&gt;:由于系统内存压力被干掉。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[vnode-limit]&lt;/code&gt;: 打开太多文件了。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[highwater]&lt;/code&gt;:一个系统守护进程超过过了它的内存占用高水位（就是已经很危险了）。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[jettisoned]&lt;/code&gt;:进程因为其它不可描述的原因被杀掉。&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/iOS-Crash-%E5%88%86%E6%9E%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/iOS-Crash-%E5%88%86%E6%9E%90/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>视频秒开优化方案</title>
        <description>&lt;h3 id=&quot;前置metadata&quot;&gt;前置metadata：&lt;/h3&gt;
&lt;p&gt;需要获取文件的metadata，解析出文件的编码，帧率等信息后才能开始边下边播，所以尽量让metadata或 MOOV box在靠近文件头部的位置，保证播放器尽快播放&lt;/p&gt;

&lt;h3 id=&quot;选择合适的缓冲策略&quot;&gt;选择合适的缓冲策略：&lt;/h3&gt;
&lt;p&gt;AVPlayer的 automaticallyWaitsToMinimizeStalling属性就是尽量多缓存一段时间，保证播放过程中减少卡顿&lt;/p&gt;

&lt;h3 id=&quot;使用httpdns加快建连&quot;&gt;使用HTTPDNS加快建连：&lt;/h3&gt;
&lt;p&gt;获取最优的CDN节点地址，并每隔一段时间获取一次最佳CDN节点，准实时的保证使用最佳节点。&lt;/p&gt;

&lt;h3 id=&quot;提升cdn命中率&quot;&gt;提升CDN命中率：&lt;/h3&gt;
&lt;p&gt;减少CDN的资源部命中，减少回源，比如URL中减少随机性的值，增加匹配命中概率。&lt;/p&gt;

&lt;h3 id=&quot;域名解析&quot;&gt;域名解析：&lt;/h3&gt;
&lt;p&gt;使用HTTPDNS快速获取最佳CDN节点信息。&lt;/p&gt;

&lt;h3 id=&quot;socket-cache&quot;&gt;Socket cache:&lt;/h3&gt;
&lt;p&gt;TCP的数据收发都是在缓冲区中完成拼装，通过调整缓冲区的大小。设置太小，影响效率，设置太大， 会短时间吃掉带宽(根据带宽探测原理可知),通过ffmpeg提供的api可修改。&lt;/p&gt;

&lt;h3 id=&quot;探测buffer&quot;&gt;探测buffer:&lt;/h3&gt;
&lt;p&gt;一开始需要先读一段数据，再对数据进行探测，得到封装格式、分辨率等信息。这个buffer可以设置。&lt;/p&gt;

&lt;h3 id=&quot;格式探测&quot;&gt;格式探测：&lt;/h3&gt;
&lt;p&gt;播放端开始时会探测数据格式，根据自己支持的格式探测出一个分数，得到相应的格式，如果短视频格式确定，就可以减少不必要的探测类型。&lt;/p&gt;

&lt;h3 id=&quot;播放-buffer&quot;&gt;播放 buffer:&lt;/h3&gt;
&lt;p&gt;减少播放的缓冲，一般缓冲buffer会按照帧数设置，但是短视频可以减小这个数字，达到尽快解码播放。&lt;/p&gt;

&lt;h3 id=&quot;分辨率视频格式&quot;&gt;分辨率、视频格式：&lt;/h3&gt;
&lt;p&gt;一定程度降低分辨率，减小文件大小。使用HEVC格式。&lt;/p&gt;

</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E8%A7%86%E9%A2%91%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E8%A7%86%E9%A2%91%E7%A7%92%E5%BC%80%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>网络优化策略</title>
        <description>&lt;h3 id=&quot;网络优化策略&quot;&gt;网络优化策略&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;NSCache缓存，Last-Modified, ETag&lt;/li&gt;
  &lt;li&gt;DNS解析&lt;/li&gt;
  &lt;li&gt;数据压缩，protobuf, WebP&lt;/li&gt;
  &lt;li&gt;失败重发，缓存请求有网发送&lt;/li&gt;
  &lt;li&gt;弱网下设置不同超时时间&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nscache缓存&quot;&gt;NSCache缓存&lt;/h4&gt;
&lt;p&gt;Get类似SQL查找，所以默认会缓存，Post是提交数据，类似UPDATE，所以不会缓存。
Last-Modified：资源最后修改时间，来判断是否过期
请求response中会包含该字段和时间，下次请求时加上if-Modified-since : xxxx， 如果资源无变化返回304 Not Changed。&lt;/p&gt;

&lt;p&gt;ETag:资源文件的hash值，与当前资源文件比对是否一致，不一致则返回新值，一致则不返回。&lt;/p&gt;

&lt;h4 id=&quot;dns解析&quot;&gt;DNS解析&lt;/h4&gt;
&lt;p&gt;使用HTTPDNS 解析域名，代替从localDNS获取IP。 当HTTPDNS解析失败时再走localDNS.
或者本地维护IP list，与HTTPDNS的结果做更新&lt;/p&gt;

&lt;h4 id=&quot;数据压缩&quot;&gt;数据压缩&lt;/h4&gt;
&lt;p&gt;webP图片格式比PNG和jpg 体积小，但是webP图片需要解析才能成为可用的jpg图片， app内解析肯定要花费一定的性能。
在wifi条件下，较大的图片直接使用png/jpg, 减少解析时间。  4G条件下，建议用webP,对流量比较友好&lt;/p&gt;

&lt;h4 id=&quot;失败重发&quot;&gt;失败重发&lt;/h4&gt;
&lt;p&gt;超时或失败的请求建立重发机制，待网络通畅后再次发送&lt;/p&gt;

&lt;h4 id=&quot;弱网下设置不同超时时间&quot;&gt;弱网下设置不同超时时间&lt;/h4&gt;
&lt;p&gt;不同网络状态下超时时间设置不同，例如4G只需要10秒，3G需要20秒，在超时后依然无法与服务端建立连接，可排查网络链路通畅性，例如使用HTTPDNS切换新的服务器站点，尝试连接。&lt;/p&gt;

&lt;h3 id=&quot;http2相比http1x的升级&quot;&gt;HTTP2相比HTTP1.x的升级：&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP/2采用二进制格式传输数据 ，而不是1.x的文本格式。&lt;/li&gt;
  &lt;li&gt;对消息头进行压缩传输，节省消息头占用的流量。 1.x每次请求携带大量冗余头信息，浪费资源&lt;/li&gt;
  &lt;li&gt;多路复用，一个域名下的请求可以通过一个TCP连接并发完成，毕竟新开一个TCP连接都需要慢慢提升传输速度。 1.x虽然通过pipeline也能并发请求，但是多个请求之间响应会被阻塞。采用二进制分帧，数据流可以乱序发送，接收后可以重新组装。&lt;/li&gt;
  &lt;li&gt;server push， 服务端提前把资源推送给客户端&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/12/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/12/%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
