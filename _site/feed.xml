<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 16 Sep 2020 22:44:05 +0800</pubDate>
    <lastBuildDate>Wed, 16 Sep 2020 22:44:05 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>CoreAnimation</title>
        <description>&lt;h2 id=&quot;1-图层树&quot;&gt;1. 图层树&lt;/h2&gt;
&lt;p&gt;CALayer 是存在于UIView中的一种平行的层级关系
&lt;img src=&quot;http://image.smartjames.cn/20200811234017.jpg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2寄宿图&quot;&gt;2.寄宿图&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;contens 属性可以给layer赋值CGImage
contentsGravity属性类似contentModel：kCAGravityResizeAspect
contentsScale属性用来设置渲染倍数 
contentsRect用来显示contents中指定区域，适用于雪碧图的展示
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 裁剪并显示雪碧图，不用从内存中读多张图片，4张图片在一张雪碧图中
- (void)addSpriteImage:(UIImage *)img withContentRect:(CGRect)rect toLayer:(CALayer *)layer
{
    layer.contents = (__bridge id)(img.CGImage);
    layer.contentsGravity = kCAGravityResizeAspect;
    layer.contentsRect = rect;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3-图层几何学&quot;&gt;3. 图层几何学&lt;/h2&gt;
&lt;p&gt;UIView的center和 CALayer的position是 一个含义，代表中间点相对于父视图的位置。&lt;/p&gt;

&lt;p&gt;anchorPoint是用单位坐标表示的center和position的值作用与本身的那个位置。&lt;/p&gt;

&lt;p&gt;anchorPoint 可以用来实现时钟的指针转动
&lt;img src=&quot;http://image.smartjames.cn/20200812165714.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;
用layer的 -hitTest: 方法判断当前点击的是那个图层。一般情况下，我们理解layer是不能响应点击时间的，但是layer有这种方法判断点击位置&lt;/p&gt;

&lt;p&gt;CALayerDelegate提供如下函数，当frame变化时会调用，用以重新处理layer的位置，但是无法做到像UIView的自适应屏幕。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)layoutSublayersOfLayer:(CALayer *)layer;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;4视觉效果&quot;&gt;4.视觉效果&lt;/h2&gt;

&lt;p&gt;阴影      &lt;br /&gt;
shadowOffset表示阴影的相对位移，默认值{0,-3}， 表示阴影上移3个点，因为Core Animation是Mac OS上出现的，Mac和iOS坐标系是翻转的，所以在Mac上显示的就是向下位移3个点。&lt;/p&gt;

&lt;p&gt;shadowRadius是控制阴影的模糊度&lt;/p&gt;

&lt;p&gt;shadowPath通过一个CGPath来绘制阴影，因为当视图有多个图层，shadowOffset计算阴影会非常消耗资源。可以通过shadowPath提前绘制一个大概的阴影代替会快很多，涉及到离屏渲染。&lt;/p&gt;

&lt;p&gt;蒙版
mask是图层的属性，类型也是图层，可以用来将蒙版以外的内容裁剪掉。而且支持动态的mask
&lt;img src=&quot;http://image.smartjames.cn/20200812175605.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;拉伸过滤
minificationFilter和magnificationFilter属性，提供3中拉伸函数&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kCAFilterLinear&lt;/li&gt;
  &lt;li&gt;kCAFilterNearest&lt;/li&gt;
  &lt;li&gt;kCAFilterTrilinear&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;组透明
UIViewGroupOpacity，当一个控件a内部有另一个控件b, 设置a的alpha, 那么b的透明度也是0.5，但是会叠加控件a的部分颜色，通过在infoplsit中设置UIViewGroupOpacity为yes,或者设置layer的shouldRasterize=yes。
但是在最新的系统上，已经不需要单独处理这种问题。
&lt;img src=&quot;http://image.smartjames.cn/20200812183557.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;5变换&quot;&gt;5.变换&lt;/h2&gt;

&lt;h3 id=&quot;仿射变换&quot;&gt;仿射变换：&lt;/h3&gt;
&lt;p&gt;属于Core Graphics框架，是2D绘图API, 和UIView一样，只有2维空间&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)     
CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)      
CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CALayer有三维空间，所以同理CATransform3D属于Core Animation框架可以支持3D变换
API增加了Z轴旋转角度，XYZ轴缩放比例，和Z轴的移动距离&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz)
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200812222012.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。
但是旋转得到的结果是等距投影，与真实世界里透视投影不一样。在等距投影中，远处的物体和近处的物体保持同样的缩放比例。引出透视投影的概念。&lt;/p&gt;

&lt;h3 id=&quot;透视投影&quot;&gt;透视投影：&lt;/h3&gt;
&lt;p&gt;在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边更短。
通过矩阵中一个元素控制：m34。m34的默认值是0，我们可以通过设置m34为-1.0 / d来应用透视效果；d是相机与屏幕之间的距离。
&lt;img src=&quot;http://image.smartjames.cn/20200812234846.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CATransform3D transform = CATransform3DIdentity;
    transform.m34 = - 1.0 / 500.0;
    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);
    self.layerView.layer.transform = transform;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;sublayerTransform属性，使子图层都有相同的trasnform设置。&lt;/p&gt;

&lt;h3 id=&quot;背面&quot;&gt;背面&lt;/h3&gt;
&lt;p&gt;旋转180°后，形成一个镜像，可以用doubleSided属性控制背面是否需要绘制。&lt;/p&gt;

&lt;h3 id=&quot;扁平化图层&quot;&gt;扁平化图层&lt;/h3&gt;
&lt;p&gt;当父视图沿着Y轴旋转45°时，子视图沿着Y轴旋转-45°时，预期结果如下，能够抵消旋转的角度
&lt;img src=&quot;http://image.smartjames.cn/20200812235931.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是真实结果如下所示，子视图并没有垂直Z轴，因为CoreAnimation的3D场景其实是扁平化的，3D场景是图层想象出来的，绘制在图层表面的，且各自独立在不同的3D空间。
&lt;img src=&quot;http://image.smartjames.cn/20200812235939.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;
所以用普通的CALayer很难创建非常复杂的3D场景，除非用CATransformLayer。&lt;/p&gt;

&lt;h3 id=&quot;固体对象&quot;&gt;固体对象&lt;/h3&gt;
&lt;p&gt;通过将不同layer旋转不同角度，拼凑成一个表面看是实心体。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;
    
    // 都旋转一个角度,看到侧面
    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);
    
    self.view.layer.sublayerTransform = perspective;
    //add cube face 1
    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);
    [self addFace:0 withTransform:transform];
    //add cube face 2
    transform = CATransform3DMakeTranslation(100, 0, 0);
    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
    [self addFace:1 withTransform:transform];
    //add cube face 3
    transform = CATransform3DMakeTranslation(0, -100, 0);
    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
    [self addFace:2 withTransform:transform];
    //add cube face 4
    transform = CATransform3DMakeTranslation(0, 100, 0);
    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
    [self addFace:3 withTransform:transform];
    //add cube face 5
    transform = CATransform3DMakeTranslation(-100, 0, 0);
    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
    [self addFace:4 withTransform:transform];
    //add cube face 6
    transform = CATransform3DMakeTranslation(0, 0, -100);
    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
    [self addFace:5 withTransform:transform];
    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813003034.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;6专用图层&quot;&gt;6.专用图层&lt;/h2&gt;

&lt;h3 id=&quot;cashapelayer&quot;&gt;CAShapeLayer&lt;/h3&gt;
&lt;p&gt;一个通过矢量图形而不是bitmap来绘制的图层子类。&lt;/p&gt;

&lt;p&gt;定义颜色和线宽用CGPath就能渲染，看起来Core Graphics也能实现，但是CAShapeLayer优点如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;渲染快。使用了硬件加速，绘制比CG快很多&lt;/li&gt;
  &lt;li&gt;高效使用内存。不会像普通CALayer一样创建一个寄宿图，所以无论多大，都不会占用太多内存&lt;/li&gt;
  &lt;li&gt;不会被图层边界裁掉。可以在边界之外绘制&lt;/li&gt;
  &lt;li&gt;不会像素化。因为是矢量图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现3个圆角，1个直角的矩形。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CGRect rect = CGRectMake(50, 50, 100, 100);
    CGSize radii = CGSizeMake(20, 20);
    UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomLeft | UIRectCornerTopLeft;
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];
    
CAShapeLayer *layer = [CAShapeLayer layer];
........ // 设置宽度颜色等
layer.path = path.CGPath;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;catextlayer&quot;&gt;CATextLayer&lt;/h3&gt;
&lt;p&gt;它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。同样，CATextLayer也要比UILabel渲染得快得多。很少有人知道在iOS 6及之前的版本，UILabel其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core text，并且渲染得非常快。&lt;/p&gt;

&lt;h3 id=&quot;catransformlayer&quot;&gt;CATransformLayer&lt;/h3&gt;
&lt;p&gt;前面想做一个立体图形的旋转状态，需要对立体图形的每一个图层做一次旋转。
现在使用CATransformLayer不需要，只要创建立体图形时把图层加入到CATransformLayer中，旋转CATransformLayer一次即可实现立体图形旋转。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (CALayer *)cubeWithTransform:(CATransform3D)transform
{
  //create cube layer
  CATransformLayer *cube = [CATransformLayer layer];

  //add cube face 1
  CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);
  [cube addSublayer:[self faceWithTransform:ct]];

// .......

  //add cube face 6
  ct = CATransform3DMakeTranslation(0, 0, -50);
  ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);
  [cube addSublayer:[self faceWithTransform:ct]];

  //center the cube layer within the container
  CGSize containerSize = self.containerView.bounds.size;
  cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);

  //apply the transform and return
  cube.transform = transform;
  return cube;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813010733.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cagradientlayer&quot;&gt;CAGradientLayer&lt;/h3&gt;
&lt;p&gt;用来生成2种或更多颜色平滑渐变的图层。&lt;/p&gt;

&lt;p&gt;startPoint和endPoint决定渐变方向，用单位坐标系定义，左上角是{0,0}, 右下角是{1,1}
location定义不同颜色的位置，个数要和颜色个数相同，可选。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad {
	[super viewDidLoad];

	//create gradient layer and add it to our container view
	CAGradientLayer *gradientLayer = [CAGradientLayer layer];
	gradientLayer.frame = self.containerView.bounds;
	[self.containerView.layer addSublayer:gradientLayer];

	//set gradient colors
	gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];

	//set locations
	gradientLayer.locations = @[@0.0, @0.25, @0.5];

	//set gradient start and end points
	gradientLayer.startPoint = CGPointMake(0, 0);
	gradientLayer.endPoint = CGPointMake(1, 1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813011439.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;careplicatorlayer&quot;&gt;CAReplicatorLayer&lt;/h3&gt;
&lt;p&gt;为了高效生成许多相似的重复图层。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)viewDidLoad
{
    [super viewDidLoad];
    //create a replicator layer and add it to our view
    CAReplicatorLayer *replicator = [CAReplicatorLayer layer];
    replicator.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:replicator];

    //configure the replicator
    replicator.instanceCount = 10;

    //apply a transform for each instance
    CATransform3D transform = CATransform3DIdentity;
    transform = CATransform3DTranslate(transform, 0, 200, 0);
    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
    transform = CATransform3DTranslate(transform, 0, -200, 0);
    replicator.instanceTransform = transform;

    //apply a color shift for each instance
    replicator.instanceBlueOffset = -0.1;
    replicator.instanceGreenOffset = -0.1;

    //create a sublayer and place it inside the replicator
    CALayer *layer = [CALayer layer];
    layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);
    layer.backgroundColor = [UIColor whiteColor].CGColor;
    [replicator addSublayer:layer];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813012855.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;instanceCount 代表有复制多少次
instanceTransform属性，代表后续每个图层都要做这个变换。
instanceBlueOffset和instanceGreenOffset代表每次减少蓝色绿色通道多少值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;镜像&lt;/strong&gt;
用CAReplicatorLayer实现镜像效果&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;
    layer.instanceCount = 2;

    //move reflection instance below original and flip vertically
    CATransform3D transform = CATransform3DIdentity;
    CGFloat verticalOffset = self.bounds.size.height + 2;
    transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);
    transform = CATransform3DScale(transform, 1, -1, 0);
    layer.instanceTransform = transform;

    //reduce alpha of reflection layer
    layer.instanceAlphaOffset = -0.6;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2个重复对象，移动高度的2倍，缩小一点，颜色透明一点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813013306.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cascrolllayer&quot;&gt;CAScrollLayer&lt;/h3&gt;
&lt;p&gt;实现类似UIScrollView的图层，但是内容可以滑出边界。&lt;/p&gt;

&lt;h3 id=&quot;catiledlayer&quot;&gt;CATiledLayer&lt;/h3&gt;
&lt;p&gt;iOS中绘制图片最终是转化为OpenGL纹理，最大纹理尺寸是2048×2048或4096×4096， 如果图片超过这个尺寸，会遇到性能问题。&lt;/p&gt;

&lt;p&gt;因为Core Animation强制用CPU处理图片而不是GPU。&lt;/p&gt;

&lt;p&gt;CATiledLayer会将大图片分解成小图片然后按需载入，类似ScrollView.
    &lt;strong&gt;使用场景&lt;/strong&gt;是iOS老版本的地图应用，会一块一块的显示新的之前未曾渲染过的地图，就是用到了这个技术。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //determine tile coordinate
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);

    //load tile image
    NSString *imageName = [NSString stringWithFormat: @&quot;Snowman_%02i_%02i&quot;, x, y];
    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;jpg&quot;];
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];

    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:bounds];
    UIGraphicsPopContext();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;滑动图层到边缘时自动调用在drawLayer方法，获取对应要显示的图片并渲染。
CATiledLayer支持多线程绘制，这一点不同于UIKit和Core Animation方法。即-drawLayer:inContext: 能在多线程中并发调用&lt;/p&gt;

&lt;h3 id=&quot;caemitterlayer&quot;&gt;CAEmitterLayer&lt;/h3&gt;
&lt;p&gt;是一个高性能的粒子引擎，被用来创建实时粒子动画如：烟雾，火，雨，烟花等。&lt;/p&gt;

&lt;p&gt;CAEmitterLayer是CAEmitterCell的容器，后者定义了粒子效果，CAEmitterLayer将不同的粒子效果cell作为模板实例化粒子流。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   CAEmitterLayer *emitter = [CAEmitterLayer layer];
    emitter.frame = self.view.bounds;
    [self.view.layer addSublayer:emitter];

    //configure emitter
    emitter.renderMode = kCAEmitterLayerAdditive;
    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);

    //create a particle template
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
    cell.alphaSpeed = -0.4;
    cell.velocity = 50;
    cell.velocityRange = 50;
    cell.emissionRange = M_PI * 2.0;

    //add particle template to emitter
    emitter.emitterCells = @[cell];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813020502.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;CAEMitterCell的属性基本上可以分为三种：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。&lt;/li&gt;
  &lt;li&gt;粒子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着粒子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形。&lt;/li&gt;
  &lt;li&gt;指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说粒子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐消失的效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;caeagllayer&quot;&gt;CAEAGLLayer&lt;/h3&gt;
&lt;p&gt;当想使用GLKit实现OpenGL渲染时，使用CLKView类来处理大部分的设置和绘制工作，但是OpenGL 绘图缓冲的底层可配置项仍然需要使用CAEAGLLayer完成，用来显示任意的Open GL图形。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#import &quot;ViewController.h&quot;
#import &amp;lt;QuartzCore/QuartzCore.h&amp;gt;
#import &amp;lt;GLKit/GLKit.h&amp;gt;

@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *glView;
@property (nonatomic, strong) EAGLContext *glContext;
@property (nonatomic, strong) CAEAGLLayer *glLayer;
@property (nonatomic, assign) GLuint framebuffer;
@property (nonatomic, assign) GLuint colorRenderbuffer;
@property (nonatomic, assign) GLint framebufferWidth;
@property (nonatomic, assign) GLint framebufferHeight;
@property (nonatomic, strong) GLKBaseEffect *effect;

@end

@implementation ViewController

- (void)setUpBuffers
{
    //set up frame buffer
    glGenFramebuffers(1, &amp;amp;_framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);

    //set up color render buffer
    glGenRenderbuffers(1, &amp;amp;_colorRenderbuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.glLayer];
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;amp;_framebufferWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;amp;_framebufferHeight);

    //check success
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        NSLog(@&quot;Failed to make complete framebuffer object: %i&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));
    }
}

- (void)tearDownBuffers
{
    if (_framebuffer) {
        //delete framebuffer
        glDeleteFramebuffers(1, &amp;amp;_framebuffer);
        _framebuffer = 0;
    }

    if (_colorRenderbuffer) {
        //delete color render buffer
        glDeleteRenderbuffers(1, &amp;amp;_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
}

- (void)drawFrame {
    //bind framebuffer &amp;amp; set viewport
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    glViewport(0, 0, _framebufferWidth, _framebufferHeight);

    //bind shader program
    [self.effect prepareToDraw];

    //clear the screen
    glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0, 0.0, 0.0, 1.0);

    //set up vertices
    GLfloat vertices[] = {
        -0.5f, -0.5f, -1.0f, 0.0f, 0.5f, -1.0f, 0.5f, -0.5f, -1.0f,
    };

    //set up colors
    GLfloat colors[] = {
        0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,
    };

    //draw triangle
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vertices);
    glVertexAttribPointer(GLKVertexAttribColor,4, GL_FLOAT, GL_FALSE, 0, colors);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    //present render buffer
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    //set up context
    self.glContext = [[EAGLContext alloc] initWithAPI: kEAGLRenderingAPIOpenGLES2];
    [EAGLContext setCurrentContext:self.glContext];

    //set up layer
    self.glLayer = [CAEAGLLayer layer];
    self.glLayer.frame = self.glView.bounds;
    [self.glView.layer addSublayer:self.glLayer];
    self.glLayer.drawableProperties = @{kEAGLDrawablePropertyRetainedBacking:@NO, kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8};

    //set up base effect
    self.effect = [[GLKBaseEffect alloc] init];

    //set up buffers
    [self setUpBuffers];

    //draw frame
    [self drawFrame];
}

- (void)viewDidUnload
{
    [self tearDownBuffers];
    [super viewDidUnload];
}

- (void)dealloc
{
    [self tearDownBuffers];
    [EAGLContext setCurrentContext:nil];
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/20200813021236.png&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;avplayerlayer&quot;&gt;AVPlayerLayer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由AVFoundation框架提供用于播放视频的图层。 因为本身是CALayer的子类，所以也支持layer该有的效果，例如边框，圆角，蒙版，阴影等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;7隐式动画&quot;&gt;7.隐式动画&lt;/h2&gt;

&lt;h3 id=&quot;事务&quot;&gt;事务&lt;/h3&gt;
&lt;p&gt;通过CATransaction类来管理，通过begin和commit的入栈和出栈来管理栈中的动画事务，栈中的动画默认执行时长0.25秒  &lt;br /&gt;
不显示的调用begin，在runloop一个周期内，也会收集所有属性的变化，做一些0.25秒的动画。  &lt;br /&gt;
CATransaction 有completionBlock方法，动画执行完后会自动调用。&lt;/p&gt;

&lt;p&gt;UIView会默认禁用关联图层的动画效果，否则对于UIview的属性修改都会形成动画效果，这不是我们想要的。要实现UIView的动画，使用UIView的animateWithDuration：方法；&lt;/p&gt;

&lt;h3 id=&quot;catransition&quot;&gt;CATransition&lt;/h3&gt;
&lt;p&gt;控制移动的动画类，使用方法如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CATransition *transition = [CATransition animation];
transition.type = kCATransitionPush;
transition.subtype = kCATransitionFromLeft;
self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CALayer的属性值变化，其实在设置的当时已经变化，只是视图的更新会延后，CALayer在动画过程中，需要知道当前显示在屏幕上的属性值的记录，所以提供-presentationLayer方法来访问当前呈现的图层。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342476.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;大多数情况下，不需要直接访问呈现图层，但在以下俩种情况下呈现图层会很有用，一个是同步动画，一个是处理用户交互。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果实现一个基于定时器的动画，而不仅仅是基于事务的动画，这个时候准确地知道在某个时刻图层显示在什么位置就会对正确摆放图层很有用。&lt;/li&gt;
  &lt;li&gt;想让动画的图层响应用户输入，可以使用++-hitTest:++ 方法判断指定图层是否被触摸，此时响应的是呈现图层，而不是动画结束后的模型图层。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8显式动画&quot;&gt;8.显式动画&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;显式动画相对于隐式动画，是用户自己主动创建的一种动画类型，与隐式动画做的关于属性动画不同。 ### 属性动画
作用于图层的某个单一属性，并指定了它的一个或一连串目标值，分为基础动画和关键帧动画，即CABasicAnimation和CAKeyframeAnimation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;基础动画&quot;&gt;基础动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;最简单的形式就是从一个值改变到另一个值，这也是CABasicAnimation最主要的功能。提供了fromValue, toValue, byValue三个属性。fromValue代表了动画开始之前属性的值，toValue代表了动画结束之后的值，byValue代表了动画执行过程中改变的相对值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CABasicAnimation *animation = [CABasicAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.toValue = (__bridge id)color.CGColor;
    [self.colorLayer addAnimation:animation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面这种动画，是使layer变换颜色，但是动画结束后又立刻变回原始值，因为这里使用的显式动画改变的是呈现层，不是模型层（隐式动画通过赋值达到改变模型层）。解决方案是动画完成前赋值给模型层。&lt;/p&gt;

&lt;h3 id=&quot;关键帧动画&quot;&gt;关键帧动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation揭示了大多数隐式动画背后依赖的机制，这的确很有趣，但是显式地给图层添加CABasicAnimation相较于隐式动画而言，只能说费力不讨好。 CAKeyframeAnimation是另一种UIKit没有暴露出来但功能强大的类。不光能设置单一值，还能设置一串值。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;backgroundColor&quot;;
    animation.duration = 2.0;
    animation.values = @[
                         (__bridge id)[UIColor blueColor].CGColor,
                         (__bridge id)[UIColor redColor].CGColor,
                         (__bridge id)[UIColor greenColor].CGColor,
                         (__bridge id)[UIColor blueColor].CGColor ];
    [self.colorLayer addAnimation:animation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上面给关键帧的values赋值了一个颜色组，每个颜色默认动画0.25秒。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
    animation.keyPath = @&quot;position&quot;;
    animation.duration = 4.0;
    animation.path = bezierPath.CGPath;
    [shipLayer addAnimation:animation forKey:nil];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关键帧不光能接受一组值，还能接受一个路径，使用Core Graphics函数定义运动序列来绘制动画。移动中通过设置rotationMode = kCAAnimationRotateAuto达到图层垂直于路径。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342490.jpeg&quot; style=&quot;zoom:40%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;虚拟属性&quot;&gt;虚拟属性&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;前面的属性动画都针对真实属性，例如backgroundColor, position等。如果想对一个属性的路径，或不是真实属性做动画，就是虚拟属性。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform&quot;;
animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;正常的属性赋值是上面这样，使用虚拟属性可以向下面一样使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CABasicAnimation *animation = [CABasicAnimation animation];
animation.keyPath = @&quot;transform.rotation&quot;;
animation.byValue = @(M_PI * 2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;用transform.rotation而不是transform做动画的好处如下：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;我们可以不通过关键帧一步旋转多于180度的动画。&lt;/li&gt;
  &lt;li&gt;可以用相对值而不是绝对值旋转（设置byValue而不是toValue）。&lt;/li&gt;
  &lt;li&gt;可以不用创建CATransform3D，而是使用一个简单的数值来指定角度。&lt;/li&gt;
  &lt;li&gt;不会和transform.position或者transform.scale冲突（同样是使用关键路径来做独立的动画属性）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;过渡变幻&quot;&gt;过渡/变幻&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用CATransition类，有4种变换类型。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kCATransitionFade&lt;/li&gt;
  &lt;li&gt;kCATransitionMoveIn&lt;/li&gt;
  &lt;li&gt;kCATransitionPush&lt;/li&gt;
  &lt;li&gt;kCATransitionReveal&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;和4个方向&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;kCATransitionFromRight&lt;/li&gt;
  &lt;li&gt;kCATransitionFromLeft&lt;/li&gt;
  &lt;li&gt;kCATransitionFromTop&lt;/li&gt;
  &lt;li&gt;kCATransitionFromBottom&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342502.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;自定义动画&quot;&gt;自定义动画&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;过渡是一种对那些不太好做平滑动画属性的强大工具，但是CATransition的提供的动画类型太少了。 UIView +transitionFromView:toView:duration:options:completion: 提供的过渡选项却很多 - UIViewAnimationOptionTransitionFlipFromLeft  - UIViewAnimationOptionTransitionFlipFromRight - UIViewAnimationOptionTransitionCurlUp  - UIViewAnimationOptionTransitionCurlDown - UIViewAnimationOptionTransitionCrossDissolve  - UIViewAnimationOptionTransitionFlipFromTop  - UIViewAnimationOptionTransitionFlipFromBottom
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;9图层时间&quot;&gt;9.图层时间&lt;/h2&gt;

&lt;h3 id=&quot;camediatiming-协议&quot;&gt;CAMediaTiming 协议&lt;/h3&gt;
&lt;p&gt;CAMediaTiming协议定义了在一段动画内用来控制逝去时间的属性的集合，CALayer和CAAnimation都实现了此协议。&lt;/p&gt;

&lt;p&gt;常用属性&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;duration      动画持续时间&lt;/li&gt;
  &lt;li&gt;repeatCount   重复次数&lt;/li&gt;
  &lt;li&gt;speed         倍速，0暂停，负数回放动画&lt;/li&gt;
  &lt;li&gt;beginTime     动画开始之前的的延迟时间&lt;/li&gt;
  &lt;li&gt;timeOffset    动画快进到某一点&lt;/li&gt;
  &lt;li&gt;fillMode      动画结束是否保持之前的状态，定义了几个类型&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kCAFillModeForwards
kCAFillModeBackwards
kCAFillModeBoth
kCAFillModeRemoved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;autoreverses  是否进行反向动画，实现门的开关&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342517.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;10时间函数&quot;&gt;10.时间函数&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;为了让动画显得更自然，而不是很机械，需要使用时间函数控制动画速率
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;camediatimingfunction&quot;&gt;CAMediaTimingFunction&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CAAnimation的timingFunciont属性接收一个CAMediaTimingFunction对象。 包含以下类型 - kCAMediaTimingFunctionLinear  - kCAMediaTimingFunctionEaseIn  - kCAMediaTimingFunctionEaseOut  - kCAMediaTimingFunctionEaseInEaseOut - kCAMediaTimingFunctionDefault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;uiview的时间函数&quot;&gt;UIView的时间函数&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UIView的动画也支持时间函数，参考CAAnimation的函数 - UIViewAnimationOptionCurveEaseInOut  - UIViewAnimationOptionCurveEaseIn  - UIViewAnimationOptionCurveEaseOut  - UIViewAnimationOptionCurveLinear
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;自定义时间函数&quot;&gt;自定义时间函数&lt;/h3&gt;
&lt;p&gt;除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::
三次贝塞尔时间函数，自定义函数的入参就是图中的几个控制点
参数就是图中的几个控制点&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002639342534.jpeg&quot; style=&quot;zoom:50%&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;12性能调优&quot;&gt;12.性能调优&lt;/h2&gt;

&lt;h3 id=&quot;影响gpu-降低图层绘制&quot;&gt;影响GPU， 降低图层绘制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;太多的几何结构 - 这发生在需要太多的三角板来做变换，以应对处理器的栅格化的时候。现代iOS设备的图形芯片可以处理几百万个三角板，所以在Core Animation中几何结构并不是GPU的瓶颈所在。但由于图层在显示之前通过IPC发送到渲染服务器的时候（图层实际上是由很多小物体组成的特别重量级的对象），太多的图层就会引起CPU的瓶颈。这就限制了一次展示的图层个数（见本章后续“CPU相关操作”）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重绘 - 主要由重叠的半透明图层引起。GPU的填充比率（用颜色填充像素的比率）是有限的，所以需要避免重绘（每一帧用相同的像素填充多次）的发生。在现代iOS设备上，GPU都会应对重绘；即使是iPhone 3GS都可以处理高达2.5的重绘比率，并任然保持60帧率的渲染（这意味着你可以绘制一个半的整屏的冗余信息，而不影响性能），并且新设备可以处理更多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;离屏绘制 - 这发生在当不能直接在屏幕上绘制，并且必须绘制到离屏图片的上下文中的时候。离屏绘制发生在基于CPU或者是GPU的渲染，或者是为离屏图片分配额外内存，以及切换绘制上下文，这些都会降低GPU性能。对于特定图层效果的使用，比如圆角，图层遮罩，阴影或者是图层光栅化都会强制Core Animation提前渲染图层的离屏绘制。但这不意味着你需要避免使用这些效果，只是要明白这会带来性能的负面影响。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;过大的图片 - 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理，就必须要用CPU在图层每次显示之前对图片预处理，同样也会降低性能。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;影响cpu延迟动画开始时间&quot;&gt;影响CPU，延迟动画开始时间&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;布局计算 - 如果你的视图层级过于复杂，当视图呈现或者修改的时候，计算图层帧率就会消耗一部分时间。特别是使用iOS6的自动布局机制尤为明显，它应该是比老版的自动调整逻辑加强了CPU的工作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;视图惰性加载 - iOS只会当视图控制器的视图显示到屏幕上时才会加载它。这对内存使用和程序启动时间很有好处，但是当呈现到屏幕上之前，按下按钮导致的许多工作都会不能被及时响应。比如控制器从数据库中获取数据，或者视图从一个nib文件中加载，或者涉及IO的图片显示（见后续“IO相关操作”），都会比CPU正常操作慢得多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Core Graphics绘制 - 如果对视图实现了-drawRect:方法，或者CALayerDelegate的-drawLayer:inContext:方法，那么在绘制任何东西之前都会产生一个巨大的性能开销。为了支持对图层内容的任意绘制，Core Animation必须创建一个内存中等大小的寄宿图片。然后一旦绘制结束之后，必须把图片数据通过IPC传到渲染服务器。在此基础上，Core Graphics绘制就会变得十分缓慢，所以在一个对性能十分挑剔的场景下这样做十分不好。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解压图片 - PNG或者JPEG压缩之后的图片文件会比同质量的位图小得多。但是在图片绘制到屏幕上之前，必须把它扩展成完整的未解压的尺寸（通常等同于图片宽 x 长 x 4个字节）。为了节省内存，iOS通常直到真正绘制的时候才去解码图片（14章“图片IO”会更详细讨论）。根据你加载图片的方式，第一次对图层内容赋值的时候（直接或者间接使用UIImageView）或者把它绘制到Core Graphics中，都需要对它解压，这样的话，对于一个较大的图片，都会占用一定的时间。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;性能优化实例&quot;&gt;性能优化实例&lt;/h3&gt;
&lt;p&gt;UITabelViewCell 使用了阴影和圆角等触发离屏渲染，影响性能。这是可以打开shouldRasterize， 这是光栅化，缓存阴影和圆角到位图，下次重绘时直接取用缓存。虽然光栅会也会触发离屏渲染，但是能够缓解cell的滑动不断渲染，也能一定程度上提高性能。&lt;/p&gt;

&lt;h2 id=&quot;13-高效绘图&quot;&gt;13. 高效绘图&lt;/h2&gt;

&lt;p&gt;软件绘图指不由GPU协助的绘图，iOS中一般通过Core Graphics完成，但是和Core Animation和 OpenGL相比，Core Graphics要慢不少。
软件绘图还会消耗不少内存，一个Context上下文相当于图层宽×高×4字节，分辨率为2048*1526的iPad来说，就是12MB内存，且每次重绘都需要抹掉内存重新分配，代价很大，所以要尽量避免绘图。&lt;/p&gt;

&lt;h3 id=&quot;使用cashapelayer-提高效率&quot;&gt;使用CAShapeLayer 提高效率&lt;/h3&gt;
&lt;p&gt;例如实现手指滑动绘制线条，简单做法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    //get the current point
    CGPoint point = [[touches anyObject] locationInView:self];

    //add a new line segment to our path
    [self.path addLineToPoint:point];

    //redraw the view
    [self setNeedsDisplay];
}

- (void)drawRect:(CGRect)rect
{
    //draw path
    [[UIColor clearColor] setFill];
    [[UIColor redColor] setStroke];
    [self.path stroke];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;使用了Core Graphics，画的越多，程序越慢，每次都会重绘整个路径，效率很低。
使用CAShapeLayer替代Core Graphics，性能大幅提高。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (Class)layerClass
{
    //this makes our view create a CAShapeLayer
    //instead of a CALayer for its backing layer
    return [CAShapeLayer class];
}
- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
    //get the current point
    CGPoint point = [[touches anyObject] locationInView:self];

    //add a new line segment to our path
    [self.path addLineToPoint:point];

    //update the layer with a copy of the path
    ((CAShapeLayer *)self.layer).path = self.path.CGPath;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;脏矩形&quot;&gt;脏矩形&lt;/h3&gt;
&lt;p&gt;为了减少不必要的绘制，MacOS和iOS设备将会把屏幕区分为需要重绘的区域和不需要重绘的区域。那些需要重绘的部分被称作『脏区域』。&lt;/p&gt;

&lt;p&gt;当一个视图被改动过了，TA可能需要重绘。但是很多情况下，只是这个视图的一部分被改变了，所以重绘整个寄宿图就太浪费了。所以提供了-setNeedsDisplayInRect:来把脏区域作为参数传入，能够提高部分效率。&lt;/p&gt;

&lt;p&gt;相比依赖于Core Graphics为你重绘，裁剪出自己的绘制区域可能会让你避免不必要的操作。那就是说，如果你的裁剪逻辑相当复杂，那还是让Core Graphics来代劳吧，记住：当你能高效完成的时候才这样做。&lt;/p&gt;

&lt;p&gt;CGRectIntersectsRect()能判断指定的rect在不在脏区域内，从而判断是否需要重新绘制这一块。&lt;/p&gt;

&lt;h3 id=&quot;异步绘制&quot;&gt;异步绘制&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CATiledLayer 分片显示的layer，在多线程中为每个小块同时调用drawLayer:inContext:方法，避免阻塞交互。&lt;/li&gt;
  &lt;li&gt;drawsAsynchronously 它自己的-drawLayer:inContext:方法只会在主线程调用，但是CGContext并不等待每个绘制命令的结束。相反地，它会将命令加入队列，当方法返回时，在后台线程逐个执行真正的绘制。==根据苹果的说法。这个特性在需要频繁重绘的视图上效果最好（比如我们的绘图应用，或者诸如UITableViewCell之类的），对那些只绘制一次或很少重绘的图层内容来说没什么太大的帮助。==&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;14图像io&quot;&gt;14.图像IO&lt;/h2&gt;
&lt;p&gt;图像耗费时间主要包括2个部分，加载到内存和解压。&lt;/p&gt;

&lt;h3 id=&quot;解决加载问题&quot;&gt;解决加载问题&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;文件读取&lt;/strong&gt;: 使用异步加载的方式，GCD或NSOperationQueue，在子线程中读取图片，在主线程中显示图片。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;延迟解压&lt;/strong&gt;: 当加载图片之后，iOS通常会延迟解压图片的时间。这就会在准备绘制图片的时候影响性能，因为需要在绘制之前进行解压（通常是消耗时间的问题所在）。&lt;/p&gt;

&lt;p&gt;使用+imageNamed:方法能避免延时加载，会在加载图片后立刻解压。但对于生成的图片，相册照片或下载的图片无效。
此时可以使用ImageIO框架实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSInteger index = indexPath.row;
NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]];
NSDictionary *options = @{(__bridge id)kCGImageSourceShouldCache: @YES}; 
CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);
CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);
UIImage *image = [UIImage imageWithCGImage:imageRef]; 
CGImageRelease(imageRef);
CFRelease(source);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就可以使用kCGImageSourceShouldCache来创建图片，强制图片立刻解压，然后在图片的生命周期保留解压后的版本。&lt;/p&gt;

&lt;h3 id=&quot;分辨率替换&quot;&gt;分辨率替换&lt;/h3&gt;
&lt;p&gt;在滑动的时候使用分辨率图片，滑动停止时替换为高分辨率图片。&lt;/p&gt;

&lt;h3 id=&quot;图片缓存&quot;&gt;图片缓存&lt;/h3&gt;
&lt;p&gt;imageNamed: 在内存中自动缓存了解压后的图片，但也有以下几个问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;[UIImage imageNamed:]方法仅仅适用于在应用程序资源束目录下的图片，但是大多数应用的许多图片都要从网络或者是用户的相机中获取，所以[UIImage imageNamed:]就没法用了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[UIImage imageNamed:]缓存用来存储应用界面的图片（按钮，背景等等）。如果对照片这种大图也用这种缓存，那么iOS系统就很可能会移除这些图片来节省内存。那么在切换页面时性能就会下降，因为这些图片都需要重新加载。对传送器的图片使用一个单独的缓存机制就可以把它和应用图片的生命周期解耦。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;[UIImage imageNamed:]缓存机制并不是公开的，所以你不能很好地控制它。例如，你没法做到检测图片是否在加载之前就做了缓存，不能够设置缓存大小，当图片没用的时候也不能把它从缓存中移除。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nscache&quot;&gt;NSCache&lt;/h3&gt;
&lt;p&gt;NSCache和NSDictionary类似，你可以通过-setObject:forKey:和-object:forKey:方法分别来插入，检索。和字典不同的是，NSCache在系统低内存的时候自动丢弃存储的对象。
-setCountLimit: 设置缓存大小
-setObject:forKey:cost:来对每个存储的对象指定消耗的值来提供一些参考，数值越大说明很昂贵，降低丢弃的优先级。
-setTotalCostLimit: 指定全体缓存的大小&lt;/p&gt;

&lt;h3 id=&quot;png和jpeg区别&quot;&gt;PNG和JPEG区别&lt;/h3&gt;
&lt;p&gt;JPEG不包含透明度通道，压缩算法复杂，文件小，解压时会耗费时间多
PNG包含透明度通道，算法简单，文件大，解压时耗费时间少&lt;/p&gt;

&lt;p&gt;JPEG适合噪点大的图片， PNG适合扁平颜色，锋利的线条和渐变色图片。&lt;/p&gt;

&lt;h2 id=&quot;15图层性能&quot;&gt;15.图层性能&lt;/h2&gt;

&lt;h3 id=&quot;光栅化&quot;&gt;光栅化&lt;/h3&gt;

&lt;p&gt;在第四章『视觉效果』中我们提到了&lt;code class=&quot;highlighter-rouge&quot;&gt;CALayer&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldRasterize&lt;/code&gt;属性，它可以解决重叠透明图层的混合失灵问题。同样在第12章『速度的曲调』中，它也是作为绘制复杂图层树结构的优化方法。&lt;/p&gt;

&lt;p&gt;启用&lt;code class=&quot;highlighter-rouge&quot;&gt;shouldRasterize&lt;/code&gt;属性会将图层绘制到一个屏幕之外的图像。然后这个图像将会被缓存起来并绘制到实际图层的&lt;code class=&quot;highlighter-rouge&quot;&gt;contents&lt;/code&gt;和子图层。如果有很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧划得来得多。但是光栅化原始图像需要时间，而且还会消耗额外的内存。&lt;/p&gt;

&lt;p&gt;当我们使用得当时，光栅化可以提供很大的性能优势（如你在第12章所见），但是一定要避免作用在内容不断变动的图层上，否则它缓存方面的好处就会消失，而且会让性能变的更糟。&lt;/p&gt;

&lt;p&gt;为了检测你是否正确地使用了光栅化方式，用Instrument查看一下Color Hits Green和Misses Red项目，是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。&lt;/p&gt;

&lt;h3 id=&quot;混合和过度绘制&quot;&gt;混合和过度绘制&lt;/h3&gt;

&lt;p&gt;GPU每一帧可以绘制的像素有最大显示fill rate, 所以必须有选择的绘制区域。GPU会放弃绘制哪些被其他图层遮挡的像素，但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源。同样，合并不同图层的透明重叠像素(混合)消耗的资源也是相当可观的。所以为了加速处理进程，非必要时刻不要用透明图层。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;给视图&lt;code class=&quot;highlighter-rouge&quot;&gt;backgroundColor&lt;/code&gt; 设置一个固定的不透明颜色。&lt;/li&gt;
  &lt;li&gt;设置&lt;code class=&quot;highlighter-rouge&quot;&gt;opaque&lt;/code&gt;属性为YES&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样做减少了混合行为（因为编译器知道在图层之后的东西都不会对最终的像素颜色产生影响），且计算得到了加速。&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/CoreAnimation/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/CoreAnimation/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>深入理解HTTPS</title>
        <description>&lt;h2 id=&quot;what&quot;&gt;What&lt;/h2&gt;
&lt;p&gt;HTTPS在传统的HTTP和TCP之间加了一层用于&lt;code class=&quot;highlighter-rouge&quot;&gt;加密解密的SSL/TLS层&lt;/code&gt;（安全套接层Secure Sockets Layer/安全传输层Transport Layer Security）层。使用HTTPS必须要有一套自己的数字证书（包含公钥和私钥）。&lt;/p&gt;

&lt;h2 id=&quot;why&quot;&gt;Why&lt;/h2&gt;
&lt;h3 id=&quot;http的问题&quot;&gt;HTTP的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不加密，通信是明文，可能被窃听&lt;/li&gt;
  &lt;li&gt;无法证明报文的完整性，可能被篡改&lt;/li&gt;
  &lt;li&gt;没验证通信方的身份，可能遭遇中间人伪装&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;https解决的问题&quot;&gt;HTTPS解决的问题&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;信息加密传输：第三方无法窃听；&lt;/li&gt;
  &lt;li&gt;校验机制：一旦被篡改，通信双方会立刻发现；&lt;/li&gt;
  &lt;li&gt;身份证书：防止身份被冒充。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;how&quot;&gt;How&lt;/h2&gt;
&lt;h3 id=&quot;如何加密&quot;&gt;如何加密&lt;/h3&gt;
&lt;h4 id=&quot;对称加密&quot;&gt;对称加密&lt;/h4&gt;
&lt;p&gt;加密和解密同用一个密钥。&lt;strong&gt;没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了&lt;/strong&gt;。对称加密有很多种算法，常用的有AES, DES。由于它效率很高，所以被广泛使用在很多加密协议的核心当中。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    encrypt(明文，秘钥) = 密文
    decrypt(密文，秘钥) = 明文
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;优点: 相对于非对称加密，加解密效率高得多，加密速度块。
缺点: 对于秘钥的管理和分发上比较困难，秘钥管理负担重。&lt;/p&gt;

&lt;h4 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h4&gt;
&lt;p&gt;指的是加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。&lt;strong&gt;私钥只能由一方安全保管，不能外泄，而公钥则可任意发布给需要的人&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    encrypt(明文，公钥) = 密文
    decrypt(密文，私钥) = 明文
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;优点: 安全性高，私钥自己保存，不需要传输。
缺点: 加解密消耗高，速度慢。&lt;/p&gt;

&lt;p&gt;HTTPS采用了对称加密+非对称加密的方案。具体做法如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633632456.png&quot; style=&quot;zoom:60%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;但是依然解决不了中间人的攻击，如下图：&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633723857.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因此需要保证数据完整性引入数字签名&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;如何保证数据完整性-数字签名&quot;&gt;如何保证数据完整性-数字签名&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改，那如何校验数据的完整性呢？—-校验数字签名。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;数字签名有两种功效：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。&lt;/li&gt;
  &lt;li&gt;数字签名能确定消息的完整性,证明数据是否未被篡改过。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;数字签名生如何成：&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633815147.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者。接下来就是接收者校验数字签名的流程了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;校验数字签名流程：&lt;/strong&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634134529.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用Hash函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上面可行的前提是需要事先拿到可信的公钥，因此引入数字证书&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;如何校验身份-数字证书&quot;&gt;如何校验身份-数字证书&lt;/h3&gt;
&lt;p&gt;数字证书就是Server将公钥和公司信息提交给证书颁发机构（Certificate Authority，简称CA），CA将公钥和其他信息数字签名后生成证书， Client也会内置所有受信CA的证书。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634229207.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此HTTPS的流程如下：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;客户端请求服务器获取&lt;code class=&quot;highlighter-rouge&quot;&gt;证书公钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端(SSL/TLS)解析证书，判断真实性&lt;/li&gt;
  &lt;li&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;公钥&lt;/code&gt;加密&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;客户端将&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;发送给服务器&lt;/li&gt;
  &lt;li&gt;服务端用&lt;code class=&quot;highlighter-rouge&quot;&gt;私钥&lt;/code&gt;解密得到&lt;code class=&quot;highlighter-rouge&quot;&gt;密钥&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;将信息和秘钥混合在一起&lt;/code&gt;进行对称加密&lt;/li&gt;
  &lt;li&gt;将加密的内容发送给客户端&lt;/li&gt;
  &lt;li&gt;客户端用&lt;code class=&quot;highlighter-rouge&quot;&gt;秘钥&lt;/code&gt;解密信息&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634413967.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;附：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTPS默认使用443端口，而HTTP默认使用80端口。&lt;/li&gt;
  &lt;li&gt;TLS就是从SSL发展而来的，只是SSL发展到3.0版本后改成了TLS&lt;/li&gt;
  &lt;li&gt;第一次请求中TLS握手的代价很大&lt;/li&gt;
  &lt;li&gt;后续的请求会共用第一次请求的协商结果&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 13 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/HTTPS%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/HTTPS%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B/</guid>
        
        
      </item>
    
      <item>
        <title>优秀程序员的九种素质</title>
        <description>&lt;h3 id=&quot;一&quot;&gt;一&lt;/h3&gt;

&lt;p&gt;上周看到一篇文章，大意是阿里云源代码泄露，涉及多少家企业云云，看起来耸人听闻，点进去发现是有企业在使用阿里云做代码托管的时候，private internal 和 public 傻傻分不清，创建仓库用了 internal，结果只要是登录用户都可以看到并 clone 这些代码。事实上，这三个设置不仅是惯例，internel 的注释也写的清清楚楚，但是挡不住程序员不看。你永远不知道一个人的水准会低到什么地步，也许这些人从来没用过 GitHub 和 GitLab 呢？&lt;/p&gt;

&lt;p&gt;阿里云其实可以采用安全最小化原则，也就是常说的多一事不如少一事。最小化可用原则，对于操作系统来说，就是装最小化的包，没用的服务不启动，操作命令最小化，权限最小化等等。对于阿里云上的托管用户来说，internal 应该是个可有可无的功能，去掉是不是更好呢，也许值得平台方思考。&lt;/p&gt;

&lt;p&gt;永远不要高估用户的聪明程度。&lt;/p&gt;

&lt;h3 id=&quot;二&quot;&gt;二&lt;/h3&gt;

&lt;p&gt;本周我们上线了一款基础课专栏《软件工程之美》，最新的文章中阐述了软件过程和软件危机：&lt;/p&gt;

&lt;p&gt;软件是怎么被创造出来的？&lt;/p&gt;

&lt;p&gt;首先，它们的诞生都是有人想要造一个东西。这其中的很多故事你都耳熟能详：张小龙创造微信、乔布斯创造 iOS、暴雪想做一款不一样的射击游戏……他们首先有着这样的意图，然后，他们立项做这样的产品。&lt;/p&gt;

&lt;p&gt;每一款软件项目背后，都有很多人在参与。你无法想象微信这样复杂的 App 靠张小龙自己可以开发出来；你也不会相信 iOS 是乔布斯一个人设计出来的；像守望先锋这种游戏的背后，有成百上千的游戏策划、美术设计、程序开发人员。&lt;/p&gt;

&lt;p&gt;从立项到第一个版本的发布，每个成功的软件都需要有计划、有步骤地进行，什么时候发布第一个版本、第一个版本有什么样的功能、什么时候发布第二个版本、第二个版本有哪些地方要改进，这些都是研发过程中需要考虑的问题。&lt;/p&gt;

&lt;p&gt;比如，守望先锋是在 2013 年立项，他们计划做一个基于职业的 MMO 游戏，他们先花了几个月的时间做了第一个 Demo 演示，只有四个英雄和一个张地图。&lt;/p&gt;

&lt;p&gt;然后，他们要在 2014 年的“暴雪嘉年华”发布这个游戏的试玩版，包含 12 个英雄和 4 张地图。&lt;/p&gt;

&lt;p&gt;最终这个游戏在 2016 年 5 月正式发布了。这样从立项一步步到最终发布，历时三年，中间经过了诸多环节。&lt;/p&gt;

&lt;p&gt;类似的例子还有微信，2010 年 11 月 20 日立项，2011 年 1 月 21 日第一版上线，当时的功能还非常简陋，只能发送文本消息和照片。之后才是一个个版本的迭代，直到你现在看到的微信。&lt;/p&gt;

&lt;p&gt;像这种有人参与、有计划、有步骤地造一件产品，我们通常称为「工程」。&lt;/p&gt;

&lt;p&gt;那什么是软件危机呢？有兴趣可以订阅专栏阅读。软件工程是你通向程序之巅的必经之路。&lt;/p&gt;

&lt;h3 id=&quot;三&quot;&gt;三&lt;/h3&gt;

&lt;p&gt;周末读村上的书，他说自己能够持续写作和跑步，就是因为具备两个特质，一个是集中力，一个是耐力。村上写长篇的时候每天早晨集中写作四小时，他一个人坐在书桌前，没有任何打扰，将意识集中倾斜在书稿中，其他什么都不考虑。另外，没有耐力也不行。你集中写了一星期然后伸伸懒腰说，我累了，然后就休息一个月，这样是写不成长篇的。你必须每天集中写作，坚持半年，一年，甚至更长才行。&lt;/p&gt;

&lt;p&gt;一个优秀的程序员需要什么特质呢？由此我想到之前读过的一篇文章，是 Redis 之父萨尔瓦托·桑菲利普（Salvatore Sanfilippo）写的 9 种高能程序员的特质，重新意译一下，推荐给读者：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、高效完成子任务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从处理编程子任务上，可以看出一个程序员的短板和长处，比如实现一个函数或者一个算法。事实上，擅于使用基本的编程技能来高效完成任务的程序员，并没有人们想象的那么多。有时候，团队里有些不称职的程序员，他们甚至不知道该怎么写一个简单的排序算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、合理使用自己的经验&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;桑菲利普认为，经验就是一系列解决方案，它们已经被证实可以用于处理一些重复性的任务。经验老道的程序员知道该如何处理各种子任务，这样不但省掉了很多设计工作，而且避免了很多设计错误，而设计错误是简洁性最大的敌人。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、准确预测工期&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;花在编码上的时间不仅要看数量，也要看质量。造成注意力不集中的因素既有内部的，也有外部的。集中注意力和避免被打扰，对于提高编程效率来说是至关重要的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、设计权衡：用 5% 换取 90%&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;项目的「非根本性」目标在很大程度上导致了设计的复杂性，或者导致无法达成其他更重要的目标，因为根本性功能和非根本性功能在设计上存在竞争关系。如果意识不到这点，复杂性就会随之而来。对于设计者来说，如果项目要最大化产出，就要把精力集中在重要的事情上，并在合理的时间内完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、简洁性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简洁性是成败之间最为明显的分界点，理解复杂性的产生过程有助于理解什么是简洁性。不愿意做出设计权衡和设计错误的累积是导致复杂性的两个主要因素。我在第一点里讲的 Internal 其实是提高了复杂度导致用户选择错误。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、拒绝完美主义（为了偏袒设计而放弃生产力）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;完美主义可以分为两种：一种是追求程序极致性能的工程文化，另一种是个人特质。不管是哪一种完美主义，它们都会对程序员实现快速交付造成阻碍。完美主义和对外部评判的恐惧会导致设计上的偏袒，程序员根据主观的心理因素和无关紧要的衡量参数做出设计决策，却忽略了健壮性、简洁性和及时交付。&lt;/p&gt;

&lt;p&gt;我曾经服务过的一家公司就犯了这种错误。当然，错误不止于此。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、理解知识理论的价值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在处理复杂任务时，具备一些理论方面的知识会对设计产生重要影响，比如数据结构方面的知识、了解计算能力的局限性和一些重要的算法。虽然程序员没有必要成为无所不知的超级专家，但是至少要知道一些问题的潜在解决方案，避免设计出复杂、缓慢、低内存效能的解决方案。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、理解机器原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;程序的很多问题都是源于对计算机工作原理的误解，即使是使用高级语言开发的程序也不外乎如此。这种情况可能导致一个项目需要重新设计和实现，因为项目所使用的工具和算法出现了根本性的错误。&lt;/p&gt;

&lt;p&gt;7 和 8 说的道理差不多，这也是极客时间会连续推出数学、算法、数据结构、网络协议、软件工程等课程的原因，后面还有架构设计、操作系统、编译原理等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9、调试技能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;查找和解决 bug 经常会占用程序员大量的时间。查找引起 bug 的问题根源，在合理的步骤内修复 bug，以简单的方式编写包含较少 bug 的代码，对于程序员来说，做到这几点就可以显著提升效率。&lt;/p&gt;

&lt;p&gt;能否运用调试技能快速解决问题是衡量一个程序员水平的重要标准。&lt;/p&gt;

&lt;p&gt;你具备这些特质嘛？我觉得村上说的没错，程序员同时还需要集中力和耐力。&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/%E4%BC%98%E7%A7%80%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%B9%9D%E7%A7%8D%E7%B4%A0%E8%B4%A8/</guid>
        
        <category>闲谈</category>
        
        
      </item>
    
      <item>
        <title>WebRTC架构及原理</title>
        <description>&lt;h2 id=&quot;架构&quot;&gt;架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002625734050.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;主体包含3个模块，音频引擎，视频引擎，传输层。最核心的在于传输层。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;音频引擎包含回声消除，降噪音频编解码等。音频采集和渲染层 可override自己实现&lt;/li&gt;
  &lt;li&gt;视频引擎包含VP8，VP9，H264编解码，图形增强的算法。视频采集层 可override自己实现，不包含图像渲染层&lt;/li&gt;
  &lt;li&gt;传输层包含P2P,STUN,TURN,ICE，RTP,RTSP等传输控制协议。网络IO层可override 自己实现&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;信令服务器&quot;&gt;信令服务器&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002625864892.png&quot; style=&quot;zoom:80%&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;nat穿越&quot;&gt;NAT穿越：&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;设备大多在网关背后，想要简历P2P连接就要穿过网关，连接到内网的设备，网关一般包含以下4种防火墙类型。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;完全锥形：网关只做简单的映射，最容易穿越&lt;/li&gt;
  &lt;li&gt;地址限制锥形：对于主动访问外网的IP做记录，容易穿越&lt;/li&gt;
  &lt;li&gt;端口限制锥形：对主动访问外网的IP和Port做记录，比上一个更严格&lt;/li&gt;
  &lt;li&gt;对称型：内网与外网通信会建立一个IP和Port,不同的外网地址建立不同的IP和port,基本无法穿越。&lt;strong&gt;是否可用中继服务器的方式打洞&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;穿越原理&quot;&gt;穿越原理&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;C1, C2向STUN发消息&lt;/li&gt;
  &lt;li&gt;交换公网IP和Port&lt;/li&gt;
  &lt;li&gt;C1-&amp;gt;C2, C2-&amp;gt;C1。如果是对称型需要端口猜测&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;stun&quot;&gt;STUN:&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;目的就是获取设备的公网IP和Port然后互相交换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;turn&quot;&gt;TURN:&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;目的是解决对称NAT无法穿越的问题，用来转发数据。
获取到双方地址后尝试P2P链接，如果链接失败，则使用数据转发&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;ice&quot;&gt;ICE:&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;包含了STUN, TURN的一整个解决方案框架，不断选择最优的链接通路，获取不同的candidate，尝试最优的链路。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;收集Candidata&lt;/li&gt;
  &lt;li&gt;对Candidate Pair排序，筛选出最合适的候选者对，否则直接检查浪费时间
    &lt;ul&gt;
      &lt;li&gt;一方收集到所有候选者后，通过信令传给对方&lt;/li&gt;
      &lt;li&gt;另一方收到候选者后也做收集工作&lt;/li&gt;
      &lt;li&gt;当双方拿到全部列表后，将候选者形成匹配对儿&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对Candidate Pair连通性检查
    &lt;ul&gt;
      &lt;li&gt;对每个后选对进行发送，接收检查&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002626005389.png&quot; style=&quot;zoom:80%&quot; /&gt;
***&lt;/p&gt;

&lt;h4 id=&quot;candidata&quot;&gt;Candidata&lt;/h4&gt;
&lt;p&gt;是一个地址，例如： …UDP…192.168.1.2  1816 type host等协议，地址，类型
类型包含3个：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;主机候选者， 本机网卡上所有地址和类型&lt;/li&gt;
  &lt;li&gt;反射候选者，NAT穿越后的地址和类型， SUTN/TURN&lt;/li&gt;
  &lt;li&gt;中继候选者， TURN服务开通后的地址和类型， TURN&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;sdp&quot;&gt;SDP&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;Session Description Protocol ， 是设备之间互通配置信息的协议&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002626096788.png&quot; alt=&quot;&quot; /&gt;
上图中是SDP基本内容， 其中有2个candidate, 一个是本机UDP,另一个是NAT穿越后的地址UDP&lt;/p&gt;

&lt;p&gt;SDP规范包括2部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;会话层： 会话时间，名称等全局基本信息，多个媒体信息&lt;/li&gt;
  &lt;li&gt;媒体层
    &lt;ul&gt;
      &lt;li&gt;媒体格式:音频、视频、数据&lt;/li&gt;
      &lt;li&gt;传输协议：TCP/UDP&lt;/li&gt;
      &lt;li&gt;传输IP和Port&lt;/li&gt;
      &lt;li&gt;媒体负载类型:VP8 VP9 h264. h265&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;m 媒体名称和地址, c 传输层信息, b 带宽信息 ,a 各种属性定义和对m的描述&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;WebRTC中的SDP包含5个部分：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;会话元&lt;/li&gt;
  &lt;li&gt;网络描述&lt;/li&gt;
  &lt;li&gt;流描述&lt;/li&gt;
  &lt;li&gt;安全描述&lt;/li&gt;
  &lt;li&gt;服务质量&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;连接流程图&quot;&gt;连接流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002626241435.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 11 Aug 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/08/WebRTC%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/08/WebRTC%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%8E%9F%E7%90%86/</guid>
        
        <category>WebRTC</category>
        
        
      </item>
    
      <item>
        <title>SIG蓝牙协议5.2版本更新内容</title>
        <description>&lt;h4 id=&quot;主要是3块新特性&quot;&gt;主要是3块新特性&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Enhanced Attribute Protocol&lt;/li&gt;
  &lt;li&gt;LE Power Control&lt;/li&gt;
  &lt;li&gt;LE Isochronous Channels&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUD: Protocol Data Unit 协议数据单元 被某一层处理为指定数据格式的数据。

SDU: Service Data Unit 服务数据单元 在某一层中还未处理的数据，比如输入的数据，叫SDU,封装成PDU通过层与层之间的管道传输给下一层。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;本层的PDU是下一层的SDU,本层的SDU是上一层的PDU&lt;/p&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;一enhanced-att&quot;&gt;一、Enhanced ATT&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632642584.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ATT: 定义了不同服务的属性参数和可使用的命令，用来作为主从设备间的信息交换个协商。&lt;/p&gt;

&lt;p&gt;MTU(Maximum Transmission Unit) 是不同协议的最大数据处理能力，决定不同层协议处理最大PUD/SDU的尺寸。ATT中定义了服务的MTU,在L2CAP根据上下层不同的MTU来分割/组合数据，来适配整体数据通路的PDU/SDU。&lt;/p&gt;

&lt;p&gt;LE5.1之前：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ATT与L2CAP之间的MTU是固定的，建立连接后不能改。&lt;/li&gt;
  &lt;li&gt;数据处理是串行的，不同业务MTU必须在上一个PDU/SDU完成后才能执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LE5.2:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;MTU在ATT和L2CAP之间不再一一对应，可以互相独立配置，即ATT和L2CAP之间的MTU和PDU大小动态配置。&lt;/li&gt;
  &lt;li&gt;不同业务PDU可以交叉处理，减小数据延迟&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EATT相比ATT的影响：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;新的PDU只能再EATT上使用&lt;/li&gt;
  &lt;li&gt;某些ATT PDU只能用在ATT上&lt;/li&gt;
  &lt;li&gt;一些PDU的定义或流程被细化或优化&lt;/li&gt;
  &lt;li&gt;EATT只能加密连接使用，ATT可以通过未加密、加密连接&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;二le-power-control&quot;&gt;二、LE Power Control&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;在蓝牙接收错误率BER超过0.1%时，连接被认为是质量不好连接 增加了发射功率的动态管理，通过信号响度RSSI的监控，通知发射方增加或减少发射功率。使接收器的信号强度落在不太强也不太弱的区域，刚好满足应用又省电。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h4 id=&quot;三le-isochronous-channels&quot;&gt;三、LE Isochronous Channels&lt;/h4&gt;
&lt;p&gt;定义了一个有时间依赖的数据传输通道和传输策略。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;增加对于一对多接收方同步获取数据的机制&lt;/li&gt;
  &lt;li&gt;允许发送方在指定时间外丢弃数据，保证接收方数据满足时效要求&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该通道支持链接模式和广播模式.
俩种模式下 ISO异同点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;每个BIG CIG最多包含31个BIS CIS&lt;/li&gt;
  &lt;li&gt;CIS中从设备对主设备有信息反馈，BIS没有&lt;/li&gt;
  &lt;li&gt;BIS重传是通过接收方信息反馈决定， CIS是强制的&lt;/li&gt;
  &lt;li&gt;CIG中CIS同步通过CIG的时间以及CIS时间参数实现，BIG中的BIS通过周期广播的PDU实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;能实现多重串流音频（Multi-Stream Audio）和音频分享（Audio Sharing）&lt;/p&gt;

&lt;h5 id=&quot;链接模式&quot;&gt;链接模式&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;称作CIS (LE Connected Isochronous Stream)逻辑传输通道，可将延迟数据丢弃。 不同的CIS组成CIG ( Connected Isochronous Groups ),同一个CIG内的CIS有相同的时间戳，保证同一个group内数据同步。例如一对TWS耳机
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632747277.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;广播模式&quot;&gt;广播模式&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;称作BIS (Broadcast Isochronous Stream)。 多个BIS 可组成BIG (Broadcast Isochronous Groups).通过一个周期广播的PUD实现。 该PDU包含针对每个BIS的时间戳，一旦同步，广播接收者变成同步接收者。例如，广场舞大妈蓝牙耳机听同一音源歌曲。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002633057507.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Fri, 05 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/SIG%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE5.2%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/SIG%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE5.2%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E5%86%85%E5%AE%B9/</guid>
        
        <category>BLE</category>
        
        
      </item>
    
      <item>
        <title>蓝牙协议栈</title>
        <description>&lt;h3 id=&quot;协议栈内容&quot;&gt;协议栈内容&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632222709.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;phy层&quot;&gt;PHY层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Physical layer 用来指定BLE所用的无线频段，调试解调方式和方法等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;ll层&quot;&gt;LL层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;link layer 是协议栈的核心，选择使用哪个射频通道进行通信，怎么识别inflight数据包，在哪个时间点发送数据包，哪个时间点接收数据包，怎么保证数据完整性，ACK接收，如何重传，链路管理控制等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;hci层&quot;&gt;HCI层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host controller interface  HCI是可选的，主要用于2颗芯片实现BLE协议栈的场合，规范两者之间的通信协议和通信命令等
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;gap层&quot;&gt;GAP层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Generic access profile 对LL层payload 如何进行解析的一种方式，最简单。GAP对payload进行一些规范和定义，因此功能有限，主要用来广播，扫描和发起连接等。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;l2cap层&quot;&gt;L2CAP层&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Logic link control and adaption protocol 对LL进行简单封装，LL只关心传输的数据本身，L2CAP区分是加密通道还是普通通道，同时对连接间隔进行管理
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;smp&quot;&gt;SMP&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Security manager protocol 管理BLE连接的加密和安全
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;att&quot;&gt;ATT&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Attribute protocol ATT层用来定义用户命令以及命令操作的数据，比如读、写、通知等。Attribute定义数据和数据可以使用的命令。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;gatt&quot;&gt;GATT&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Generic attribute profile 用来规范attribute 中的数据内容，运用group来对attribute进行分类管理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;设备连接&quot;&gt;设备连接&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;连接指设备A和B 一对一‘同步’成功 连接成功包含以下几点： - 设备A和B对接下来要使用的物理信道达成一致 - 设备A和B双方建立一个共同的时间锚点，把时间原点变成同一个点 - 设备A和B时钟同步成功，明确双方什么时候发数据，什么时候接收数据
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002632477431.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图表示连接成功后，A将以CI为周期向B发送数据包，B将以CI (connection interval)为周期打开射频接收窗口来接收A的数据包。在B接收A数据包后150us后，切换为发送状态，把数据发送给A，A切换为接收状态接收B的数据。&lt;/p&gt;

&lt;p&gt;以发送0x53为例，看看不同协议层做了些什么&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对开发者来说，很简单，他只需要调用send(0x53)&lt;/li&gt;
  &lt;li&gt;GATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样- GATT层把数据打包成130053（小端模式！）&lt;/li&gt;
  &lt;li&gt;ATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053&lt;/li&gt;
  &lt;li&gt;L2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053&lt;/li&gt;
  &lt;li&gt;LL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：
    &lt;ul&gt;
      &lt;li&gt;AAAB5D65501E08040004001B130053D550F6&lt;/li&gt;
      &lt;li&gt;AA – 前导帧(preamble)&lt;/li&gt;
      &lt;li&gt;0x50655DAB – 访问地址(access address)&lt;/li&gt;
      &lt;li&gt;1E – LL帧头字段(LL header)&lt;/li&gt;
      &lt;li&gt;08 – 有效数据包长度(payload length)&lt;/li&gt;
      &lt;li&gt;04000400 – ATT数据长度，以及L2CAP通道编号&lt;/li&gt;
      &lt;li&gt;1B – notify command&lt;/li&gt;
      &lt;li&gt;0x0013 – 电量数据handle&lt;/li&gt;
      &lt;li&gt;0x53 – 真正要发送的电量数据&lt;/li&gt;
      &lt;li&gt;0xF650D5 – CRC24值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Jun 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/06/%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/06/%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88/</guid>
        
        <category>BLE</category>
        
        
      </item>
    
      <item>
        <title>在腾讯云上搭建jekyll静态博客</title>
        <description>&lt;p&gt;本文旨在帮助小伙伴在腾讯云或阿里云上搭建jekyll环境，有错误还请指正。
对于一个全新服务器，需要从新开始配置相关依赖环境。&lt;/p&gt;

&lt;h3 id=&quot;安装-nodejs-环境&quot;&gt;安装 Nodejs 环境&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wget https://nodejs.org/dist/v8.12.0/node-v8.12.0-linux-x64.tar.xz
$ xz -d node-v8.12.0-linux-x64.tar.xz
$ tar -xf node-v8.12.0-linux-x64.tar 
$ ln -s ~/node-v8.12.0-linux-x64/bin/node /usr/bin/node
$ ln -s ~/node-v8.12.0-linux-x64/bin/npm /usr/bin/npm
$ node -v 
$ npm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中nodejs下载地址可以在 &lt;a href=&quot;https://nodejs.org/zh-cn/download/&quot;&gt;这里&lt;/a&gt; 根据系统选择。&lt;/p&gt;

&lt;h3 id=&quot;安装ruby环境&quot;&gt;安装ruby环境&lt;/h3&gt;
&lt;p&gt;这里有3种常用安装方式，个人推荐第一种。&lt;/p&gt;
&lt;h4 id=&quot;1-通过rvm安装ruby&quot;&gt;1. 通过RVM安装ruby&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;安装GPG 秘钥
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gpg2 --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3 7D2BAF1CF37B13E2069D6956105BD0E739499BDB
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;安装稳定版RVM
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ \curl -sSL https://get.rvm.io | bash -s stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;安装完毕后执行查看rvm版本是否安装成功
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm -v 
rvm 1.29.10 (latest) by Michal Papis, Piotr Kuczynski, Wayne E. Seguin [https://rvm.io]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;查看rvm当前可选ruby版本
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm list known
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20200916/16002634646313.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;选择一个想要的版本,例如2.7
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rvm install 2.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;如果下载很慢，可切换rvm 的安装源
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ echo &quot;ruby_url=https://cache.ruby-china.com/pub/ruby&quot; &amp;gt; ~/.rvm/user/db
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;安装完成，查看ruby版本
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ruby -v
ruby 2.0.0p648 (2015-12-16) [x86_64-linux]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2通过ruby源码安装&quot;&gt;2.通过ruby源码安装&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;下载源码，解压编译安装, 下载地址在&lt;a href=&quot;https://www.ruby-lang.org/zh_cn/downloads/&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ wget https://cache.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz
$ mkdir  -p /usr/local/ruby
$ tar -zxvf ruby-2.4.4.tar.gz 
$ cd ruby-2.4.4
$ ./configure --prefix=/usr/local/ruby
$ make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;环境变量配置&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ PATH=/usr/local/ruby/bin:$PATH:$HOME/bin
$ export PATH
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3通过yum安装&quot;&gt;3.通过yum安装&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$  sudo yum install ruby
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;安装gcc&quot;&gt;安装gcc&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum -y update gcc
$ yum -y install gcc+ gcc-c++
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;安装jekyll&quot;&gt;安装jekyll&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gem update --system
$ gem install jekyll
$ jekyll --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 21 May 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/05/%E5%9C%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAjekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/05/%E5%9C%A8%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B8%8A%E6%90%AD%E5%BB%BAjekyll%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</guid>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(四)</title>
        <description>&lt;h2 id=&quot;四framework层绘制&quot;&gt;四、Framework层绘制&lt;/h2&gt;
&lt;p&gt;在引擎层的处理过程会调用到window.onBeginFrame()和onDrawFrame，回到framework层从这个两个方法开始说起。&lt;/p&gt;

&lt;h3 id=&quot;41-schedulerbindinginitinstances&quot;&gt;4.1 SchedulerBinding.initInstances&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin SchedulerBinding on BindingBase, ServicesBinding {
  @override
  void initInstances() {
    super.initInstances();
    _instance = this;
    ui.window.onBeginFrame = _handleBeginFrame; //[见小节4.2]
    ui.window.onDrawFrame = _handleDrawFrame;  //[见小节4.4]
    SystemChannels.lifecycle.setMessageHandler(_handleLifecycleMessage);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可见，引擎层中的Window::BeginFrame()调用的两个方法，进入到dart层则分别是_handleBeginFrame()和_handleDrawFrame()方法&lt;/p&gt;

&lt;h4 id=&quot;411-window初始化&quot;&gt;4.1.1 Window初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Window {
    Window._()

    FrameCallback get onBeginFrame =&amp;gt; _onBeginFrame;
    FrameCallback _onBeginFrame;

    VoidCallback get onDrawFrame =&amp;gt; _onDrawFrame;
    VoidCallback _onDrawFrame;
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Window初始化过程，可以知道onBeginFrame和onDrawFrame分别保存_onBeginFrame和_onDrawFrame方法。&lt;/p&gt;

&lt;h3 id=&quot;42-_handlebeginframe&quot;&gt;4.2 _handleBeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _handleBeginFrame(Duration rawTimeStamp) {
  if (_warmUpFrame) {
    _ignoreNextEngineDrawFrame = true;
    return;
  }
  handleBeginFrame(rawTimeStamp);  //[见小节4.3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;43-handlebeginframe&quot;&gt;4.3 handleBeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void handleBeginFrame(Duration rawTimeStamp) {
  Timeline.startSync('Frame', arguments: timelineWhitelistArguments);
  _firstRawTimeStampInEpoch ??= rawTimeStamp;
  _currentFrameTimeStamp = _adjustForEpoch(rawTimeStamp ?? _lastRawTimeStamp);
  if (rawTimeStamp != null)
    _lastRawTimeStamp = rawTimeStamp;

  profile(() {
    _profileFrameNumber += 1;
    _profileFrameStopwatch.reset();
    _profileFrameStopwatch.start();
  });

  //此时阶段等于SchedulerPhase.idle;
  _hasScheduledFrame = false;
  try {
    Timeline.startSync('Animate', arguments: timelineWhitelistArguments);
    _schedulerPhase = SchedulerPhase.transientCallbacks;
    //执行动画的回调方法
    final Map&amp;lt;int, _FrameCallbackEntry&amp;gt; callbacks = _transientCallbacks;
    _transientCallbacks = &amp;lt;int, _FrameCallbackEntry&amp;gt;{};
    callbacks.forEach((int id, _FrameCallbackEntry callbackEntry) {
      if (!_removedIds.contains(id))
        _invokeFrameCallback(callbackEntry.callback, _currentFrameTimeStamp, callbackEntry.debugStack);
    });
    _removedIds.clear();
  } finally {
    _schedulerPhase = SchedulerPhase.midFrameMicrotasks;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要功能是遍历_transientCallbacks，执行相应的Animate操作，可通过scheduleFrameCallback()/cancelFrameCallbackWithId()来完成添加和删除成员，再来简单看看这两个方法。&lt;/p&gt;

&lt;h4 id=&quot;431-scheduleframecallback&quot;&gt;4.3.1 scheduleFrameCallback&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int scheduleFrameCallback(FrameCallback callback, { bool rescheduling = false }) {
  scheduleFrame();  //触发帧绘制的调度
  _nextFrameCallbackId += 1;
  _transientCallbacks[_nextFrameCallbackId] = _FrameCallbackEntry(callback, rescheduling: rescheduling);
  return _nextFrameCallbackId;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;callback保存在_FrameCallbackEntry对象里面&lt;/p&gt;

&lt;h4 id=&quot;432-cancelframecallbackwithid&quot;&gt;4.3.2 cancelFrameCallbackWithId&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void cancelFrameCallbackWithId(int id) {
  assert(id &amp;gt; 0);
  _transientCallbacks.remove(id);
  _removedIds.add(id);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;44-_handledrawframe&quot;&gt;4.4 _handleDrawFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _handleDrawFrame() {
  if (_ignoreNextEngineDrawFrame) {
    _ignoreNextEngineDrawFrame = false;
    return;
  }
  handleDrawFrame();  //[见小节4.5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;45-handledrawframe&quot;&gt;4.5 handleDrawFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void handleDrawFrame() {
  assert(_schedulerPhase == SchedulerPhase.midFrameMicrotasks);
  Timeline.finishSync(); // 标识结束&quot;Animate&quot;阶段
  try {
    _schedulerPhase = SchedulerPhase.persistentCallbacks;
    //执行PERSISTENT FRAME回调
    for (FrameCallback callback in _persistentCallbacks)
      _invokeFrameCallback(callback, _currentFrameTimeStamp); //[见小节4.5.1]

    _schedulerPhase = SchedulerPhase.postFrameCallbacks;
    // 执行POST-FRAME回调
    final List&amp;lt;FrameCallback&amp;gt; localPostFrameCallbacks = List&amp;lt;FrameCallback&amp;gt;.from(_postFrameCallbacks);
    _postFrameCallbacks.clear();
    for (FrameCallback callback in localPostFrameCallbacks)
      _invokeFrameCallback(callback, _currentFrameTimeStamp);
  } finally {
    _schedulerPhase = SchedulerPhase.idle;
    Timeline.finishSync(); //标识结束”Frame“阶段
    profile(() {
      _profileFrameStopwatch.stop();
      _profileFramePostEvent();
    });
    _currentFrameTimeStamp = null;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要功能：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历_persistentCallbacks，执行相应的回调方法，可通过addPersistentFrameCallback()注册，一旦注册后不可移除，后续每一次frame回调都会执行；&lt;/li&gt;
  &lt;li&gt;遍历_postFrameCallbacks，执行相应的回调方法，可通过addPostFrameCallback()注册，handleDrawFrame()执行完成后会清空_postFrameCallbacks内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;451-_invokeframecallback&quot;&gt;4.5.1 _invokeFrameCallback&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart:: SchedulerBinding]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _invokeFrameCallback(FrameCallback callback, Duration timeStamp, [ StackTrace callbackStack ]) {
  try {
    callback(timeStamp);  //[见小节4.5.2]
  } catch (exception, exceptionStack) {
    FlutterError.reportError(FlutterErrorDetails(...));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这里的callback是_persistentCallbacks列表中的成员，再来看看其成员是如何添加进去的。&lt;/p&gt;

&lt;h4 id=&quot;452-widgetsbindinginitinstances&quot;&gt;4.5.2 WidgetsBinding.initInstances&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin WidgetsBinding on BindingBase, SchedulerBinding, GestureBinding, RendererBinding, SemanticsBinding {
  @override
  void initInstances() {
    super.initInstances();  //[见小节4.5.3]
    _instance = this;
    buildOwner.onBuildScheduled = _handleBuildScheduled;
    ui.window.onLocaleChanged = handleLocaleChanged;
    ui.window.onAccessibilityFeaturesChanged = handleAccessibilityFeaturesChanged;
    SystemChannels.navigation.setMethodCallHandler(_handleNavigationInvocation);
    SystemChannels.system.setMessageHandler(_handleSystemMessage);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在flutter app启动过程，也就是执行runApp过程会有WidgetsFlutterBinding初始化过程，WidgetsBinding的initInstances()，根据mixin的顺序，可知此处的super.initInstances() 便是RendererBinding类。&lt;/p&gt;

&lt;h4 id=&quot;453-rendererbindinginitinstances&quot;&gt;4.5.3 RendererBinding.initInstances&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin RendererBinding on BindingBase, ServicesBinding, SchedulerBinding, SemanticsBinding, HitTestable {

  void initInstances() {
    super.initInstances();
    _instance = this;
    _pipelineOwner = PipelineOwner(
      onNeedVisualUpdate: ensureVisualUpdate,
      onSemanticsOwnerCreated: _handleSemanticsOwnerCreated,
      onSemanticsOwnerDisposed: _handleSemanticsOwnerDisposed,
    );
    ui.window
      ..onMetricsChanged = handleMetricsChanged
      ..onTextScaleFactorChanged = handleTextScaleFactorChanged
      ..onSemanticsEnabledChanged = _handleSemanticsEnabledChanged
      ..onSemanticsAction = _handleSemanticsAction;
    initRenderView();
    _handleSemanticsEnabledChanged();
    addPersistentFrameCallback(_handlePersistentFrameCallback); //[见小节4.5.4]
  }

  void _handlePersistentFrameCallback(Duration timeStamp) {
    drawFrame();  //[见小节4.6]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;454-schedulerbindingaddpersistentframecallback&quot;&gt;4.5.4 SchedulerBinding.addPersistentFrameCallback&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/scheduler/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mixin SchedulerBinding on BindingBase, ServicesBinding {

  void addPersistentFrameCallback(FrameCallback callback) {
    _persistentCallbacks.add(callback);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;46-widgetsbindingdrawframe&quot;&gt;4.6 WidgetsBinding.drawFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void drawFrame() {
  try {
    if (renderViewElement != null)
      buildOwner.buildScope(renderViewElement);   //[见小节4.6.1]
    super.drawFrame();   //[见小节4.6.4]
    buildOwner.finalizeTree();  //[见小节4.12]
  } finally {
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;461-buildownerbuildscope&quot;&gt;4.6.1 BuildOwner.buildScope&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void buildScope(Element context, [VoidCallback callback]) {
  if (callback == null &amp;amp;&amp;amp; _dirtyElements.isEmpty)
    return;
  Timeline.startSync('Build', arguments: timelineWhitelistArguments);
  try {
    _scheduledFlushDirtyElements = true;
    if (callback != null) {
      _dirtyElementsNeedsResorting = false;
      callback();  //执行回调方法
    }
    _dirtyElements.sort(Element._sort); //排序
    _dirtyElementsNeedsResorting = false;
    int dirtyCount = _dirtyElements.length;
    int index = 0;
    while (index &amp;lt; dirtyCount) {
      try {
        //具体Element子类执行重建操作 [见小节4.6.2]
        _dirtyElements[index].rebuild();
      } catch (e, stack) {
      }
      index += 1;
      if (dirtyCount &amp;lt; _dirtyElements.length || _dirtyElementsNeedsResorting) {
        _dirtyElements.sort(Element._sort);
        _dirtyElementsNeedsResorting = false;
        dirtyCount = _dirtyElements.length;
        while (index &amp;gt; 0 &amp;amp;&amp;amp; _dirtyElements[index - 1].dirty) {
          index -= 1;
        }
      }
    }
  } finally {
    for (Element element in _dirtyElements) {
      element._inDirtyList = false;
    }
    _dirtyElements.clear();
    _scheduledFlushDirtyElements = false;
    _dirtyElementsNeedsResorting = null;
    Timeline.finishSync();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;462-elementrebuild&quot;&gt;4.6.2 Element.rebuild&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void rebuild() {
  if (!_active || !_dirty)
    return;
  performRebuild();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;performRebuild具体执行方法，取决于相应的Element子类，这里以ComponentElement为例&lt;/p&gt;

&lt;h4 id=&quot;463-componentelementperformrebuild&quot;&gt;4.6.3 ComponentElement.performRebuild&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void performRebuild() {
  Widget built;
  try {
    built = build();  //执行build方法
  } catch (e, stack) {
    built = ErrorWidget.builder(_debugReportException('building $this', e, stack));
  } finally {
    _dirty = false;
  }
  try {
    _child = updateChild(_child, built, slot); //更新子元素
  } catch (e, stack) {
    built = ErrorWidget.builder(_debugReportException('building $this', e, stack));
    _child = updateChild(null, built, slot);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;464-rendererbindingdrawframe&quot;&gt;4.6.4 RendererBinding.drawFrame&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/binding.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void drawFrame() {
  pipelineOwner.flushLayout();  //[见小节4.7]
  pipelineOwner.flushCompositingBits();  //[见小节4.8]
  pipelineOwner.flushPaint(); //[见小节4.9]
  renderView.compositeFrame();  //[见小节4.10]
  pipelineOwner.flushSemantics(); //[见小节4.11]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;RendererBinding的initInstances()过程注册了一个Persistent的帧回调方法_handlePersistentFrameCallback()，故handleDrawFrame()过程会调用该方法。pipelineOwner管理渲染管道，提供了一个用于驱动渲染管道的接口，并存储了哪些渲染对象请求访问状态，要刷新管道，需要按顺序运行如下5个阶段：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;[flushLayout]：更新需要计算其布局的渲染对象，在此阶段计算每个渲染对象的大小和位置，渲染对象可能会弄脏其绘画或者合成状态，这个过程可能还会调用到build过程。
耗时对应timeline的‘Layout’过程&lt;/li&gt;
  &lt;li&gt;[flushCompositingBits]：更新具有脏合成位的任何渲染对象，在此阶段每个渲染对象都会了解其子项是否需要合成。在绘制阶段使用此信息选择如何实现裁剪等视觉效果。如果渲染对象有一个自己合成的子项，它需要使用布局信息来创建裁剪，以便将裁剪应用于已合成的子项
耗时对应timeline的‘Compositing bits’过程&lt;/li&gt;
  &lt;li&gt;[flushPaint]：访问需要绘制的任何渲染对象，在此阶段，渲染对象有机会将绘制命令记录到[PictureLayer]，并构建其他合成的[Layer]；
    &lt;ul&gt;
      &lt;li&gt;耗时对应timeline的‘Paint’过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[compositeFrame]：将Compositing bits发送给GPU；
    &lt;ul&gt;
      &lt;li&gt;耗时对应timeline的‘Compositing’过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;[flushSemantics]：编译渲染对象的语义，并将语义发送给操作系统；
    &lt;ul&gt;
      &lt;li&gt;耗时对应timeline的‘Semantics’过程&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;packages/flutter/lib/src/rendering/debug.dart，这里面记录着关于render过程相关的调试开关，可以逐一实践。&lt;/p&gt;

&lt;h3 id=&quot;47-pipelineownerflushlayout&quot;&gt;4.7 PipelineOwner.flushLayout&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushLayout() {
  profile(() {
    Timeline.startSync('Layout', arguments: timelineWhitelistArguments);
  });
  try {
    //遍历所有的渲染对象
    while (_nodesNeedingLayout.isNotEmpty) {
      final List&amp;lt;RenderObject&amp;gt; dirtyNodes = _nodesNeedingLayout;
      _nodesNeedingLayout = &amp;lt;RenderObject&amp;gt;[];
      for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&amp;gt; a.depth - b.depth)) {
        //如果渲染对象需要重新布局，则执行布局操作 [见小节4.7.1]
        if (node._needsLayout &amp;amp;&amp;amp; node.owner == this)
          node._layoutWithoutResize();
      }
    }
  } finally {
    profile(() {
      Timeline.finishSync();
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;471-_layoutwithoutresize&quot;&gt;4.7.1 _layoutWithoutResize&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _layoutWithoutResize() {
  try {
    performLayout();  //执行布局操作[]
    markNeedsSemanticsUpdate();  //[见小节4.7.2]
  } catch (e, stack) {
    _debugReportException('performLayout', e, stack);
  }
  _needsLayout = false; //完成layout操作
  markNeedsPaint(); // [见小节4.7.3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;performLayout操作：参数sizedByParent为false需要同时改变渲染对象和指导子项的布局，性能更慢；&lt;/li&gt;
  &lt;li&gt;markNeedsSemanticsUpdate：标记需要更新语义；&lt;/li&gt;
  &lt;li&gt;markNeedsPaint：标记需要绘制；&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SchedulerBinding.scheduleWarmUpFrame
  RenderView.performLayout
    RenderObject.layout
      _RenderLayoutBuilder.performLayout
        _LayoutBuilderElement._layout
          BuildOwner.buildScope
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;472-markneedssemanticsupdate&quot;&gt;4.7.2 markNeedsSemanticsUpdate&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void markNeedsSemanticsUpdate() {
  if (!attached || owner._semanticsOwner == null) {
    _cachedSemanticsConfiguration = null;
    return;
  }

  final bool wasSemanticsBoundary = _semantics != null &amp;amp;&amp;amp; _cachedSemanticsConfiguration?.isSemanticBoundary == true;
  _cachedSemanticsConfiguration = null;
  bool isEffectiveSemanticsBoundary = _semanticsConfiguration.isSemanticBoundary &amp;amp;&amp;amp; wasSemanticsBoundary;
  RenderObject node = this;

  while (!isEffectiveSemanticsBoundary &amp;amp;&amp;amp; node.parent is RenderObject) {
    if (node != this &amp;amp;&amp;amp; node._needsSemanticsUpdate)
      break;
    node._needsSemanticsUpdate = true;

    node = node.parent;
    isEffectiveSemanticsBoundary = node._semanticsConfiguration.isSemanticBoundary;
    if (isEffectiveSemanticsBoundary &amp;amp;&amp;amp; node._semantics == null) {
      return;
    }
  }
  if (node != this &amp;amp;&amp;amp; _semantics != null &amp;amp;&amp;amp; _needsSemanticsUpdate) {
    owner._nodesNeedingSemantics.remove(this);
  }
  if (!node._needsSemanticsUpdate) {
    node._needsSemanticsUpdate = true;
    if (owner != null) {
      //记录需要更新语义的渲染对象
      owner._nodesNeedingSemantics.add(node);
      owner.requestVisualUpdate();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;473-markneedspaint&quot;&gt;4.7.3 markNeedsPaint&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void markNeedsPaint() {
  if (_needsPaint)
    return;
  _needsPaint = true;
  if (isRepaintBoundary) {
    if (owner != null) {
      //记录需要重新绘制的渲染对象
      owner._nodesNeedingPaint.add(this);
      owner.requestVisualUpdate();
    }
  } else if (parent is RenderObject) {
    final RenderObject parent = this.parent;
    parent.markNeedsPaint();
  } else {
    if (owner != null)
      owner.requestVisualUpdate();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;48-pipelineownerflushcompositingbits&quot;&gt;4.8 PipelineOwner.flushCompositingBits&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushCompositingBits() {
  profile(() { Timeline.startSync('Compositing bits'); });
  _nodesNeedingCompositingBitsUpdate.sort((RenderObject a, RenderObject b) =&amp;gt; a.depth - b.depth);
  for (RenderObject node in _nodesNeedingCompositingBitsUpdate) {
    //根据需要来决定是否更新位合成
    if (node._needsCompositingBitsUpdate &amp;amp;&amp;amp; node.owner == this)
      node._updateCompositingBits(); // [见小节4.8.1]
  }
  _nodesNeedingCompositingBitsUpdate.clear();  //清空需要位合成的渲染对象
  profile(() { Timeline.finishSync(); });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;481-_updatecompositingbits&quot;&gt;4.8.1 _updateCompositingBits&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _updateCompositingBits() {
  if (!_needsCompositingBitsUpdate)
    return;
  final bool oldNeedsCompositing = _needsCompositing;
  _needsCompositing = false;
  visitChildren((RenderObject child) {
    //遍历所有子项来更新位合成
    child._updateCompositingBits();
    if (child.needsCompositing)
      _needsCompositing = true;
  });
  if (isRepaintBoundary || alwaysNeedsCompositing)
    _needsCompositing = true;
  if (oldNeedsCompositing != _needsCompositing)
    markNeedsPaint();
  _needsCompositingBitsUpdate = false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;49-pipelineownerflushpaint&quot;&gt;4.9 PipelineOwner.flushPaint&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushPaint() {
  profile(() { Timeline.startSync('Paint', arguments: timelineWhitelistArguments); });
  try {
    final List&amp;lt;RenderObject&amp;gt; dirtyNodes = _nodesNeedingPaint;
    _nodesNeedingPaint = &amp;lt;RenderObject&amp;gt;[];
    //排序脏节点，深度最大的节点排第一位
    for (RenderObject node in dirtyNodes..sort((RenderObject a, RenderObject b) =&amp;gt; b.depth - a.depth)) {
      if (node._needsPaint &amp;amp;&amp;amp; node.owner == this) {
        //此节点是否连接到树中，如果连接则重绘，否则跳过
        if (node._layer.attached) {
          PaintingContext.repaintCompositedChild(node);  //[小节4.9.1]
        } else {
          node._skippedPaintingOnLayer();
        }
      }
    }
  } finally {
    profile(() { Timeline.finishSync(); });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;491-repaintcompositedchild&quot;&gt;4.9.1 repaintCompositedChild&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void repaintCompositedChild(RenderObject child, { bool debugAlsoPaintedParent = false }) {
  _repaintCompositedChild(
    child,
    debugAlsoPaintedParent: debugAlsoPaintedParent,
  );
}

static void _repaintCompositedChild(
  RenderObject child, {
  bool debugAlsoPaintedParent = false,
  PaintingContext childContext,
}) {
  if (child._layer == null) {
    child._layer = OffsetLayer();
  } else {
    child._layer.removeAllChildren();
  }
  childContext ??= PaintingContext(child._layer, child.paintBounds);
  child._paintWithContext(childContext, Offset.zero);
  childContext.stopRecordingIfNeeded();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;410-renderviewcompositeframe&quot;&gt;4.10 RenderView.compositeFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/view.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void compositeFrame() {
  Timeline.startSync('Compositing', arguments: timelineWhitelistArguments);
  try {
    //创建SceneBuilder [见小节4.10.1]
    final ui.SceneBuilder builder = ui.SceneBuilder();
    //创建Scene [见小节4.10.2]
    final ui.Scene scene = layer.buildScene(builder);
    if (automaticSystemUiAdjustment)
      _updateSystemChrome();
    ui.window.render(scene); // [见小节4.10.3]
    scene.dispose();
  } finally {
    Timeline.finishSync();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分别创建Flutter框架(dart)和引擎层(C++)的两个SceneBuilder；&lt;/li&gt;
  &lt;li&gt;分别创建Flutter框架(dart)和引擎层(C++)的两个Scene；&lt;/li&gt;
  &lt;li&gt;执行render()将layer树发送给GPU线程；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4101-scenebuilder初始化&quot;&gt;4.10.1 SceneBuilder初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/ui/compositing.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SceneBuilder extends NativeFieldWrapperClass2 {
  @pragma('vm:entry-point')
  SceneBuilder() { _constructor(); }
  void _constructor() native 'SceneBuilder_constructor';
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;SceneBuilder_constructor这是native方法，最终调用到引擎中的lib/ui/compositing/scene_builder.h中的SceneBuilder::create()方法， 创建C++的SceneBuilder对象。&lt;/p&gt;

&lt;h4 id=&quot;4102-offsetlayerbuildscene&quot;&gt;4.10.2 OffsetLayer.buildScene&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/layer.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ui.Scene buildScene(ui.SceneBuilder builder) {
  updateSubtreeNeedsAddToScene();  //遍历layer树，将需要子树加入到scene
  addToScene(builder); //将layer添加到SceneBuilder
  return builder.build(); //调用C++层的build来构建Scene对象。
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;遍历layer树，将需要更新的全部都加入到SceneBuilder。再调用build()，同样也是native方法，执行SceneBuilder::build()来构建Scene对象。&lt;/p&gt;

&lt;h4 id=&quot;4103-windowrender&quot;&gt;4.10.3 Window::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window/window.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Render(Dart_NativeArguments args) {
  Dart_Handle exception = nullptr;
  Scene* scene = tonic::DartConverter&amp;lt;Scene*&amp;gt;::FromArguments(args, 1, exception);
  if (exception) {
    Dart_ThrowException(exception);
    return;
  }
  UIDartState::Current()-&amp;gt;window()-&amp;gt;client()-&amp;gt;Render(scene);  // [4.10.4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;ui.window.render()位于window.dart文件，这是一个native方法，会调用到window.cc的Render()方法。&lt;/p&gt;

&lt;h4 id=&quot;4104-runtimecontrollerrender&quot;&gt;4.10.4 RuntimeController::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/runtime/runtime_controller.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RuntimeController::Render(Scene* scene) {
  //从scene中取出layer树 [见小节4.10.5]
  client_.Render(scene-&amp;gt;takeLayerTree());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4105-enginerender&quot;&gt;4.10.5 Engine::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::Render(std::unique_ptr&amp;lt;flow::LayerTree&amp;gt; layer_tree) {
  if (!layer_tree)
    return;

  SkISize frame_size = SkISize::Make(viewport_metrics_.physical_width,
                                     viewport_metrics_.physical_height);
  if (frame_size.isEmpty())
    return;

  layer_tree-&amp;gt;set_frame_size(frame_size);
  animator_-&amp;gt;Render(std::move(layer_tree));  // [4.10.6]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4106-animatorrender&quot;&gt;4.10.6 Animator::Render&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::Render(std::unique_ptr&amp;lt;flow::LayerTree&amp;gt; layer_tree) {
  if (dimension_change_pending_ &amp;amp;&amp;amp;
      layer_tree-&amp;gt;frame_size() != last_layer_tree_size_) {
    dimension_change_pending_ = false;
  }
  last_layer_tree_size_ = layer_tree-&amp;gt;frame_size();

  if (layer_tree) {
    layer_tree-&amp;gt;set_construction_time(fml::TimePoint::Now() -
                                      last_begin_frame_time_);
  }

  //提交待处理的continuation，本次PipelineProduce完成 //[见小节4.10.7]
  producer_continuation_.Complete(std::move(layer_tree));

  delegate_.OnAnimatorDraw(layer_tree_pipeline_); //[见小节4.10.8]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;UI线程的耗时从doFrame(frameTimeNanos)中的frameTimeNanos为起点，以Animator::Render()方法结束为终点， 并将结果保存到LayerTree的成员变量construction_time_，这便是UI线程的耗时时长。&lt;/p&gt;

&lt;h4 id=&quot;4107-producercontinuationcomplete&quot;&gt;4.10.7 ProducerContinuation.Complete&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/synchronization/pipeline.h]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ProducerContinuation {
  void Complete(ResourcePtr resource) {
    if (continuation_) {
      continuation_(std::move(resource), trace_id_);
      continuation_ = nullptr;
      TRACE_EVENT_ASYNC_END0(&quot;flutter&quot;, &quot;PipelineProduce&quot;, trace_id_);
      TRACE_FLOW_STEP(&quot;flutter&quot;, &quot;PipelineItem&quot;, trace_id_);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4108-shellonanimatordraw&quot;&gt;4.10.8 Shell::OnAnimatorDraw&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/shell.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnAnimatorDraw(
    fml::RefPtr&amp;lt;flutter::Pipeline&amp;lt;flow::LayerTree&amp;gt;&amp;gt; pipeline) {

  //向GPU线程提交绘制任务
  task_runners_.GetGPUTaskRunner()-&amp;gt;PostTask(
      [rasterizer = rasterizer_-&amp;gt;GetWeakPtr(),
       pipeline = std::move(pipeline)]() {
        if (rasterizer) {
          //由GPU线程来负责栅格化操作
          rasterizer-&amp;gt;Draw(pipeline);
        }
      });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个方法主要是向GPU线程提交绘制任务。&lt;/p&gt;

&lt;h3 id=&quot;411-pipelineownerflushsemantics&quot;&gt;4.11 PipelineOwner.flushSemantics&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/view.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void flushSemantics() {
  if (_semanticsOwner == null)
    return;
  profile(() { Timeline.startSync('Semantics'); });
  try {
    final List&amp;lt;RenderObject&amp;gt; nodesToProcess = _nodesNeedingSemantics.toList()
      ..sort((RenderObject a, RenderObject b) =&amp;gt; a.depth - b.depth);
    _nodesNeedingSemantics.clear();
    //遍历_nodesNeedingSemantics，更新需要更新语义的渲染对象
    for (RenderObject node in nodesToProcess) {
      if (node._needsSemanticsUpdate &amp;amp;&amp;amp; node.owner == this)
        node._updateSemantics(); // [见小节4.11.1]
    }
    _semanticsOwner.sendSemanticsUpdate(); // 发送语义更新[见小节4.11.2]
  } finally {
    profile(() { Timeline.finishSync(); });
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4111-_updatesemantics&quot;&gt;4.11.1 _updateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/rendering/object.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void _updateSemantics() {
  if (_needsLayout) {
    //此子树中没有足够的信息来计算语义，子树可能被视图窗口保持活着但没有布局
    return;
  }
  final _SemanticsFragment fragment = _getSemanticsForParent(
    mergeIntoParent: _semantics?.parent?.isPartOfNodeMerging ?? false,
  );
  final _InterestingSemanticsFragment interestingFragment = fragment;
  final SemanticsNode node = interestingFragment.compileChildren(
    parentSemanticsClipRect: _semantics?.parentSemanticsClipRect,
    parentPaintClipRect: _semantics?.parentPaintClipRect,
  ).single;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4112-sendsemanticsupdate&quot;&gt;4.11.2 sendSemanticsUpdate&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/semantics/semantics.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void sendSemanticsUpdate() {
  if (_dirtyNodes.isEmpty)
    return;
  final Set&amp;lt;int&amp;gt; customSemanticsActionIds = Set&amp;lt;int&amp;gt;();
  final List&amp;lt;SemanticsNode&amp;gt; visitedNodes = &amp;lt;SemanticsNode&amp;gt;[];
  while (_dirtyNodes.isNotEmpty) {
    final List&amp;lt;SemanticsNode&amp;gt; localDirtyNodes = _dirtyNodes.where((SemanticsNode node) =&amp;gt; !_detachedNodes.contains(node)).toList();
    _dirtyNodes.clear();
    _detachedNodes.clear();
    localDirtyNodes.sort((SemanticsNode a, SemanticsNode b) =&amp;gt; a.depth - b.depth);
    visitedNodes.addAll(localDirtyNodes);
    for (SemanticsNode node in localDirtyNodes) {
      if (node.isPartOfNodeMerging) {
        //如果合并到父节点，确保父节点已被添加到脏列表
        if (node.parent != null &amp;amp;&amp;amp; node.parent.isPartOfNodeMerging)
          node.parent._markDirty(); //将节点添加到脏列表
      }
    }
  }
  visitedNodes.sort((SemanticsNode a, SemanticsNode b) =&amp;gt; a.depth - b.depth);
  final ui.SemanticsUpdateBuilder builder = ui.SemanticsUpdateBuilder();
  for (SemanticsNode node in visitedNodes) {
    if (node._dirty &amp;amp;&amp;amp; node.attached)
      node._addToUpdate(builder, customSemanticsActionIds);
  }
  _dirtyNodes.clear();
  for (int actionId in customSemanticsActionIds) {
    final CustomSemanticsAction action = CustomSemanticsAction.getAction(actionId);
    builder.updateCustomAction(id: actionId, label: action.label, hint: action.hint, overrideId: action.action?.index ?? -1);
  }
  ui.window.updateSemantics(builder.build());  // [见小节4.11.3]
  notifyListeners(); //通知已注册的监听器
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以看看监听器的数据，是否影响性能。&lt;/p&gt;

&lt;p&gt;updateSemantics这是window.dart中的一个native方法，调用到如下方法。&lt;/p&gt;

&lt;h4 id=&quot;4113-windowupdatesemantics&quot;&gt;4.11.3 Window::updateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window/window.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void UpdateSemantics(Dart_NativeArguments args) {
  Dart_Handle exception = nullptr;
  SemanticsUpdate* update =
      tonic::DartConverter&amp;lt;SemanticsUpdate*&amp;gt;::FromArguments(args, 1, exception);
  if (exception) {
    Dart_ThrowException(exception);
    return;
  }
  UIDartState::Current()-&amp;gt;window()-&amp;gt;client()-&amp;gt;UpdateSemantics(update); // [见小节4.11.4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4114-runtimecontrollerupdatesemantics&quot;&gt;4.11.4 RuntimeController::UpdateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/runtime/runtime_controller.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void RuntimeController::UpdateSemantics(SemanticsUpdate* update) {
  if (window_data_.semantics_enabled) {
    client_.UpdateSemantics(update-&amp;gt;takeNodes(), update-&amp;gt;takeActions()); // [见小节4.11.5]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4115-engineupdatesemantics&quot;&gt;4.11.5 Engine::UpdateSemantics&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::UpdateSemantics(blink::SemanticsNodeUpdates update,
                             blink::CustomAccessibilityActionUpdates actions) {
  delegate_.OnEngineUpdateSemantics(std::move(update), std::move(actions)); // [见小节4.11.6]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4116-shellonanimatordraw&quot;&gt;4.11.6 Shell::OnAnimatorDraw&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/shell.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnEngineUpdateSemantics(
    blink::SemanticsNodeUpdates update,
    blink::CustomAccessibilityActionUpdates actions) {

  task_runners_.GetPlatformTaskRunner()-&amp;gt;PostTask(
      [view = platform_view_-&amp;gt;GetWeakPtr(), update = std::move(update),
       actions = std::move(actions)] {
        if (view) {
          view-&amp;gt;UpdateSemantics(std::move(update), std::move(actions));
        }
      });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这个方法主要是向平台线程提交Semantic任务。&lt;/p&gt;

&lt;p&gt;再回到小节4.6，可知接下来再执行finalizeTree()操作；&lt;/p&gt;

&lt;h3 id=&quot;412-buildownerfinalizetree&quot;&gt;4.12 BuildOwner.finalizeTree&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void finalizeTree() {
  Timeline.startSync('Finalize tree', arguments: timelineWhitelistArguments);
  try {
    lockState(() {
      //遍历所有的Element，执行unmount()动作，且取消GlobalKeys的注册
      _inactiveElements._unmountAll();
    });
  } catch (e, stack) {
    _debugReportException('while finalizing the widget tree', e, stack);
  } finally {
    Timeline.finishSync();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;遍历所有的Element，执行相应具体Element子类的unmount()操作，下面以常见的StatefulElement为例来说明。&lt;/p&gt;

&lt;h4 id=&quot;4121-statefulelementunmount&quot;&gt;4.12.1 StatefulElement.unmount&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void unmount() {
  super.unmount(); //[见小节4.12.2]
  _state.dispose(); //执行State的dispose()方法
  _state._element = null;
  _state = null;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;4122-elementunmount&quot;&gt;4.12.2 Element.unmount&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; lib/src/widgets/framework.dart]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void unmount() {
  if (widget.key is GlobalKey) {
    final GlobalKey key = widget.key;
    key._unregister(this);  //取消GlobalKey的注册
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;本文涉及到相关源码文件&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;flutter/shell/common/
    - vsync_waiter.cc
    - engine.cc
    - animator.cc
    - shell.cc
    - rasterizer.cc

flutter/shell/platform/android/
    - vsync_waiter_android.cc
    - platform_view_android_jni.cc
    - library_loader.cc
    - io/flutter/view/VsyncWaiter.java

flutter/runtime/runtime_controller.cc
flutter/synchronization/pipeline.h
flutter/fml/message_loop_impl.cc
flutter/lib/ui/window/window.cc
flutter/lib/ui/window.dart
flutter/lib/ui/hooks.dart

lib/src/widgets/framework.dart
lib/src/widgets/binding.dart
lib/src/scheduler/binding.dart
lib/src/semantics/semantics.dart

lib/src/rendering/
    - binding.dart
    - object.dart
    - view.dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Wed, 25 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E5%9B%9B)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E5%9B%9B)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(三)</title>
        <description>&lt;h2 id=&quot;三engine层绘制&quot;&gt;三、Engine层绘制&lt;/h2&gt;
&lt;h3 id=&quot;31-doframe&quot;&gt;3.1 doFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; Choreographer.java]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void doFrame(long frameTimeNanos) {
    //Android FW每次当vsync信号触发，则会调用该方法 [见下方]
    nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Vsync注册过程见[小节2.6] Choreographer.FrameCallback()。注册了Vysnc信号后，一旦底层Vsync信号触发，经过层层调用回到FrameDisplayEventReceiver的过程，然后会有一个通过handler的方式post到线程”FlutterVsyncThread”来执行操作， 具体流程见Choreographer原理。紧接着再处理所有注册的doCallbacks方法，则会执行Choreographer.FrameCallback中的doFrame()方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Choreographer.FrameCallback() {
    @Override
    public void doFrame(long frameTimeNanos) {
        //frameTimeNanos是VYSNC触发的时间点，也就是计划绘制的时间点 [见小节3.2]
        nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-onnativevsync&quot;&gt;3.2 OnNativeVsync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/io/flutter/view/VsyncWaiter.java]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class VsyncWaiter {
    ...
    // [见小节3.2.1]
    private static native void nativeOnVsync(long frameTimeNanos,
                                             long frameTargetTimeNanos,
                                             long cookie);
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由[小节2.5.3]可知，VsyncWaiter.java中的nativeOnVsync对应于vsync_waiter_android.cc的OnNativeVsync()，具体过程在jni加载过程初始化，如下所示。&lt;/p&gt;

&lt;h4 id=&quot;321-onnativevsyncc&quot;&gt;3.2.1 OnNativeVsync[C++]&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void OnNativeVsync(JNIEnv* env, jclass jcaller,
                          jlong frameTimeNanos,
                          jlong frameTargetTimeNanos,
                          jlong java_baton) {
  auto frame_time = fml::TimePoint::FromEpochDelta(
      fml::TimeDelta::FromNanoseconds(frameTimeNanos));
  auto target_time = fml::TimePoint::FromEpochDelta(
      fml::TimeDelta::FromNanoseconds(frameTargetTimeNanos));
  //消费pending回调[见小节3.3]
  ConsumePendingCallback(java_baton, frame_time, target_time);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;33-consumependingcallback&quot;&gt;3.3 ConsumePendingCallback&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void ConsumePendingCallback(jlong java_baton,
                                   fml::TimePoint frame_start_time,
                                   fml::TimePoint frame_target_time) {
  auto* weak_this = reinterpret_cast&amp;lt;std::weak_ptr&amp;lt;VsyncWaiter&amp;gt;*&amp;gt;(java_baton);
  auto shared_this = weak_this-&amp;gt;lock();
  delete weak_this;

  if (shared_this) {
    //shared_this指向VsyncWaiter的弱引用 [见小节3.4]
    shared_this-&amp;gt;FireCallback(frame_start_time, frame_target_time);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;34-vsyncwaiterfirecallback&quot;&gt;3.4 VsyncWaiter::FireCallback&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/vsync_waiter.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void VsyncWaiter::FireCallback(fml::TimePoint frame_start_time,
                               fml::TimePoint frame_target_time) {
  Callback callback;
  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(callback_mutex_);
    callback = std::move(callback_);
  }
  if (!callback) {
    TRACE_EVENT_INSTANT0(&quot;flutter&quot;, &quot;MismatchedFrameCallback&quot;);
    return;
  }

  TRACE_EVENT0(&quot;flutter&quot;, &quot;VsyncFireCallback&quot;);
  //将任务放入task队列[见小节3.4.1]
  task_runners_.GetUITaskRunner()-&amp;gt;PostTaskForTime(
    [callback, flow_identifier, frame_start_time, frame_target_time]() {
      FML_TRACE_EVENT(&quot;flutter&quot;, kVsyncTraceName, &quot;StartTime&quot;,
                      frame_start_time, &quot;TargetTime&quot;, frame_target_time);
      fml::tracing::TraceEventAsyncComplete(
          &quot;flutter&quot;, &quot;VsyncSchedulingOverhead&quot;, fml::TimePoint::Now(),
          frame_start_time);
      //开始执行vync [见小节3.5]
      callback(frame_start_time, frame_target_time);
      TRACE_FLOW_END(&quot;flutter&quot;, kVsyncFlowName, flow_identifier);
    },
    frame_start_time);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将任务闭包放入task队列，消息Loop一旦接受到消息则会读取出来。&lt;/p&gt;

&lt;h4 id=&quot;341-messageloopimplrunexpiredtasks&quot;&gt;3.4.1 MessageLoopImpl::RunExpiredTasks&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/fml/message_loop_impl.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void MessageLoopImpl::RunExpiredTasks() {
  TRACE_EVENT0(&quot;fml&quot;, &quot;MessageLoop::RunExpiredTasks&quot;);
  std::vector&amp;lt;fml::closure&amp;gt; invocations;

  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(delayed_tasks_mutex_);
    //当没有待处理的task则直接返回
    if (delayed_tasks_.empty()) {
      return;
    }

    auto now = fml::TimePoint::Now();
    while (!delayed_tasks_.empty()) {
      const auto&amp;amp; top = delayed_tasks_.top();
      if (top.target_time &amp;gt; now) {
        break;
      }
      invocations.emplace_back(std::move(top.task));
      delayed_tasks_.pop();
    }
    WakeUp(delayed_tasks_.empty() ? fml::TimePoint::Max()
                                  : delayed_tasks_.top().target_time);
  }

  for (const auto&amp;amp; invocation : invocations) {
    invocation();  // [见小节3.5]
    for (const auto&amp;amp; observer : task_observers_) {
      observer.second();
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于ui线程处于消息loop状态，一旦有时间到达的任务则开始执行，否则处于空闲等等状态。前面[小节3.4] VsyncWaiter::FireCallback过程已经向该ui线程postTask。 对于不可复用layer tree的情况则调用Animator::BeginFrame()方法。&lt;/p&gt;

&lt;h3 id=&quot;35-callback&quot;&gt;3.5 callback&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[self = weak_factory_.GetWeakPtr()](fml::TimePoint frame_start_time,
                                    fml::TimePoint frame_target_time) {
  if (self) {
    if (self-&amp;gt;CanReuseLastLayerTree()) {
      self-&amp;gt;DrawLastLayerTree();
    } else {
      //根据默认参数regenerate_layer_tree_为true，则执行该分支 [见小节3.6]
      self-&amp;gt;BeginFrame(frame_start_time, frame_target_time);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此次的callback赋值过程位于[小节2.3]Animator::AwaitVSync()方法的闭包参数，相关说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;frame_start_time：计划开始绘制时间点，来源于doFrame()方法中的参数；&lt;/li&gt;
  &lt;li&gt;frame_target_time：从frame_start_time加上一帧时间(16.7ms)的时间，作为本次绘制的deadline。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;36-animatorbeginframe&quot;&gt;3.6 Animator::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::BeginFrame(fml::TimePoint frame_start_time,
                          fml::TimePoint frame_target_time) {
  TRACE_EVENT_ASYNC_END0(&quot;flutter&quot;, &quot;Frame Request Pending&quot;, frame_number_++);
  TRACE_EVENT0(&quot;flutter&quot;, &quot;Animator::BeginFrame&quot;);

  frame_scheduled_ = false;
  notify_idle_task_id_++;
  regenerate_layer_tree_ = false;
  //信号量加1，可以注册新的vsync信号，也就是能执行Animator::RequestFrame()
  pending_frame_semaphore_.Signal();

  if (!producer_continuation_) {
    //[小节3.6.1]/[小节3.6.2]
    producer_continuation_ = layer_tree_pipeline_-&amp;gt;Produce();
    //pipeline已满，说明GPU线程繁忙，则结束本次UI绘制，重新注册Vsync
    if (!producer_continuation_) {
      RequestFrame();
      return;
    }
  }

  //从pipeline中获取有效的continuation，并准备为可能的frame服务
  last_begin_frame_time_ = frame_start_time;
  //获取当前帧绘制截止时间，用于告知可GC的空闲时长
  dart_frame_deadline_ = FxlToDartOrEarlier(frame_target_time);
  {
    TRACE_EVENT2(&quot;flutter&quot;, &quot;Framework Workload&quot;, &quot;mode&quot;, &quot;basic&quot;, &quot;frame&quot;,
                 FrameParity());
    //此处delegate_为Shell [小节3.7]
    delegate_.OnAnimatorBeginFrame(last_begin_frame_time_);
  }

  if (!frame_scheduled_) {
    task_runners_.GetUITaskRunner()-&amp;gt;PostDelayedTask(
        [self = weak_factory_.GetWeakPtr(),
         notify_idle_task_id = notify_idle_task_id_]() {
          if (!self.get()) {
            return;
          }
          // 该任务id和当前任务id一致，则不再需要审查frame，可以通知引擎当前处于空闲状态，100ms
          if (notify_idle_task_id == self-&amp;gt;notify_idle_task_id_) {
            self-&amp;gt;delegate_.OnAnimatorNotifyIdle(Dart_TimelineGetMicros() +
                                                 100000);
          }
        },
        kNotifyIdleTaskWaitTime); //延迟51ms再通知引擎空闲状态
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法主要功能说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;layer_tree_pipeline_是在Animator对象初始化的过程中创建的LayerTreePipeline，其类型为Pipeline&lt;/li&gt;
  &lt;li&gt;此处kNotifyIdleTaskWaitTime等于51ms，等于3帧的时间+1ms，之所以这样设计是由于在某些工作负载下（比如父视图调整大小，通过viewport metrics事件传达给子视图）实际上还没有schedule帧，尽管在下一个vsync会生成一帧(将在收到viewport事件后schedule)，因此推迟调用OnAnimatorNotifyIdle一点点，从而避免可能垃圾回收在不希望的时间触发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;361-layertreepipeline初始化&quot;&gt;3.6.1 LayerTreePipeline初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Animator::Animator(Delegate&amp;amp; delegate,
                   TaskRunners task_runners,
                   std::unique_ptr&amp;lt;VsyncWaiter&amp;gt; waiter)
    : delegate_(delegate),
      task_runners_(std::move(task_runners)),
      waiter_(std::move(waiter)),
      last_begin_frame_time_(),
      dart_frame_deadline_(0),
      layer_tree_pipeline_(fml::MakeRefCounted&amp;lt;LayerTreePipeline&amp;gt;(2)),
      ... {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此处LayerTreePipeline的初始化过程如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;using LayerTreePipeline = Pipeline&amp;lt;flutter::LayerTree&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在pipeline.h的过程会初始化Pipeline，可见初始值empty_ = 2，available_ = 0；&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Pipeline(uint32_t depth) : empty_(depth), available_(0) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;362-pipelineproduce&quot;&gt;3.6.2 Pipeline::Produce&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/synchronization/pipeline.h]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProducerContinuation Produce() {
  //当管道不为空，则不允许再次向管道加入数据
  if (!empty_.TryWait()) {
    return {};
  }

  //[见小节3.6.3]
  return ProducerContinuation{
      std::bind(&amp;amp;Pipeline::ProducerCommit, this, std::placeholders::_1,
                std::placeholders::_2),  // continuation
      GetNextPipelineTraceID()};  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过信号量empty_的初始值为depth(默认等于2)，来保证同一个管道的任务最多不超过depth个，每次UI线程执行Produce()会减1，当GPU线程执行完成Consume()方法后才会执行加1操作。&lt;/p&gt;

&lt;h4 id=&quot;363-producercontinuation初始化&quot;&gt;3.6.3 ProducerContinuation初始化&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/synchronization/pipeline.h]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ProducerContinuation(Continuation continuation, size_t trace_id)
    : continuation_(continuation), trace_id_(trace_id) {
  TRACE_FLOW_BEGIN(&quot;flutter&quot;, &quot;PipelineItem&quot;, trace_id_);
  TRACE_EVENT_ASYNC_BEGIN0(&quot;flutter&quot;, &quot;PipelineProduce&quot;, trace_id_);
}
3.6.3 Pipeline.ProducerCommit
[-&amp;gt; flutter/synchronization/pipeline.h]

void ProducerCommit(ResourcePtr resource, size_t trace_id) {
  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(queue_mutex_);
    queue_.emplace(std::move(resource), trace_id);
  }

  available_.Signal();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;37-shellonanimatorbeginframe&quot;&gt;3.7 Shell::OnAnimatorBeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/shell.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Shell::OnAnimatorBeginFrame(fml::TimePoint frame_time) {
  if (engine_) {
    engine_-&amp;gt;BeginFrame(frame_time);  // [小节3.8]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;38-enginebeginframe&quot;&gt;3.8 Engine::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::BeginFrame(fml::TimePoint frame_time) {
  TRACE_EVENT0(&quot;flutter&quot;, &quot;Engine::BeginFrame&quot;);
  runtime_controller_-&amp;gt;BeginFrame(frame_time);  // [小节3.9]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;39-runtimecontrollerbeginframe&quot;&gt;3.9 RuntimeController::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/runtime/runtime_controller.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool RuntimeController::BeginFrame(fml::TimePoint frame_time) {
  if (auto* window = GetWindowIfAvailable()) {
    window-&amp;gt;BeginFrame(frame_time);  // [小节3.10]
    return true;
  }
  return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;310-windowbeginframe&quot;&gt;3.10 Window::BeginFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/lib/ui/window/window.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Window::BeginFrame(fml::TimePoint frameTime) {
  std::shared_ptr&amp;lt;tonic::DartState&amp;gt; dart_state = library_.dart_state().lock();
  if (!dart_state)
    return;
  tonic::DartState::Scope scope(dart_state);
  //注意此处的frameTime便是前面小节3.1中doFrame方法中的参数frameTimeNanos
  int64_t microseconds = (frameTime - fml::TimePoint()).ToMicroseconds();

  // [见小节4.2]
  DartInvokeField(library_.value(), &quot;_beginFrame&quot;,
                  {Dart_NewInteger(microseconds)});

  //执行MicroTask
  UIDartState::Current()-&amp;gt;FlushMicrotasksNow();

  // [见小节4.4]
  DartInvokeField(library_.value(), &quot;_drawFrame&quot;, {});
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Window::BeginFrame()过程主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;执行_beginFrame&lt;/li&gt;
  &lt;li&gt;执行FlushMicrotasksNow&lt;/li&gt;
  &lt;li&gt;执行_drawFrame&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，Microtask位于beginFrame和drawFrame之间，那么Microtask的耗时会影响ui绘制过程。&lt;/p&gt;

&lt;p&gt;DartInvokeField()通过dart虚拟机调用了window.onBeginFrame()和onDrawFrame方法，见hooks.dart文件中如下过程：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@pragma('vm:entry-point')
void _beginFrame(int microseconds) {
  _invoke1&amp;lt;Duration&amp;gt;(window.onBeginFrame, window._onBeginFrameZone, new Duration(microseconds: microseconds));
}

@pragma('vm:entry-point')
void _drawFrame() {
  _invoke(window.onDrawFrame, window._onDrawFrameZone);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Thu, 19 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%B8%89)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%B8%89)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter渲染机制—UI线程(二)</title>
        <description>&lt;h2 id=&quot;二-vsync注册流程&quot;&gt;二、 VSYNC注册流程&lt;/h2&gt;
&lt;h3 id=&quot;21-enginescheduleframe&quot;&gt;2.1 Engine::ScheduleFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/engine.cc]&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Engine::ScheduleFrame(bool regenerate_layer_tree) {
    //[见小节2.2]
    animator_-&amp;gt;RequestFrame(regenerate_layer_tree);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;animator_的赋值过程是在Engine对象初始化过程完成，而Engine初始化过程在Shell创建过程，此处animator_便是Animator对象；&lt;/li&gt;
  &lt;li&gt;ScheduleFrame的参数regenerate_layer_tree决定是否需要重新生成layer tree，还是直接复用上一次生成的layer tree；&lt;/li&gt;
  &lt;li&gt;绝大多数情况下，调用RequestFrame()时将regenerate_layer_tree_设置为true或者用默认值true，执行完Animator::BeginFrame()则设置该变量为false；
    &lt;ul&gt;
      &lt;li&gt;当无参数调用该方法时，regenerate_layer_tree为默认值为true。&lt;/li&gt;
      &lt;li&gt;特别的例子就是Shell::OnPlatformViewMarkTextureFrameAvailable()过程，设置参数为false，那么计划绘制一帧的时候就不需要重绘layer tree；&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-animatorrequestframe&quot;&gt;2.2 Animator::RequestFrame&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::RequestFrame(bool regenerate_layer_tree) {
  if (regenerate_layer_tree) {
    // regenerate_layer_tree_决定Vsync信号到来时，是否执行BeginFrame
    regenerate_layer_tree_ = true;
  }

  //当调用Animator::Stop()则会停止动画绘制
  if (paused_ &amp;amp;&amp;amp; !dimension_change_pending_) {
    return;
  }

  //调用sem_trywait来保证不会同时有多个vsync请求
  if (!pending_frame_semaphore_.TryWait()) {
    return;
  }

  task_runners_.GetUITaskRunner()-&amp;gt;PostTask([self = weak_factory_.GetWeakPtr(),
                                             frame_number = frame_number_]() {
    if (!self.get()) {
      return;
    }
    TRACE_EVENT_ASYNC_BEGIN0(&quot;flutter&quot;, &quot;Frame Request Pending&quot;, frame_number);
    self-&amp;gt;AwaitVSync();  // [见小节2.3]
  });
  frame_scheduled_ = true;  //标注已经schedule绘画帧
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;过程说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;pending_frame_semaphore_：非负信号量，初始值为1，第一次调用TryWait减1，而后再次调用则会失败直接返回。当消费了这次vsync回调，也就是调用了Animator的BeginFrame()或者DrawLastLayerTree()方法后，改信号量会加1[见小节3.6]，可以再次执行vysnc的注册；&lt;/li&gt;
  &lt;li&gt;通过Animator的Start()或者BeginFrame调用到的RequestFrame方法，则肯定需要重新生成layer tree；通过Engine的ScheduleFrame方法是否重建layer tree看小节2.1；&lt;/li&gt;
  &lt;li&gt;此处通过post把Animator::AwaitVSync任务放入到UI Task Runner来执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-animatorawaitvsync&quot;&gt;2.3 Animator::AwaitVSync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/animator.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void Animator::AwaitVSync() {
  // [见小节2.4]
  waiter_-&amp;gt;AsyncWaitForVsync(
      [self = weak_factory_.GetWeakPtr()](fml::TimePoint frame_start_time,
                                          fml::TimePoint frame_target_time) {
        if (self) {
          //是否能复用上次layer树，取决于regenerate_layer_tree_
          if (self-&amp;gt;CanReuseLastLayerTree()) {
            //复用上次layer树，直接把任务post到gpu线程做栅格化操作
            self-&amp;gt;DrawLastLayerTree();
          } else {
            self-&amp;gt;BeginFrame(frame_start_time, frame_target_time);
          }
        }
      });

  delegate_.OnAnimatorNotifyIdle(dart_frame_deadline_);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;waiter_的赋值是在Animator初始化过程，取值为VsyncWaiterAndroid对象，当调用了RequestFrame()，默认参数regenerate_layer_tree_为true，意味着需要重新生成layer树，故不能重复使用上一次的layer树，接着来看一下AsyncWaitForVsync()方法的实现。&lt;/p&gt;

&lt;h3 id=&quot;24-vsyncwaiterasyncwaitforvsync&quot;&gt;2.4 VsyncWaiter::AsyncWaitForVsync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/common/vsync_waiter.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void VsyncWaiter::AsyncWaitForVsync(Callback callback) {
  {
    std::lock_guard&amp;lt;std::mutex&amp;gt; lock(callback_mutex_);
    //赋值callback_
    callback_ = std::move(callback);
  }
  TRACE_EVENT0(&quot;flutter&quot;, &quot;AsyncWaitForVsync&quot;);
  AwaitVSync(); // [见小节2.5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此次的callback_便是[小节2.3]方法中的参数，该方法根据regenerate_layer_tree_来决定执行流。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当regenerate_layer_tree_=false，则执行DrawLastLayerTree();&lt;/li&gt;
  &lt;li&gt;当regenerate_layer_tree_=false，则执行BeginFrame();&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;25-vsyncwaiterandroidawaitvsync&quot;&gt;2.5 VsyncWaiterAndroid::AwaitVSync&lt;/h3&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void VsyncWaiterAndroid::AwaitVSync() {
  std::weak_ptr&amp;lt;VsyncWaiter&amp;gt;* weak_this =
      new std::weak_ptr&amp;lt;VsyncWaiter&amp;gt;(shared_from_this());
  //获取VsyncWaiter的弱引用
  jlong java_baton = reinterpret_cast&amp;lt;jlong&amp;gt;(weak_this);

  JNIEnv* env = fml::jni::AttachCurrentThread();
  // 此次调用到Java层的asyncWaitForVsync方法，java_baton指向VsyncWaiter
  env-&amp;gt;CallStaticVoidMethod(g_vsync_waiter_class-&amp;gt;obj(),     //
                            g_async_wait_for_vsync_method_,  //
                            java_baton                       //
  );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;此处g_vsync_waiter_class，g_async_wait_for_vsync_method_的赋值过程是由JNI_OnLoad完成，如下所示。&lt;/p&gt;

&lt;h4 id=&quot;251-jni_onload&quot;&gt;2.5.1 JNI_OnLoad&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/library_loader.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {
  // 初始化Java虚拟机
  fml::jni::InitJavaVM(vm);

  JNIEnv* env = fml::jni::AttachCurrentThread();
  bool result = false;

  // 注册FlutterMain.
  result = shell::FlutterMain::Register(env);

  // 注册PlatformView [见小节2.5.2]
  result = shell::PlatformViewAndroid::Register(env);

  // 注册VSyncWaiter [见小节2.5.3]
  result = shell::VsyncWaiterAndroid::Register(env);

  return JNI_VERSION_1_4;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;首次加载共享库时虚拟机会调用此方法。&lt;/p&gt;

&lt;h4 id=&quot;252-register&quot;&gt;2.5.2 Register&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/platform_view_android_jni.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool PlatformViewAndroid::Register(JNIEnv* env) {
  //记录FlutterCallbackInformation类的全局引用
  g_flutter_callback_info_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(
      env, env-&amp;gt;FindClass(&quot;io/flutter/view/FlutterCallbackInformation&quot;));
  //记录FlutterCallbackInformation构造函数
  g_flutter_callback_info_constructor = env-&amp;gt;GetMethodID(
      g_flutter_callback_info_class-&amp;gt;obj(), &quot;&amp;lt;init&amp;gt;&quot;,
      &quot;(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V&quot;);
  //记录FlutterJNI类的全局引用
  g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(
      env, env-&amp;gt;FindClass(&quot;io/flutter/embedding/engine/FlutterJNI&quot;));
  //记录SurfaceTexture类的全局引用
  g_surface_texture_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(
      env, env-&amp;gt;FindClass(&quot;android/graphics/SurfaceTexture&quot;));

  static const JNINativeMethod callback_info_methods[] = {
      {
          .name = &quot;nativeLookupCallbackInformation&quot;,
          .signature = &quot;(J)Lio/flutter/view/FlutterCallbackInformation;&quot;,
          .fnPtr = reinterpret_cast&amp;lt;void*&amp;gt;(&amp;amp;shell::LookupCallbackInformation),
      },
  };
  //注册FlutterCallbackInformation的nativeLookupCallbackInformation()方法
  env-&amp;gt;RegisterNatives(g_flutter_callback_info_class-&amp;gt;obj(),
                           callback_info_methods,
                           arraysize(callback_info_methods)) != 0);

  g_is_released_method =
      env-&amp;gt;GetMethodID(g_surface_texture_class-&amp;gt;obj(), &quot;isReleased&quot;, &quot;()Z&quot;);

  fml::jni::ClearException(env);

  g_attach_to_gl_context_method = env-&amp;gt;GetMethodID(
      g_surface_texture_class-&amp;gt;obj(), &quot;attachToGLContext&quot;, &quot;(I)V&quot;);

  g_update_tex_image_method =
      env-&amp;gt;GetMethodID(g_surface_texture_class-&amp;gt;obj(), &quot;updateTexImage&quot;, &quot;()V&quot;);

  g_get_transform_matrix_method = env-&amp;gt;GetMethodID(
      g_surface_texture_class-&amp;gt;obj(), &quot;getTransformMatrix&quot;, &quot;([F)V&quot;);

  g_detach_from_gl_context_method = env-&amp;gt;GetMethodID(
      g_surface_texture_class-&amp;gt;obj(), &quot;detachFromGLContext&quot;, &quot;()V&quot;);

  return RegisterApi(env);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该方法的主要工作：&lt;/p&gt;

&lt;p&gt;记录和注册类FlutterCallbackInformation、FlutterJNI以及SurfaceTexture类的相关方法，用于Java和C++层方法的相互调用。&lt;/p&gt;
&lt;h4 id=&quot;253-register&quot;&gt;2.5.3 Register&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; flutter/shell/platform/android/vsync_waiter_android.cc]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool VsyncWaiterAndroid::Register(JNIEnv* env) {
  static const JNINativeMethod methods[] = ;

  jclass clazz = env-&amp;gt;FindClass(&quot;io/flutter/view/VsyncWaiter&quot;);

  g_vsync_waiter_class = new fml::jni::ScopedJavaGlobalRef&amp;lt;jclass&amp;gt;(env, clazz);

  g_async_wait_for_vsync_method_ = env-&amp;gt;GetStaticMethodID(
      g_vsync_waiter_class-&amp;gt;obj(), &quot;asyncWaitForVsync&quot;, &quot;(J)V&quot;);

  return env-&amp;gt;RegisterNatives(clazz, methods, arraysize(methods)) == 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;该注册过程主要工作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;将Java层的VsyncWaiter类的nativeOnVsync()方法，映射到C++层的OnNativeVsync()方法，用于该方法的Java调用C++的过程；&lt;/li&gt;
  &lt;li&gt;将Java层的VsyncWaiter类的asyncWaitForVsync()方法，保存到C++层的g_async_wait_for_vsync_method_变量，用于该方法C++调用Java的过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见，将调用VsyncWaiter类的asyncWaitForVsync()方法&lt;/p&gt;

&lt;h3 id=&quot;26-asyncwaitforvsync&quot;&gt;2.6 asyncWaitForVsync&lt;/h3&gt;
&lt;p&gt;[Java]
[-&amp;gt; flutter/shell/platform/android/io/flutter/view/VsyncWaiter.java]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class VsyncWaiter {
    // FlutterView的刷新时间周期（16.7ms）
    public static long refreshPeriodNanos = 1000000000 / 60;

    private static HandlerThread handlerThread;
    private static Handler handler;

    static {
        handlerThread = new HandlerThread(&quot;FlutterVsyncThread&quot;);
        handlerThread.start();
    }

    public static void asyncWaitForVsync(final long cookie) {
        if (handler == null) {
            handler = new Handler(handlerThread.getLooper());
        }
        handler.post(new Runnable() {
            @Override
            public void run() {
                //注册帧回调方法，见小节[2.6.1]/[2.6.2]
                Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {
                    @Override
                    public void doFrame(long frameTimeNanos) {
                        //frameTimeNanos是VYSNC触发的时间点，也就是计划绘制的时间点
                        nativeOnVsync(frameTimeNanos, frameTimeNanos + refreshPeriodNanos, cookie);
                    }
                });
            }
        });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过Handler将工作post到FlutterVsyncThread线程，具体的工作是通过Choreographer来注册回调方法doFrame()以监听系统VSYNC信号。&lt;/p&gt;

&lt;h4 id=&quot;261-choreographergetinstance&quot;&gt;2.6.1 Choreographer.getInstance&lt;/h4&gt;
&lt;p&gt;[-&amp;gt; Choreographer.java]&lt;/p&gt;

&lt;p&gt;```public static Choreographer getInstance() {
    return sThreadInstance.get(); //单例模式
}&lt;/p&gt;

&lt;p&gt;private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance =
    new ThreadLocal&lt;Choreographer&gt;() {&lt;/Choreographer&gt;&lt;/Choreographer&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected Choreographer initialValue() {
    //获取当前线程FlutterVsyncThread的Looper
    Looper looper = Looper.myLooper();
    // 初始化Choreographer对象
    return new Choreographer(looper);
} };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;private Choreographer(Looper looper) {
    mLooper = looper;
    //创建Handler对象
    mHandler = new FrameHandler(looper);
    //创建用于接收VSync信号的对象
    mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;
    mLastFrameTimeNanos = Long.MIN_VALUE;  //上一次帧绘制时间点
    mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());
    mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];&lt;br /&gt;
    for (int i = 0; i &amp;lt;= CALLBACK_LAST; i++) {
        mCallbackQueues[i] = new CallbackQueue();
    }
}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此处Choreographer的mLooper和mHandler都运行在FlutterVsyncThread线程。

#### 2.6.2 postFrameCallback
[-&amp;gt; Choreographer.java]

```public void postFrameCallback(FrameCallback callback) {
    postFrameCallbackDelayed(callback, 0);
}

public void postFrameCallbackDelayed(FrameCallback callback, long delayMillis) {
    postCallbackDelayedInternal(CALLBACK_ANIMATION,
            callback, FRAME_CALLBACK_TOKEN, delayMillis);
}

private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) {
    synchronized (mLock) {
        final long now = SystemClock.uptimeMillis();
        final long dueTime = now + delayMillis;
        //添加到mCallbackQueues队列
        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);
        if (dueTime &amp;lt;= now) {
          scheduleFrameLocked(now);
        } else {
          ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将FrameCallback方法加入到mCallbackQueues[CALLBACK_ANIMATION]回调队列中。&lt;/p&gt;

</description>
        <pubDate>Thu, 12 Mar 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%BA%8C)/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/03/Flutter%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6-UI%E7%BA%BF%E7%A8%8B(%E4%BA%8C)/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
  </channel>
</rss>
