<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>拜伦的博客</title>
    <description>这里有关于iOS,机器学习的笔记心得,欢迎交流</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 02 Nov 2020 17:51:18 +0800</pubDate>
    <lastBuildDate>Mon, 02 Nov 2020 17:51:18 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>iOS 组件化方案选型</title>
        <description>&lt;h2 id=&quot;一组件化概念&quot;&gt;一、组件化概念&lt;/h2&gt;
&lt;h3 id=&quot;11项目状态&quot;&gt;1.1、项目状态&lt;/h3&gt;
&lt;p&gt;各模块直接调用，耦合严重。业务模块间划分不清晰，相互引用，模块之间耦合度很大，非常难维护。
所有模块代码都编写在一个项目中，测试某个模块或功能，需要编译运行整个项目，不能独立运行。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024733598436.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;12解决方案&quot;&gt;1.2、解决方案&lt;/h3&gt;
&lt;p&gt;所有的模块间的调用都会经过中间层中转(参考Router)，但是发现增加这个中间层后，耦合还是存在的。
中间层对被调用模块存在耦合，其他模块也需要耦合中间层才能发起调用。这样还是存在之前的相互耦合的问题，虽然可解决了统一调用的问题，而且本质上比之前更麻烦了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734216154.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;13正确的组件化解耦&quot;&gt;1.3、正确的组件化解耦&lt;/h3&gt;
&lt;p&gt;正确的解耦应该是，只让其他模块对中间层产生耦合关系，中间层不对其他模块发生耦合。
对于这个问题，可以采用组件化的架构，将每个模块作为一个组件。并且建立一个主项目，这个主项目负责集成所有组件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734534438.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二组件化主流方案&quot;&gt;二、组件化主流方案&lt;/h2&gt;
&lt;h3 id=&quot;21url-block-代表蘑菇街组件化方案mgjrouter&quot;&gt;2.1、url-block (代表：蘑菇街组件化方案MGJRouter)&lt;/h3&gt;
&lt;p&gt;蘑菇街通过&lt;code class=&quot;highlighter-rouge&quot;&gt;MGJRouter&lt;/code&gt;实现中间层，通过MGJRouter进行组件间的消息转发，从名字上来说更像是路由器。实现方式大致是，在提供服务的组件中提前注册block，然后在调用方组件中通过URL调用block，下面是调用方式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;架构设计
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024734970626.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MGJRouter组件化架构
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024735173869.png&quot; style=&quot;zoom=20%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MGJRouter是一个单例对象，在其内部维护着一个“URL -&amp;gt; block”格式的注册表，通过这个注册表来保存服务方注册的block，以及使调用方可以通过URL映射出block，并通过MGJRouter对服务方发起调用。&lt;/li&gt;
  &lt;li&gt;在程序开始运行时，需要将所有服务方的接口类实例化，以完成这个注册工作，使MGJRouter中所有服务方的block可以正常提供服务。在这个服务注册完成后，就可以被调用方调起并提供服务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.1.1 、MGJRouter调用，代码模拟对详情页的注册、调用，在调用过程中传递id参数。下面是注册的示例代码。&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter registerURLPattern:@&quot;mgj://detail?id=id&quot; toHandler:^(NSDictionary *routerParameters) {
// 下面可以在拿到参数后，为其他组件提供对应的服务
NSString uid = routerParameters[@&quot;id&quot;];
}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.1.2、通过openURL:方法传入的URL参数，对详情页已经注册的block方法发起调用。调用方式类似于GET请求，URL地址后面拼接参数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter openURL:@&quot;mgj://detail?id=404&quot;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.1.3、也可以通过字典方式传参，MGJRouter提供了带有字典参数的方法，这样就可以传递非字符串之外的其他类型参数。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[MGJRouter openURL:@&quot;mgj://detail?&quot; withParam:@{@&quot;id&quot; : @&quot;404&quot;}];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;短链管理这时候会发现一个问题，在蘑菇街组件化架构中，存在了很多硬编码的URL和参数。&lt;/li&gt;
  &lt;li&gt;在代码实现过程中URL编写出错会导致调用失败，而且参数是一个字典类型，调用方不知道服务方需要哪些参数，这些都是个问题。&lt;/li&gt;
  &lt;li&gt;对于这些数据的管理，蘑菇街开发了一个web页面，这个web页面统一来管理所有的URL和参数，Android和iOS都使用这一套URL，可以保持统一性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22protocol方案代表阿里的beehive&quot;&gt;2.2、Protocol方案(代表：阿里的BeeHive)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;面向接口调用，我们知道只要直接引用代码，就会有依赖，比如：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// A 模块
- (void)getSomeDataFromB {
B.getSomeData();
}
// B 模块
- (void)getSomeData {
return self.data;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;那么我们可以实现一个 getSomeDataFromB 的接口，让 A 只依赖这个接口，而 B 来实现这个接口，这样就实现了 A 与 B 的解耦。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 接口
@protocol BService &amp;lt;NSObject&amp;gt;
- (void)getSomeData;
@end
// A 模块, 只依赖接口
- (void)getSomeDataFromB {
id b = findService(@protocol(BService));
b.getSomeData;
}
// B 模块，实现BService接口
@interface B : NSObject &amp;lt;BService&amp;gt;
- (void)getSomeData {
return self.data;
}
@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样就可以实现了即满足了模块之间调用，也实现了解耦。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口类似代码，可以非常灵活的定义函数和回调等。&lt;/li&gt;
  &lt;li&gt;解决了硬编码的问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口定义文件需要放在一个模块以供依赖，但是这个模块不会贡献代码，所以还好。&lt;/li&gt;
  &lt;li&gt;使用较为麻烦，每个调用都需要定义一个service，并实现, 对于一些具有普适性规律的场景不太合适，比如页面统一跳转。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;BeeHive框架&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Module负责管理模块的注册和释放&lt;/li&gt;
  &lt;li&gt;Protocol负责公开组件开放的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201012/16024736500731.jpg&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;优势：扩展组件的生命周期，大厂开源 注意：BeeHive采用GPL开源协议，若有修改，不允许私有化，必须开源分享。&lt;/p&gt;

&lt;h3 id=&quot;23target-action方案casatwy组件化方案&quot;&gt;2.3、Target-Action方案(casatwy组件化方案)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.3.1、调用方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;整体架构casatwy组件化方案分为两种调用方式，远程调用和本地调用，对于两个不同的调用方式分别对应两个接口。&lt;/li&gt;
  &lt;li&gt;远程调用通过AppDelegate代理方法传递到当前应用后，调用远程接口并在内部做一些处理，处理完成后会在远程接口内部调用本地接口，以实现本地调用为远程调用服务。&lt;/li&gt;
  &lt;li&gt;本地调用由performTarget:action:params:方法负责，但调用方一般不直接调用performTarget:方法。CTMediator会对外提供明确参数和方法名的方法，在方法内部调用performTarget:方法和参数的转换。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.3.2、架构设计思路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;casatwy是通过CTMediator类实现组件化的，在此类中对外提供明确参数类型的接口，接口内部通过performTarget方法调用服务方组件的Target、Action。&lt;/li&gt;
  &lt;li&gt;由于CTMediator类的调用是通过runtime主动发现服务的，所以服务方对此类是完全解耦的。&lt;/li&gt;
  &lt;li&gt;但如果CTMediator类对外提供的方法都放在此类中，将会对CTMediator造成极大的负担和代码量。&lt;/li&gt;
  &lt;li&gt;解决方法就是对每个服务方组件创建一个CTMediator的Category，并将对服务方的performTarget调用放在对应的Category中，这些Category都属于CTMediator中间件，从而实现了感官上的接口分离。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2.3.3、casatwy组件化实现细节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;对于服务方的组件来说，每个组件都提供一个或多个Target类，在Target类中声明Action方法。&lt;/li&gt;
  &lt;li&gt;Target类是当前组件对外提供的一个“服务类”，Target将当前组件中所有的服务都定义在里面，CTMediator通过runtime主动发现服务。&lt;/li&gt;
  &lt;li&gt;在Target中的所有Action方法，都只有一个字典参数，所以可以传递的参数很灵活，这也是casatwy提出的去Model化的概念。&lt;/li&gt;
  &lt;li&gt;在Action的方法实现中，对传进来的字典参数进行解析，再调用组件内部的类和方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三组件化方案对比&quot;&gt;三、组件化方案对比&lt;/h2&gt;
&lt;h3 id=&quot;31url-block方式&quot;&gt;3.1、url-block方式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;硬编码问题，每个组件参数调用都需要查找对应。蘑菇街为此开发了一个web页面，这个web页面统一来管理所有的URL和参数。&lt;/li&gt;
  &lt;li&gt;需要在内存中维护url-block的表，组件多了可能会有内存问题。&lt;/li&gt;
  &lt;li&gt;url的参数传递受到限制，只能传递常规的字符串参数，无法传递非常规参数，如UIImage、NSData等类型。&lt;/li&gt;
  &lt;li&gt;没有区分本地调用和远程调用的情况，尤其是远程调用，会因为url参数受限，导致一些功能受限。&lt;/li&gt;
  &lt;li&gt;组件本身依赖了中间件，且分散注册使的耦合较多。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32protocol方案&quot;&gt;3.2、Protocol方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;0硬编码，代码可读性高;&lt;/li&gt;
  &lt;li&gt;Protocol方案需要在启动的时候向ProtocolManager注册，侵入较大。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;33target_action方案&quot;&gt;3.3、Target_Action方案&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;侵入最小，但硬编码较多。&lt;/li&gt;
  &lt;li&gt;runtime编译阶段不检查,运行时才检查对应类或者方法是否存在，对开发要求较高。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四组件化实现原则&quot;&gt;四、组件化实现原则&lt;/h2&gt;
&lt;h3 id=&quot;41抽象化原则&quot;&gt;4.1、抽象化原则&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;越底层的模块，应该越稳定，越抽象，越具有高复用度。&lt;/li&gt;
  &lt;li&gt;稳定的最直观表现就是API很久都不用变化，所有的变化因子不要暴露出来，避免传递给依赖它的模块。&lt;/li&gt;
  &lt;li&gt;但是要做到设计一套API很久都不用改变，那么就需要设计的时候能越抽象, 即需要我们抽象总结的能力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42稳定性原则&quot;&gt;4.2、稳定性原则&lt;/h3&gt;
&lt;p&gt;不要让稳定的模块依赖不稳定的模块， 减少依赖，稳定性 还有一个特点就是会传递，比如 B 模块依赖了 A 模块，如果 B 模块很稳定，但是 A 模块不稳定，那么B模块也会变的不稳定了。&lt;/p&gt;

&lt;h3 id=&quot;43自备性完整&quot;&gt;4.3、自备性完整&lt;/h3&gt;
&lt;p&gt;提升模块的复用度，自完备性有时候要优于代码复用；什么是自完备性，就是尽可能的依赖少的模块来达到代码可复用；我有个模块 Utils 里面放了大量的category工具方法等，在日常UI产品开发中，依赖这个Utils会很方便，但是我现在要写一个比较基础的模块，应该就要求复用度更高一些，这个时候需要用到Utils里面的几个方法，那这个时候还适合直接依赖Utils吗，当然不合适了，这与我们上面的设计原则相悖了啊，因此我们这时候为了这个模块的自完备性，就可以重新实现下这几个方法，而不是依赖Utils模块。&lt;/p&gt;

&lt;h3 id=&quot;44不要让common出现&quot;&gt;4.4、不要让Common出现&lt;/h3&gt;
&lt;p&gt;每个模块只做好一件事情，不要让Common出现，按照你架构的层数从上到下依赖，不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合。&lt;/p&gt;

&lt;h3 id=&quot;45业务模块真正解耦&quot;&gt;4.5、业务模块真正解耦&lt;/h3&gt;
&lt;p&gt;为什么要解耦吧，模块化并不是说你把工程的代码拆分成 50 个 pod 或者framework就算完事了，要实现模块之间真正的解耦才算真正的模块化，否则如果模块之间还都是互相调用代码，循环依赖，那么和原本放文件夹里面没啥两样。那么什么是模块间的解耦呢？模块解耦的目标就是, 在基于模块设计原则上, 让模块之间没有循环依赖, 让业务模块之间解除依赖。&lt;/p&gt;

&lt;h3 id=&quot;46单向依赖&quot;&gt;4.6、单向依赖&lt;/h3&gt;
&lt;p&gt;基础模块下沉，这块其实还是讲的模块设计，一个工程的架构可能会分为很多层，然而在开发的过程中，很容易有人不注意让应该处于较底层的模块依赖了上层的模块，这种情况下应该对模块的设计进行改造实现单向依赖。&lt;/p&gt;

&lt;h2 id=&quot;五组件化具体实施步骤&quot;&gt;五、组件化具体实施步骤&lt;/h2&gt;
&lt;h3 id=&quot;51组件化第一步剥离产品公共库和基础库&quot;&gt;5.1、组件化第一步，剥离产品公共库和基础库&lt;/h3&gt;
&lt;p&gt;包括组件中间件，网络请求，第三方SDK管理封装，WebView(封装js，且以服务形式提供)，自定义键盘，UI基础组件，分类。然后在项目里用pod进行管理。其中，针对三方库，最好再封装一层，使我们的项目不直接依赖三方库，方便后续开发过程中的更换。&lt;/p&gt;

&lt;h3 id=&quot;52组件化第二步独立业务模块单独成库&quot;&gt;5.2、组件化第二步，独立业务模块单独成库&lt;/h3&gt;
&lt;p&gt;拆分粒度可以先粗后细，将相对独立的组件拆分出来。在开发过程中，对一些独立的模块，如：登录模块、账户模块等等，也可以封装成组件，因为这些组件是项目强依赖的，调用的频次比较多。另外，在拆分组件化的过程中，拆分的粒度要合适，尽量做到组件的独立性。同时，组件化是一个渐进的过程，不可能把一个完整的工程一下子全部组件化，要分步进行，通过不停的迭代，来最终实现项目的组件化。&lt;/p&gt;

&lt;h3 id=&quot;53组件化第三步对外服务最小化&quot;&gt;5.3、组件化第三步，对外服务最小化&lt;/h3&gt;
&lt;p&gt;在前两步都完成的情况下，我们可以根据组件被调用的需求来抽象出组件对外的最小化接口。&lt;/p&gt;

</description>
        <pubDate>Mon, 12 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS-%E7%BB%84%E4%BB%B6%E5%8C%96%E6%96%B9%E6%A1%88%E9%80%89%E5%9E%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(8)- 性能优化</title>
        <description>&lt;h3 id=&quot;减少卡顿&quot;&gt;减少卡顿&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;尽量减少视图数量和层次&lt;/li&gt;
  &lt;li&gt;减少透明的视图&lt;/li&gt;
  &lt;li&gt;尽量避免出现离屏渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;离屏渲染&quot;&gt;离屏渲染&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果要在显示屏上显示内容，我们至少需要一块与屏幕像素数据量一样大的frame buffer，作为像素数据存储区域，而这也是GPU存储渲染结果的地方。
如果有时因为面临一些限制，无法把渲染结果直接写入frame buffer，而是先暂存在另外的内存区域，之后再写入frame buffer，那么这个过程被称之为离屏渲染。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;GPU离屏渲染：采用画家算法，把每一层依次输出到画布，如果父layer剪裁成圆角，容器子layer因为父容器有圆角，也要被剪裁，但这时还在渲染队列中，此时需要在新内存中，把容器以及子layer依次画好，剪裁完成，再放到&lt;code class=&quot;highlighter-rouge&quot;&gt;frame buffer&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&quot;消耗性能原因&quot;&gt;消耗性能原因&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;需要创建新的缓冲区&lt;/li&gt;
  &lt;li&gt;整个过程需要多次切换上下文环境，从&lt;code class=&quot;highlighter-rouge&quot;&gt;on-screen&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;off-screen&lt;/code&gt;，等渲染结束后，将离屏缓冲区结果显示到屏幕上，再讲上下文从&lt;code class=&quot;highlighter-rouge&quot;&gt;off-screen&lt;/code&gt;切换到&lt;code class=&quot;highlighter-rouge&quot;&gt;on-screen&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;哪些会触发离屏渲染&quot;&gt;哪些会触发离屏渲染&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;光栅化   &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shouldRasterize= YES&lt;/code&gt;。 隐式的创建一个位图，各种阴影遮罩效果保存在位图中缓存，如果对应的layer极其sublayers没有发生改变，在下一帧的时候可以直接复用，减少渲染频率。但是否有助于优化性能取决于缓存的位图是否被有效复用。&lt;/li&gt;
  &lt;li&gt;遮罩   &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.mask&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;圆角   同时设置&lt;code class=&quot;highlighter-rouge&quot;&gt;layer.maskToBounds = YES&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.cornerRadius &amp;gt;0&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;阴影 &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shadowoffset...&lt;/code&gt;,    但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;layer.shadowPath&lt;/code&gt;不会产生离屏渲染&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;卡顿检测&quot;&gt;卡顿检测&lt;/h3&gt;
&lt;p&gt;通过使用监听 runloop的状态切换的耗时达到监控卡顿的目的&lt;/p&gt;

&lt;h3 id=&quot;app启动优化&quot;&gt;APP启动优化&lt;/h3&gt;
&lt;p&gt;启动分为3大阶段&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyld(dynamic link editor)&lt;/code&gt; 动态链接，装在Mach-O文件
    &lt;ul&gt;
      &lt;li&gt;装在APP可执行文件，递归加载所有依赖的动态库&lt;/li&gt;
      &lt;li&gt;都完毕后，通知runtime进行下一步处理&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;map_images&lt;/code&gt; 进行执行文件内容的解析和处理&lt;/li&gt;
      &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;load_images&lt;/code&gt;中调用&lt;code class=&quot;highlighter-rouge&quot;&gt;call_load_methods&lt;/code&gt;， 调用所有class和&lt;code class=&quot;highlighter-rouge&quot;&gt;category&lt;/code&gt;的 &lt;code class=&quot;highlighter-rouge&quot;&gt;+load&lt;/code&gt;方法&lt;/li&gt;
      &lt;li&gt;进行objc结构初始化，注册类，初始化对象等&lt;/li&gt;
      &lt;li&gt;可执行文件和动态库中所有符号Class,Protocol, Selctor, IMP 都已经加载完成&lt;/li&gt;
      &lt;li&gt;调用Main函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationMain&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;didFinishLaunchingWithOptions&lt;/code&gt;方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;优化方案：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyld&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;减少动态库，合并动态库&lt;/li&gt;
      &lt;li&gt;减少Objc类，分类的数量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;runtime&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;+initialize&lt;/code&gt;方法和dispath_once代替+load方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;按需加载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更多详细优化方案见&lt;a href=&quot;https://byronjia.github.io/2020/09/iOS-%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E8%80%97%E6%97%B6%E5%88%86%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96/&quot;&gt;iOS 应用启动耗时分析及优化&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(8)-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(8)-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(7)- 内存管理</title>
        <description>&lt;h2 id=&quot;浅拷贝和深拷贝&quot;&gt;浅拷贝和深拷贝&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;拷贝的最终目的是产生一个副本，修改副本不会对原对象产生影响。故到底是深拷贝还是浅拷贝要根据这个规则来判断。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;[任意对象 copy] 产生一个不可变对象，如果原对象是不可变对象，那么就是浅拷贝，因为不可变对象本身就不能修改，所以没必要创新分配内存。原对象是可变对象，就是深拷贝。&lt;/li&gt;
  &lt;li&gt;[任意对象 mutableCopy] 产生一个可变对象，不论原对象是否是可变对象，都是深拷贝，因为要产生修改不影响原对象的副本，必须重新分配内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208497217.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;定义属性时使用copy修饰词，目的是在赋值之后产生一个不可变对象，那么在修改外部变量的时候不影响内部，例如UI控件的text都是copy修饰，防止外部修改影响内部实现。&lt;/p&gt;

&lt;h2 id=&quot;cadisplaylink-和-nstimer使用问题&quot;&gt;CADisplayLink 和 NSTimer使用问题&lt;/h2&gt;
&lt;p&gt;会对target 强引用，如果target也强引用他们，就发生循环引用问题
解决方法是使用NSProxy，是和NSObject同一级别的基类，但是没有实现和声明多余的方法，只有alloc等。
作用是只要方法列表里找不到方法，跳过动态方法解析，直接做转发。且NXProxy中弱引用target即可。&lt;/p&gt;

&lt;h2 id=&quot;内存布局&quot;&gt;内存布局&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208614585.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tagged-pointer&quot;&gt;Tagged Pointer&lt;/h2&gt;
&lt;p&gt;从64位开始引入，目的是优化NSNumber, NSDate， NSString等小对象的存储，提高内存使用率&lt;br /&gt;
原来NSNumber占用一个对象的空间，指针还指向堆地址的值，最终可能只是为了存一个3。 就浪费很大空间&lt;/p&gt;

&lt;p&gt;在使用Tagged pointer技术后，NSNumber 3的地址0x327, Tag+Data 的形式存储，从地址就能读到真实值，不需要额外空间。当内存地址长度超过64位后，才使用动态分配内存的方式存储数据。&lt;/p&gt;

&lt;p&gt;如果地址最低有效位是1， 则是Tagged pointer&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; ： 字符串想要使用tagged pointer, 初始化要用&lt;code class=&quot;highlighter-rouge&quot;&gt;[NSString stringWithFormat:]&lt;/code&gt;，如果是@”xx”创建的是常规对象存在常量区。&lt;/p&gt;
&lt;h2 id=&quot;引用计数管理&quot;&gt;引用计数管理&lt;/h2&gt;
&lt;p&gt;新建OC对象引用计数默认是1，当调用alloc,new,copy,mutableCopy时对象引用计数会+1&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引用计数存储&lt;/strong&gt;：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208775066.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在64位优化后的isa共用体结构中，引用计数=extra_rc + sidetable_rc.refcnts[self].count,不是每个对象都会使用sidetable_rc,要看isa的标志位has_sidetable_rc.  &lt;br /&gt;
如果isa不是共用体结构，引用计数=sidetable_rc.refcnts[self].count
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023208883784.png&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;refcnts是一个散列表，使用对象的地址为key,value为引用计数。
获取引用计数、retain、release操作都是获取extra_rc的值+sidetable的值+1或-1. 如果是release则判断是否为0，为0就dealloc。&lt;/p&gt;

&lt;h2 id=&quot;weak-指针原理&quot;&gt;weak 指针原理&lt;/h2&gt;
&lt;p&gt;__weak: 弱引用对象，当对象销毁时指针置为空&lt;br /&gt;
__unsafe_unretain: 弱引用对象，当对象销毁时，指针不变，使用会发生坏内存访问&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;weak能在对象销毁置为空的原理：&lt;/strong&gt;
当自动调用dealloc方法时，判断是否有弱引用和&lt;code class=&quot;highlighter-rouge&quot;&gt;sidetable_rc&lt;/code&gt;,（弱引用和超过计数器时都使用到了sidetable），有弱引用就将sidetable中自己对应的value取出来，得到一个__weak对象的地址集合(不确定是不是数组，因为用到C++的遍历器)， 并遍历将其置为nil
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209058628.png&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;自动释放池&quot;&gt;自动释放池&lt;/h2&gt;
&lt;p&gt;主要通过AutoreleasePoolPage来管理，结构如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023209189251.png&quot; alt=&quot;6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在@autoreleasePool代码开始时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;AutoreleasePoolPage&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Push&lt;/code&gt;方法，将&lt;code class=&quot;highlighter-rouge&quot;&gt;BOUNDARY&lt;/code&gt; 添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，标记为开始，后续调用&lt;code class=&quot;highlighter-rouge&quot;&gt;autorelease&lt;/code&gt;的对象也会添加到该&lt;code class=&quot;highlighter-rouge&quot;&gt;Page&lt;/code&gt;中，在括号结束时，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Pop&lt;/code&gt;方法时传入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;的内存地址，会从最后一个入栈的对象开始发送&lt;code class=&quot;highlighter-rouge&quot;&gt;release&lt;/code&gt;消息，直到遇到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;POOL_BOUNDARY&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;对象释放时机&quot;&gt;对象释放时机&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MRC&lt;/strong&gt;: 对象创建时调用了autorelease方法   &lt;br /&gt;
系统在主线程的Runloop中注册了2个Observer,1个监听kCFRunLoopEntry时间，调用objc_autoreleasePoolPush()。另一个监听kCFRunLoopBeforeWaiting事件，调用objc_autoreleasePoolPop()、objc_autoreleasePoolPush()。
监听kCFRunLoopBeforeExit事件调用objc_autoreleasePoolPop() &lt;br /&gt;
例如：viewdidload和viewwillappear 在一个loop中，即一次执行所有的block和sources，直到执行完毕loop睡眠，在睡眠之前会释放对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ARC&lt;/strong&gt;:
在括号结束时，LLVM编译器自动给对象release一次，而不是在runloop中执行。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(7)-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(6)- runLoop &amp; 多线程</title>
        <description>&lt;h2 id=&quot;runloop&quot;&gt;runloop&lt;/h2&gt;
&lt;h3 id=&quot;常见类型&quot;&gt;常见类型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;runloop&lt;/strong&gt; 和线程一一对应，子线程默认不开启runloop,当第一次获取runloop时就会创建runloop。存在全局map中，key是线程，value是runloop&lt;/p&gt;

&lt;p&gt;runloopModel结构体如下
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023184791593.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;常见2种Mode:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kCFRunLoopDefaultMode&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;NSDefaultRunLoopMode&lt;/code&gt;）：App的默认Mode，通常主线程是在这个Mode下运行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UITrackingRunLoopMode&lt;/code&gt;：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;目的是不同组的&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;能分隔开来，互不影响，处理不同的事件，只能同一时间运行一种模式&lt;/p&gt;

&lt;h3 id=&quot;线程保活&quot;&gt;线程保活&lt;/h3&gt;

&lt;p&gt;一般线程启动后，如果事情做完会直接销毁，因为启动runloop 如果Mode里没有任何&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Observer&lt;/code&gt;，RunLoop会立马退出。 唯一办法是在runloop中添加前面所说的几个事件。
做法：
在当前线程中调用以下代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSRunLoop currentRunLoop] addPort:[[NSPort alloc] init]   forMode:NSDefaultRunLoopMode];
while (1){
    [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样添加一个port的 &lt;code class=&quot;highlighter-rouge&quot;&gt;source1&lt;/code&gt; 事件，并启动本次runMode, 一旦响应一次事件后本次会结束，所以需要while 运行runModel 。其实就是阻塞了当前runloop的一个事件，导致后续事件无法运行，以此保证runloop和线程的存活&lt;/p&gt;

&lt;h2 id=&quot;多线程&quot;&gt;多线程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185008204.png&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;线程死锁&quot;&gt;线程死锁&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt;函数往当前串行队列中添加任务，会卡住当前的串行队列（产生死锁)&lt;/strong&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;performSelector:withObject:afterDelay: &lt;/code&gt;方法是用你NSTimer实现定时，且是加在当前线程runloop中，但是如果当前是&lt;code class=&quot;highlighter-rouge&quot;&gt;asyn&lt;/code&gt;产生的线程runloop没启动的话这种方法无效。需要手动启动&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;线程锁&quot;&gt;线程锁&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OSSpinLock&lt;/code&gt; 自旋锁，一直处于忙等状态&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;os_unfair_lock&lt;/code&gt; 互斥锁，等待锁的线程处于休眠状态，节省资源&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185133777.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt; 互斥锁，等待锁的线程处于休眠状态
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185345005.jpg&quot; alt=&quot;4&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;的条件锁
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023185451423.jpg&quot; alt=&quot;5&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSLock&lt;/code&gt;  对于pthread_mutex的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSRecursiveLock&lt;/code&gt;  对于pthread_mutex的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt;  对于pthread_mutex 和 condition的OC封装&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_queue(DISPATCH_QUEUE_SERIAL)&lt;/code&gt; 把不同线程的任务放在同步队列中执行，能达到锁的效果&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_semaphore&lt;/code&gt; 信号量， 初始化赋一个最多同时执行线程数量，如果是1就实现了锁的效果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;锁都是由于不同线程的问题导致的，如果条件锁在一个线程有wait，没有其他线程signal,就会永远睡眠下去。wait后的代码不会执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;队列和线程是2个概念，队列中的任务可以在不同的线程中去执行。例如用globalQueue来创建不同的线程任务，所以可以使用串行队列来实现线程锁的问题，只要保证任务都加入到队列中执行即可&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;atomic 用于保证setter、 getter的操作原子性，在方法内部加上线程同步锁&lt;/p&gt;

&lt;h3 id=&quot;读写安全方案-保证同一时间只有一个线程写可以多个线程读不能同时读写&quot;&gt;读写安全方案 ,保证同一时间只有一个线程写，可以多个线程读，不能同时读写&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_rwlock&lt;/code&gt; 读写锁&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_barrier_async&lt;/code&gt; 异步栅栏调用
  &lt;code class=&quot;highlighter-rouge&quot;&gt;dispatch_asyn(que)&lt;/code&gt; 用于读操作
  &lt;code class=&quot;highlighter-rouge&quot;&gt;diapatch_barrier_async(que)&lt;/code&gt; 用于写操作，可以保证当前队列中只有栅栏中的任务在执行，其他全部暂停。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uievent-uitouch-uiresponder-和-uicontrol&quot;&gt;UIEvent 、UITouch 、UIResponder 和 UIControl&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;触摸事件的传递：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;电容屏幕检测到电流变化，定位得到触摸点，生成&lt;code class=&quot;highlighter-rouge&quot;&gt;Touch Event&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IOKit.framework&lt;/code&gt;处理&lt;code class=&quot;highlighter-rouge&quot;&gt;Touch Event&lt;/code&gt;,并封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;IOHIDEvent&lt;/code&gt;对象，通过内核的&lt;code class=&quot;highlighter-rouge&quot;&gt;mach port&lt;/code&gt;机制，传递为window上当前app的主线程&lt;/li&gt;
  &lt;li&gt;app主线程&lt;code class=&quot;highlighter-rouge&quot;&gt;runloop&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;mach port&lt;/code&gt;监听的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;IOHIDEvent&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;Source1&lt;/code&gt;事件，内部进一步分发为&lt;code class=&quot;highlighter-rouge&quot;&gt;Source0&lt;/code&gt;，Source0事件是自定义的，非基于端口port,包括触摸，滚动，selector事件，并封装为&lt;code class=&quot;highlighter-rouge&quot;&gt;UIEvent&lt;/code&gt;事件， 通过&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication&lt;/code&gt;对象&lt;code class=&quot;highlighter-rouge&quot;&gt;sendEvent&lt;/code&gt;方法传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt;判断最佳响应者&lt;/li&gt;
  &lt;li&gt;Hit-Testing寻找最佳响应者，自下而上传递，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication -&amp;gt; UIWindow -&amp;gt; 子视图 -&amp;gt; ...-&amp;gt;子视图中的子视图&lt;/code&gt;;即响应链&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;UIEvent&lt;/strong&gt;: 代表一个单一类型的UIKit事件，可以是触摸，震动，按压等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UITouch&lt;/strong&gt;:一次触摸生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;UITouch&lt;/code&gt;,例如滑动由多个&lt;code class=&quot;highlighter-rouge&quot;&gt;UITouch&lt;/code&gt;组合，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;UIEvent&lt;/code&gt;里包含多个触摸对象，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;allTouches&lt;/code&gt;获取。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UIResponder&lt;/strong&gt;: 继承&lt;code class=&quot;highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;的实例对象可以对随机事件进行相应处理,例如&lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIWindow&lt;/code&gt;、 &lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplication&lt;/code&gt; 和&lt;code class=&quot;highlighter-rouge&quot;&gt;UIApplicationDelegate&lt;/code&gt;, 默认实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesBegin&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesMove&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesEnded&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;touchesCancelled&lt;/code&gt;四个方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UIControl&lt;/strong&gt;:继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;UIResponder&lt;/code&gt;, 能够以&lt;code class=&quot;highlighter-rouge&quot;&gt;target-action&lt;/code&gt;模式处理触摸事件，有&lt;code class=&quot;highlighter-rouge&quot;&gt;addTarget:action:forControlEvent:&lt;/code&gt;方法，保存&lt;code class=&quot;highlighter-rouge&quot;&gt;target-action&lt;/code&gt;到字典中，在接收到相应Event事件时取出对应action执行。&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(6)runLoop-&-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(6)runLoop-&-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(5)-Block</title>
        <description>&lt;h2 id=&quot;block本质&quot;&gt;Block本质&lt;/h2&gt;
&lt;p&gt;本质是一个OC对象，编译之后是一个结构体包含isa指针，block中封装了调用的函数和调用环境。调用环境值&lt;code class=&quot;highlighter-rouge&quot;&gt;variables&lt;/code&gt;是block捕获的变量(如果block中访问了一些需要被捕获的变量，例如局部变量)
block的变量捕获机制：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;局部变量， &lt;code class=&quot;highlighter-rouge&quot;&gt;auto&lt;/code&gt;临时变量会捕获到block内部，且用的值传递。&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 会捕获，用的指针传递。&lt;/li&gt;
  &lt;li&gt;全局变量，不会捕获，block运行的时候会直接访问&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;auto临时变量代表 autorelease的在一个作用域内的临时变量&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098593774.png&quot; alt=&quot;1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中FuncPtr指的block函数的指针。 
block分为3种类型，分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSGlobalBlock__&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSStackBlock__&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;__NSMallocBlock__&lt;/code&gt;，分为位于以下内存区域，那么什么样的block会属于什么样的类型？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098896250.jpg&quot; alt=&quot;2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023098896265.png&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图表示不同的block因为操作的变量类型不一样，所以block类型也不一样。因为auto变量是临时变量会存在&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;中自动销毁，所以相应block就是&lt;code class=&quot;highlighter-rouge&quot;&gt;stack&lt;/code&gt;。没访问auto变量则存在常量区&lt;code class=&quot;highlighter-rouge&quot;&gt;global&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;为什么block用copy修饰&quot;&gt;为什么block用copy修饰？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;由于&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stackblock&lt;/code&gt;在栈中，且捕获的是在栈中的变量，如果变量销毁，有可能block访问的就的数据就是野指针，&lt;strong&gt;所以&lt;/strong&gt;需要将&lt;code class=&quot;highlighter-rouge&quot;&gt;stackblock&lt;/code&gt;通过调用&lt;strong&gt;copy&lt;/strong&gt;方法转为&lt;code class=&quot;highlighter-rouge&quot;&gt;mallocblock&lt;/code&gt;即保存到堆中，保证由用户自己创建自己销毁，不会造成程序异常。所以block变量用&lt;strong&gt;copy&lt;/strong&gt;修饰或者直接调用&lt;strong&gt;copy&lt;/strong&gt;方法&lt;/p&gt;

&lt;h2 id=&quot;block如果捕获变量&quot;&gt;block如果捕获变量&lt;/h2&gt;
&lt;p&gt;当block内部访问了对象类型的auto变量时：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果block在栈上，则不会对auto变量强引用&lt;/li&gt;
  &lt;li&gt;如果block被拷贝到堆上：会调用block内部的copy函数（&lt;code class=&quot;highlighter-rouge&quot;&gt;__block_object_assgin&lt;/code&gt;），会根据对象的修饰符__strong, __weak等作出强引用或弱引用&lt;/li&gt;
  &lt;li&gt;如果block从堆上移除：调用block内部dispose函数，对变量release&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;__block与__weak__strong&quot;&gt;__block与__weak、__strong&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__block&lt;/code&gt;修饰一个变量会把他包装成一个结构体对象，其中的一个属性就是这个变量。且这个结构体对象会把捕获的对象进行引用，根据对象前面是否使用&lt;code class=&quot;highlighter-rouge&quot;&gt;__weak&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;__strong&lt;/code&gt; 决定是弱引用还是强引用。
block中的&lt;code class=&quot;highlighter-rouge&quot;&gt;forwarding&lt;/code&gt;指针是指向自己位于堆中的地址，如果修饰的是对象，block中还会增加2个内存管理方法,&lt;code class=&quot;highlighter-rouge&quot;&gt;copy&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;dispose&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;__weak 和 __strong 目的是在变量被block捕获的时候以什么引用方式。&lt;/p&gt;

&lt;h2 id=&quot;循环引用问题&quot;&gt;循环引用问题：&lt;/h2&gt;
&lt;p&gt;对象 强引用 block; block  强引用  对象 导致无法释放， 解决办法是将其中一条链路变为弱引用，则能完成释放。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(5)-Block/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(5)-Block/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(4)-方法调用机制</title>
        <description>&lt;h2 id=&quot;消息发送objc_msgsend&quot;&gt;消息发送objc_msgSend()&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;缓存中查找方法，找到了直接调用&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;class_rw_t&lt;/code&gt;方法列表中查找，找到了缓存到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，再调用&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;superClass&lt;/code&gt; 缓存中查找，找到了缓存到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，再调用&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;superClass class_rw_t&lt;/code&gt;方法列表中查找，找到了缓存到&lt;code class=&quot;highlighter-rouge&quot;&gt;cache&lt;/code&gt;，再调用&lt;/li&gt;
  &lt;li&gt;递归父类查找，直到父类为空，执行下一步动态方法解析&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态方法解析&quot;&gt;动态方法解析&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;若未动态解析过，则调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;resolveInstanceMethod:  &lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;resolveClassMethod:&lt;/code&gt; 来完成方法添加&lt;/li&gt;
  &lt;li&gt;不管有没有实现，都会再次走上一步的方法查找
    &lt;ul&gt;
      &lt;li&gt;若找到则执行并结束&lt;/li&gt;
      &lt;li&gt;没找到则执行下一步消息转发&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;消息转发&quot;&gt;消息转发&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;forwardingTargetForSelector:&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;不为空则走&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend&lt;/code&gt; 向转发的对象发送消息调用&lt;/li&gt;
      &lt;li&gt;返回值为nil,调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;methodSignatureForSelector&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;methodSignatureForSelector&lt;/code&gt; 返回为空 则crash&lt;/li&gt;
  &lt;li&gt;不为空则调用 ForwardInvocation方法，在里面可以手动invoca和获取修改invoca的所有属性，包括target，methodSignature，selector&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;super-关键字&quot;&gt;super 关键字&lt;/h2&gt;
&lt;p&gt;[self class] 与 [super class] 结果一样，因为super关键字底层实现是调用
&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSendSuper({self, class_getSuperClass('selfClass')}&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;sel_registerName('class'))&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSendSuper&lt;/code&gt;意义是从父类开始查找class方法，但是方法接收者还是self, 所以才能实现跳过自己，直接调用父类的方法。
class方法的实现是objc_getClass(self), 因为前面接收者是self,所以方法实现里的参数还是自己，那么打印出来就是一样的。&lt;/p&gt;
</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(4)-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(4)-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(3)-KVC &amp; KVO</title>
        <description>&lt;h2 id=&quot;kvo&quot;&gt;KVO&lt;/h2&gt;
&lt;p&gt;Person 类的对象p 注册监听。
原理：注册监听后，系统利用runtime动态生成一个新的子类&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_Person&lt;/code&gt;对象，且将&lt;code class=&quot;highlighter-rouge&quot;&gt;p-&amp;gt;isa = NSKVONotifying_Person&lt;/code&gt;. 新的类重写set方法和class方法。
在set方法中，先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;willChangeValueForKey&lt;/code&gt;, 然后赋值，最后&lt;code class=&quot;highlighter-rouge&quot;&gt;didChangeValueForKey&lt;/code&gt;出发监听的方法。
&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_Person -&amp;gt;superClass = Person&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;NSKVONotifying_Person-&amp;gt;isa = meta-NSKVONotifying_Person&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;想手动调用监听方法：可以先调用&lt;code class=&quot;highlighter-rouge&quot;&gt;willChangeValueForKey&lt;/code&gt;, 再调用&lt;code class=&quot;highlighter-rouge&quot;&gt;didChangeValueForKey&lt;/code&gt;即可&lt;/p&gt;

&lt;h2 id=&quot;kvc&quot;&gt;KVC&lt;/h2&gt;
&lt;p&gt;下图是KVC获取属性和设置属性的调用原理图，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;[p setValue:21 forKey:@“age”]&lt;/code&gt;,找到set方法，因为声明了一个age属性，所以通过setAge方法找到，并赋值后触发监听。如果没有age属性，则不会触发监听。
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023005369387.png&quot; alt=&quot;截屏2020-10-09 下午2.55.25&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16023005401951.png&quot; alt=&quot;截屏2020-10-09 下午2.55.32&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(3)-KVC-&-KVO/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(3)-KVC-&-KVO/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(2)-Category类别 &amp; 关联对象</title>
        <description>&lt;h2 id=&quot;category&quot;&gt;Category&lt;/h2&gt;
&lt;p&gt;分类在编译的时候变成&lt;code class=&quot;highlighter-rouge&quot;&gt;category_t&lt;/code&gt; 结构体，其中包含所有方法，协议，属性等。
运行的时候把Category数组合并到Class的大数组中，后面参与编译的在数组的前面，也解释了为什么类别能够覆盖主类的方法，因为在方法查找时先找到类别的方法而已。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+laod()&lt;/code&gt;是在app启动时加载类、分类的时候调用。
调用原理与普通的category方法不同，是直接按照主类，类别的方法调用专门存取load方法的指针来调用load方法，即调用顺序一定是主类，分类1，分类2。。。而且如果父类还未load，先调用父类load。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;+initialize()&lt;/code&gt;在类第一次接受消息时调用。且方法是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_msgSend()&lt;/code&gt;方法调用，则会从大数组中寻找方法，找到第一个肯定是类别的方法，则调用完毕结束。若父类还未初始化，则先调用父类initialize&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;关联对象&quot;&gt;关联对象&lt;/h2&gt;
&lt;p&gt;可以使用runtime的关联对象给categoty添加成员变量，&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_setAssociatedObject&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;objc_getAssociatedObject&lt;/code&gt;,其中key的参数很重要，必须是不变的一个地址，有多种实现方式，可以用静态变量例如@“key”, 因为存在常量区，所以地址不变。可以用&lt;code class=&quot;highlighter-rouge&quot;&gt;static void * KEYNAEM = &amp;amp;KEYNAME&lt;/code&gt;， 取出定义的全局变量的指针用作key&lt;/p&gt;

&lt;p&gt;原理: 全局保存一个&lt;code class=&quot;highlighter-rouge&quot;&gt;AssociationsManager&lt;/code&gt;，和其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;hashMap&lt;/code&gt;,保存所有的对象和对象需要监听的属性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201010/16022999875266.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 10 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(2)-Category%E7%B1%BB%E5%88%AB-&-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(2)-Category%E7%B1%BB%E5%88%AB-&-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS底层(1)-Class &amp; isa</title>
        <description>&lt;h2 id=&quot;类初始化内存分配&quot;&gt;类初始化内存分配&lt;/h2&gt;
&lt;p&gt;NSObject占用内存大小为16个字节，但是NSObjct只有一个属性就是isa只占用8个字节，由于底层设计原因最少需要16个字节。&lt;br /&gt;
结构体内存对齐，(x+7)&amp;amp; ~x 是将x按照8字节对齐。不满8就补齐8字节
malloc 中的内存分配也会有内存对齐规则，mac中是16的倍数，如果传入只需要24字节，alloc后系统会分配32个字节空间即内存对齐。 &lt;br /&gt;
class_getInstanceSize 返回的是对象需要的内存， NSObjcet中的isa占用8， 加上继承来的每个属性的空间。
malloc_size 返回的是实际分配的空间大小&lt;/p&gt;

&lt;h2 id=&quot;oc中的对象类型&quot;&gt;OC中的对象类型&lt;/h2&gt;
&lt;p&gt;分为3种&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;实例对象
    &lt;ul&gt;
      &lt;li&gt;isa&lt;/li&gt;
      &lt;li&gt;成员变量值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;类对象
    &lt;ul&gt;
      &lt;li&gt;isa&lt;/li&gt;
      &lt;li&gt;superclass&lt;/li&gt;
      &lt;li&gt;属性、对象方法、协议、成员变量&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;元类对象
    &lt;ul&gt;
      &lt;li&gt;isa&lt;/li&gt;
      &lt;li&gt;superclass&lt;/li&gt;
      &lt;li&gt;类方法&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类对象是由元类对象描述的，即class-&amp;gt;isa = metaclass, 但是二者结构一致，只是存储的数据不同。    &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;object_getClass(id)&lt;/code&gt; 传入是对象，则返回类对象，传入是类对象，返回元类对象
&lt;code class=&quot;highlighter-rouge&quot;&gt;objc_getClass(char * className)&lt;/code&gt; 只会返回类对象。&lt;/p&gt;

&lt;h2 id=&quot;对象之间的关系&quot;&gt;对象之间的关系&lt;/h2&gt;
&lt;p&gt;有3个类 NSObjcect -&amp;gt; Person -&amp;gt; Student，
&lt;code class=&quot;highlighter-rouge&quot;&gt;[stu studentInstanceMethod];&lt;/code&gt; stu-&amp;gt;isa = Student类寻找对象方法来执行
&lt;code class=&quot;highlighter-rouge&quot;&gt;[stu personInstanceMethod]; &lt;/code&gt; stu-&amp;gt;isa = Student-&amp;gt;superClass = Person寻找对象方法
&lt;code class=&quot;highlighter-rouge&quot;&gt;[stu load]; &lt;/code&gt;stu-&amp;gt;isa = Student-&amp;gt;superClass = Person-&amp;gt;superClass = NSObject寻找对象方法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[Student studentClassMethod];&lt;/code&gt; Student-&amp;gt;isa = Meta_Student 寻找Student的类方法   &lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[Student personClassMethod];&lt;/code&gt; Student-&amp;gt;isa = Meta_Student-&amp;gt;superclass = Meta_Person 寻找person的类方法&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;[Student copy]; &lt;/code&gt;Student-&amp;gt;isa = Meta_Student-&amp;gt;superclass = Meta_Person-&amp;gt;superclass=Meta_NSObject 寻找NSObject的类方法   &lt;br /&gt;
一旦中途找到，则停止后续寻找，这就是为什么override会覆盖父类同名方法&lt;/p&gt;

&lt;p&gt;isa指针地址需要&amp;amp; isa_mask才能得到真实的class的地址
superClass地址 直接就是真实superclass地址
&lt;strong&gt;总结&lt;/strong&gt;
instance调用实例方法轨迹
isa找到class,方法不存在，就通过superclass找到父类(类对象)&lt;/p&gt;

&lt;p&gt;class调用类方法轨迹
isa找meta-class，方法不存在，就通过superclass找父类(元类对象)&lt;/p&gt;

&lt;h2 id=&quot;class的结构&quot;&gt;Class的结构&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022266359919.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;class_rw_t 中存放的是可读写的所有数据，class_ro_t保存的是只读的数据，主要是主类中生成的方法变量协议等property_list_t一维数组。class_rw_t中存放的是包含类别变量协议方法的一个大的二维数组property_array_t，存放主类和类别的小数组数据。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022266740521.jpg&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;方法缓存&quot;&gt;方法缓存&lt;/h2&gt;
&lt;p&gt;class中有个cache_t cache, 用来做方法的缓存，使用哈希表实现。第一次在rw_t中的methods中遍历查找方法实现，找到就放入cache中，节省查找时间。
插入和查询时分别用SEL按位与 mask,得到哈希表的index,解决哈希表冲突的方式是开放地址法，就是往前寻找一位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267154421.png&quot; style=&quot;zoom=50%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在arm64之前，isa是一个普通指针，指向class和meta-class地址
arm64之后， ISA经过优化，使用union数据结构，使用位域来增加存储信息，增加内存利用率
下图中bits为真正存放数据的值，struct中只是申明bits中分别多少位是什么数据。在取值时将bits按位与得到指定位数的值是多少而不受其他位数据的影响。例如shiftcls是存放类地址的，使用了33位。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267618486.jpg&quot; alt=&quot;1&quot; /&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267618501.jpg&quot; alt=&quot;2&quot; /&gt;
&lt;img src=&quot;http://image.smartjames.cn/mweb/20201009/16022267618514.jpg&quot; alt=&quot;3&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 09 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(1)-Class&isa/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/iOS%E5%BA%95%E5%B1%82(1)-Class&isa/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>JSBridge实现原理</title>
        <description>&lt;h2 id=&quot;什么是jsbridge&quot;&gt;什么是JSBridge&lt;/h2&gt;
&lt;p&gt;由于Native和H5的各自特性，尤其的H5的易于部署的适用与双端的特点，使得为了满足业务的需要，公司实际项目的开发过程中往往会融合两者进行 Hybrid 开发。
JSBridge 是一种 JS 实现的 Bridge，连接着桥两端的 Native 和 H5。它在 APP 内方便地让 Native 调用 JS，JS 调用 Native ，是双向通信的通道。&lt;/p&gt;
&lt;h2 id=&quot;为什么要做jsbridge&quot;&gt;为什么要做JSBridge&lt;/h2&gt;
&lt;p&gt;我们知道OC调用JS的方法可以通过Webview的evaluateJavaScript:completionHandler: 方法实现，但是解决不了异步问题，当JS需要执行一些耗时操作，就无法立即给OC返回相应结果。
同样JS调用OC的方法没有现成的方法，且也无法解决上面的异步问题。
所以JSBridge的出现，目的是解决OC与JS相互异步调用，且当其中有多个异步回调，要能处理好各回调之间的关系，能够做到类似CS架构。
这样能处理原先很多无法实现的能力，例如获取定位，相机拍照，手机传感器等等需要异步的接口调用能力。&lt;/p&gt;

&lt;h2 id=&quot;怎么实现jsbridge&quot;&gt;怎么实现JSBridge&lt;/h2&gt;
&lt;h3 id=&quot;10版本&quot;&gt;1.0版本&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JS调用Native，通过自定义跳转URL协议头(例如jsbridge://)，并携带相应参数，Native拦截URL并解析来实现。&lt;/li&gt;
  &lt;li&gt;OC调用Native，通过evaluateJavaScript:completionHandler: 且用runloop阻塞当前线程，直到返回结果&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2端各维护一套响应回调和方法回调的映射表，从而实现在通信过程中，即使异步依然可以从映射表中查出回调地址。
流程图如下：
&lt;img src=&quot;http://image.smartjames.cn/mweb/20200929/16013608341218.png&quot; style=&quot;zoom:70%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;20版本&quot;&gt;2.0版本&lt;/h3&gt;
&lt;p&gt;通过JavascriptCore实现,关于JSCore详见&lt;a href=&quot;https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.html&quot;&gt;深入理解JSCore&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 29 Sep 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/09/JSBridge%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
        <guid isPermaLink="true">http://localhost:4000/2020/09/JSBridge%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
