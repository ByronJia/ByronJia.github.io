---
layout: post
title: Flutter原理解析
date: 2021-01-23
tags: Flutter
---

###  Flutter核心原理
#### 架构

![](http://image.smartjames.cn/mweb/20210123/16113907879588.png)

Flutter架构分层设计如上图，从下到上一次为 Embedder、Engine、Framework。
1. Embedder： 操作系统适配层，实现渲染surface设置、线程设置等。
2. Engine: 实现Flutter渲染引擎、文字排版、事件处理、Dart运行时等功能，包括Skia图形绘制库、Dart VM、Text引擎等。其中Skia和Text为上层接口提供了调用底层渲染和排版的能力。Skia是Google开源的二维图形库，用于ChromeOS, Andoird、FirefoxOS等。
3. Framework：是一个用Dart实现的一套基础库，用于处理动画、绘制、手势等。
    1. Material和Cupertino分别是安卓和iOS风格的2套UI控件库。
    2. Widgets是flutter渲染的基本单元
    3. Rendering是渲染层，运行时Rendering会将Widgets构建出Widgets Tree, 经过处理后提供给Skia即Engine层渲染。
    4. Animation、Painting、Gestures分别提供动画功能，基础绘制功能，手势功能。
    5. Foundation提供Framework基础能力，类似iOS中的UIFoundation

#### 渲染流水线
![](http://image.smartjames.cn/mweb/20210124/16114180611048.png)
渲染流水线是由垂直同步信号(VSync)驱动的，当信号到来后，flutter按照流水线执行，最后将渲染的数据传给GPU进行绘制。

Animation阶段： 因为动画会随着每个VSync信号的到来而改变状态，因此动画阶段是第一个阶段。
Build阶段： 这里包括WidgetTree的build、ElementTree的build和计算重绘的差异diff阶段。 
Layout阶段： 这里确认每个元素的位置，尺寸。
Paint阶段： 就是绘制阶段了。
Composition阶段：和上面2个阶段一起组成了渲染的核心组成部分。

#### 渲染过程中的数据结构

Widget Tree ---> Element Tree ---> RenderObject Tree ---> Layers
分别通过 createElement 、createRenderObjet和.layer 时间数据结构的变化

三棵树对应的关系如下图：
![trees](http://image.smartjames.cn/mweb/20210124/16114633031322.png)

#### Widget Tree
第一棵树，是控件实现的基本逻辑单位，是用户对UI界面的描述方式。
需要注意的是，Widget是不可变的,当试图配置信息发生变化时，Flutter会重建Widget来进行更新，这叫simple is fast 思想，从上到下重新创建Widget Tree来进行刷新，思路简单，也不用额外保存影响到的节点。由于Widget只是配置是数据结构，创建是轻量的，销毁也做过优化，不用担心性能问题。

#### Element Tree
第二棵树，是Widget的实例化对象，Widget提供了createElement工程方法来创建Element, 持久存在于运行时的Dart上下文之中，它承载了构建的上下文数据，是连接结构化的配置到最终渲染的桥梁。  
之所以让他持久存在于Dart上下文中而不是像Widget重新构建，因为Element Tree的重新创建和渲染开销会很大所以Element Tree到Renderobject 有一个diff环节，来计算最小重绘区域。
#### RenderObject Tree
第三棵树，渲染对象树，由Element创建并关联到Element.renderObject上，接收Element的信息同步，也是持久地存在于Dart Runtime上下文中，是主要负责实现视图渲染的对象。

RenderObject Tree的显示过程分为4个阶段：
1. 布局：layout
2. 绘制：paint
3. 合成：composition
4. 渲染：rasterize

其中，布局和绘制在RenderObject中完成，Flutter采用深度优先机制遍历渲染树，确定树中各个对象的位置和尺寸，并将它们绘制到不同的图层上，绘制完毕后，交给Skia来合成和渲染。

#### Layers
最后是Layer,他是依附于RenderObject，是绘图操作的载体，也可以缓存绘图操作的结果。Flutter分别在不用的图层上绘图，然后将这些缓存了绘图结果的图层按照规则叠加，得到最终的渲染结果。  
Layer有needsAddScene和subtreeNeedsAddToScene属性，分别表示是否需要加入场景。提供了markNeedsAddToScenc()标记是否需要更新，和iOS 中layoutIfNeeded相同，都是设置需要渲染的flag。

statefulWidget控件发生变化的流程如下图：
![](http://image.smartjames.cn/mweb/20210125/16115412635238.png)



### Layout
只有布局类Widget会触发layout 如 container、padding、align等
每个RenderObject节点需要做两件事：
1. 调用自己的performLayout来计算layout
2. 调用child的layout，把parent的限制传入

递归下去，每个子节点都受到父节点的约束并计算出自己的size，父节点再按照size决定布局。

